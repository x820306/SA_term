Cplusplus!void clearerr ( FILE * stream );
Clear error indicators
Resets both the error and the eof indicators of the stream.

When a i/o function fails either because of an error or because the end of the file has been reached, one of these internal indicators may be set for the stream. The state of these indicators is cleared by a call to this function, or by a call to any of: rewind, fseek, fsetpos and freopen.!cleareer!stream
Pointer to a FILE object that identifies the stream.!None!feof Check end-of-file indicator (function )
ferror Check error indicator (function )
rewind Set position of stream to the beginning (function )!X
Cplusplus!int fclose ( FILE * stream );
Close file
Closes the file associated with the stream and disassociates it.

All internal buffers associated with the stream are disassociated from it and flushed: the content of any unwritten output buffer is written and the content of any unread input buffer is discarded.

Even if the call fails, the stream passed as parameter will no longer be associated with the file nor its buffers.!fclose!stream
Pointer to a FILE object that specifies the stream to be closed.!If the stream is successfully closed, a zero value is returned.
On failure, EOF is returned.!fopen Open file (function )
fflush Flush stream (function )!X
Cplusplus!int feof ( FILE * stream );
Check end-of-file indicator
Checks whether the end-of-File indicator associated with stream is set, returning a value different from zero if it is.

This indicator is generally set by a previous operation on the stream that attempted to read at or past the end-of-file.

Notice that stream's internal position indicator may point to the end-of-file for the next operation, but still, the end-of-file indicator may not be set until an operation attempts to read at that point.

This indicator is cleared by a call to clearerr, rewind, fseek, fsetpos or freopen. Although if the position indicator is not repositioned by such a call, the next i/o operation is likely to set the indicator again.!feof!stream
Pointer to a FILE object that identifies the stream.!A non-zero value is returned in the case that the end-of-file indicator associated with the stream is set.
Otherwise, zero is returned.!clearerr Clear error indicators (function )
ferror Check error indicator (function )!X
Cplusplus!int ferror ( FILE * stream );
Check error indicator
Checks if the error indicator associated with stream is set, returning a value different from zero if it is.

This indicator is generally set by a previous operation on the stream that failed, and is cleared by a call to clearerr, rewind or freopen.!ferror!stream
Pointer to a FILE object that identifies the stream.!A non-zero value is returned in the case that the error indicator associated with the stream is set.
Otherwise, zero is returned.!feof Check end-of-file indicator (function )
clearerr Clear error indicators (function )
perror Print error message (function )!X
Cplusplus!int fflush ( FILE * stream );
Flush stream
If the given stream was open for writing (or if it was open for updating and the last i/o operation was an output operation) any unwritten data in its output buffer is written to the file.

If stream is a null pointer, all such streams are flushed.

In all other cases, the behavior depends on the specific library implementation. In some implementations, flushing a stream open for reading causes its input buffer to be cleared (but this is not portable expected behavior).

The stream remains open after this call.

When a file is closed, either because of a call to fclose or because the program terminates, all the buffers associated with it are automatically flushed.!fflush!stream
Pointer to a FILE object that specifies a buffered stream.!A zero value indicates success.
If an error occurs, EOF is returned and the error indicator is set (see ferror).!fclose Close file (function )
fopen Open file (function )
setbuf Set stream buffer (function )
setvbuf Change stream buffering (function )!X
Cplusplus!int fgetc ( FILE * stream );
Get character from stream
Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character.

If the stream is at the end-of-file when called, the function returns EOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns EOF and sets the error indicator for the stream (ferror).

fgetc and getc are equivalent, except that getc may be implemented as a macro in some libraries.!fgetc!stream
Pointer to a FILE object that identifies an input stream.!On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the position indicator was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stream.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!getc Get character from stream (function )
fputc Write character to stream (function )
fread Read block of data from stream (function )
fscanf Read formatted data from stream (function )!X
Cplusplus!int fgetpos ( FILE * stream, fpos_t * pos );
Get current position in stream
Retrieves the current position in the stream.

The function fills the fpos_t object pointed by pos with the information needed from the stream's position indicator to restore the stream to its current position (and multibyte state, if wide-oriented) with a call to fsetpos.

The ftell function can be used to retrieve the current position in the stream as an integer value.!fgetpos!stream
Pointer to a FILE object that identifies the stream.
pos
Pointer to a fpos_t object.
This should point to an object already allocated.!On success, the function returns zero.
In case of error, errno is set to a platform-specific positive value and the function returns a non-zero value.!fsetpos Set position indicator of stream (function )
ftell Get current position in stream (function )
fseek Reposition stream position indicator (function )!X
Cplusplus!char * fgets ( char * str, int num, FILE * stream );
Get string from stream
Reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first.

A newline character makes fgets stop reading, but it is considered a valid character by the function and included in the string copied to str.

A terminating null character is automatically appended after the characters copied to str.

Notice that fgets is quite different from gets: not only fgets accepts a stream argument, but also allows to specify the maximum size of str and includes in the string any ending newline character.
!fgets!str : 
Pointer to an array of chars where the string read is copied.
num : 
Maximum number of characters to be copied into str (including the terminating null-character).
stream :
Pointer to a FILE object that identifies an input stream.
stdin can be used as argument to read from the standard input.
!On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).!fputs Write string to stream (function )
fgetc Get character from stream (function )
gets Get string from stdin (function )!X
Cplusplus!FILE * fopen ( const char * filename, const char * mode );
Open file
Opens the file whose name is specified in the parameter filename and associates it with a stream that can be identified in future operations by the FILE pointer returned.

The operations that are allowed on the stream and how these are performed are defined by the mode parameter.

The returned stream is fully buffered by default if it is known to not refer to an interactive device (see setbuf).

The returned pointer can be disassociated from the file by calling fclose or freopen. All opened files are automatically closed on normal program termination.

The running environment supports at least FOPEN_MAX files open simultaneously.!fopen!filename
C string containing the name of the file to be opened.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
mode
C string containing a file access mode. It can be:
"r" read: Open file for input operations. The file must exist.
"w" write: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file.
"a" append: Open file for output at the end of a file. Output operations always write data at the end of the file, expanding it. Repositioning operations (fseek, fsetpos, rewind) are ignored. The file is created if it does not exist.
"r+" read/update: Open a file for update (both for input and output). The file must exist.
"w+" write/update: Create an empty file and open it for update (both for input and output). If a file with the same name already exists its contents are discarded and the file is treated as a new empty file.
"a+" append/update: Open a file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file. The file is created if it does not exist.
With the mode specifiers above the file is open as a text file. In order to open a file as a binary file, a "b" character has to be included in the mode string. This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").

The new C standard (C2011, which is not part of C++) adds a new standard subspecifier ("x"), that can be appended to any "w" specifier (to form "wx", "wbx", "w+x" or "w+bx"/"wb+x"). This subspecifier forces the function to fail if the file exists, instead of overwriting it.

If additional characters follow the sequence, the behavior depends on the library implementation: some implementations may ignore additional characters so that for example an additional "t" (sometimes used to explicitly state a text file) is accepted.

On some library implementations, opening or creating a text file with update mode may treat the stream instead as a binary file.

Text files are files containing sequences of lines of text. Depending on the environment where the application runs, some special character conversion may occur in input/output operations in text mode to adapt them to a system-specific text file format. Although on some environments no conversions occur and both text files and binary files are treated the same way, using the appropriate mode improves portability.

For files open for update (those which include a "+" sign), on which both input and output operations are allowed, the stream shall be flushed (fflush) or repositioned (fseek, fsetpos, rewind) before a reading operation that follows a writing operation. The stream shall be repositioned (fseek, fsetpos, rewind) before a writing operation that follows a reading operation (whenever that operation did not reach the end-of-file).!If the file is successfully opened, the function returns a pointer to a FILE object that can be used to identify the stream on future operations.
Otherwise, a null pointer is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.
!fclose Close file (function )
freopen Reopen stream with different file or mode (function )
setbuf Set stream buffer (function )
setvbuf Change stream buffering (function )
tmpfile Open a temporary file (function )
tmpnam Generate temporary filename (function )!X
Cplusplus!int fprintf ( FILE * stream, const char * format, ... );
Write formatted data to stream
Writes the C string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.

After the format parameter, the function expects at least as many additional arguments as specified by format.!fprintf !stream
Pointer to a FILE object that identifies an output stream.
format
C string that contains the text to be written to the stream.
It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested.

A format specifier follows this prototype:

%[flags][width][.precision][length]specifier 

Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
specifier Output Example
d or i Signed decimal integer 392
u Unsigned decimal integer 7235
o Unsigned octal 610
x Unsigned hexadecimal integer 7fa
X Unsigned hexadecimal integer (uppercase) 7FA
f Decimal floating point, lowercase 392.65
F Decimal floating point, uppercase 392.65
e Scientific notation (mantissa/exponent), lowercase 3.9265e+2
E Scientific notation (mantissa/exponent), uppercase 3.9265E+2
g Use the shortest representation: %e or %f 392.65
G Use the shortest representation: %E or %F 392.65
a Hexadecimal floating point, lowercase -0xc.90fep-2
A Hexadecimal floating point, uppercase -0XC.90FEP-2
c Character a
s String of characters sample
p Pointer address b8000000
n Nothing printed.
The corresponding argument must be a pointer to a signed int.
The number of characters written so far is stored in the pointed location. 
% A % followed by another % character will write a single % to the stream. %

The format specifier can also contain sub-specifiers: flags, width, .precision and modifiers (in that order), which are optional and follow these specifications:

flags description
- Left-justify within the given field width; Right justification is the default (see width sub-specifier).
+ Forces to preceed the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign.
(space) If no sign is going to be written, a blank space is inserted before the value.
# Used with o, x or X specifiers the value is preceeded with 0, 0x or 0X respectively for values different than zero.
Used with a, A, e, E, f, F, g or G it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.
0 Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier).

width description
(number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.
* The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

.precision description
.number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.
For a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).
For g and G specifiers: This is the maximum number of significant digits to be printed.
For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.
If the period is specified without an explicit value for precision, 0 is assumed.
.* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

The length sub-specifier modifies the length of the data type. This is a chart showing the types used to interpret the corresponding arguments with and without length specifier (if a different type is used, the proper type promotion or conversion is performed, if allowed):
specifiers
length d i u o x X f F e E g G a A c s p n
(none) int unsigned int double int char* void* int*
hh signed char unsigned char     signed char*
h short int unsigned short int     short int*
l long int unsigned long int  wint_t wchar_t*  long int*
ll long long int unsigned long long int     long long int*
j intmax_t uintmax_t     intmax_t*
z size_t size_t     size_t*
t ptrdiff_t ptrdiff_t     ptrdiff_t*
L   long double    
Note that the c specifier takes an int (or wint_t) as argument, but performs the proper conversion to a char value (or a wchar_t) before formatting it for output.

Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. See <cinttypes> for the specifiers for extended types.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!printf Print formatted data to stdout (function )
fscanf Read formatted data from stream (function )
fwrite Write block of data to stream (function )
fputs Write string to stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.
Cplusplus!int fputc ( int character, FILE * stream );
Write character to stream
Writes a character to the stream and advances the position indicator.

The character is written at the position indicated by the internal position indicator of the stream, which is then automatically advanced by one.!fputc!character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.
stream
Pointer to a FILE object that identifies an output stream.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.!putc Write character to stream (function )
fgetc Get character from stream (function )
fwrite Write block of data to stream (function )
fopen Open file (function )!X
Cplusplus!int fputs ( const char * str, FILE * stream );
Write string to stream
Writes the C string pointed by str to the stream.

The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream.

Notice that fputs not only differs from puts in that the destination stream can be specified, but also fputs does not write additional characters, while puts appends a newline character at the end automatically.!fputs!str
C string with the content to be written to stream.
stream
Pointer to a FILE object that identifies an output stream.!On success, a non-negative value is returned.
On error, the function returns EOF and sets the error indicator (ferror).!puts Write string to stdout (function )
fgets Get string from stream (function )
fputc Write character to stream (function )
fprintf Write formatted data to stream (function )
fwrite Write block of data to stream (function )!X
Cplusplus!size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
Read block of data from stream
Reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by ptr.

The position indicator of the stream is advanced by the total amount of bytes read.

The total amount of bytes read if successful is (size*count).!fread!ptr
Pointer to a block of memory with a size of at least (size*count) bytes, converted to a void*.
size
Size, in bytes, of each element to be read.
size_t is an unsigned integral type.
count
Number of elements, each one with a size of size bytes.
size_t is an unsigned integral type.
stream
Pointer to a FILE object that specifies an input stream.!The total number of elements successfully read is returned.
If this number differs from the count parameter, either a reading error occurred or the end-of-file was reached while reading. In both cases, the proper indicator is set, which can be checked with ferror and feof, respectively.
If either size or count is zero, the function returns zero and both the stream state and the content pointed by ptr remain unchanged.
size_t is an unsigned integral type.!fwrite Write block of data to stream (function )
fgetc Get character from stream (function )
fscanf Read formatted data from stream (function )!X
Cplusplus!FILE * freopen ( const char * filename, const char * mode, FILE * stream );
Reopen stream with different file or mode
Reuses stream to either open the file specified by filename or to change its access mode.

If a new filename is specified, the function first attempts to close any file already associated with stream (third parameter) and disassociates it. Then, independently of whether that stream was successfuly closed or not, freopen opens the file specified by filename and associates it with the stream just as fopen would do using the specified mode.

If filename is a null pointer, the function attempts to change the mode of the stream. Although a particular library implementation is allowed to restrict the changes permitted, and under which circumstances.

The error indicator and eof indicator are automatically cleared (as if clearerr was called).

This function is especially useful for redirecting predefined streams like stdin, stdout and stderr to specific files (see the example below).!freopen!filename
C string containing the name of the file to be opened.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
If this parameter is a null pointer, the function attempts to change the mode of the stream, as if the file name currently associated with that stream had been used.
mode
C string containing a file access mode. It can be:
"r" read: Open file for input operations. The file must exist.
"w" write: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file.
"a" append: Open file for output at the end of a file. Output operations always write data at the end of the file, expanding it. Repositioning operations (fseek, fsetpos, rewind) are ignored. The file is created if it does not exist.
"r+" read/update: Open a file for update (both for input and output). The file must exist.
"w+" write/update: Create an empty file and open it for update (both for input and output). If a file with the same name already exists its contents are discarded and the file is treated as a new empty file.
"a+" append/update: Open a file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file. The file is created if it does not exist.
With the mode specifiers above the file is open as a text file. In order to open a file as a binary file, a "b" character has to be included in the mode string. This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").

The new C standard (C2011, wich is not part of C++) adds a new standard subspecifier ("x"), that can be appended to any "w" speficier (to form "wx", "wbx", "w+x" or "w+bx"/"wb+x"). This subspecifier forces the function to fail if the file exists, instead of overwriting it.

If additional characters follow the sequence, the behavior depends on the library implementation: some implementations may ignore additional characters so that for example an additional "t" (sometimes used to explicitly state a text file) is accepted.

On some library implementations, opening or creating a text file with update mode may treat the stream instead as a binary file.
stream
pointer to a FILE object that identifies the stream to be reopened.!If the file is successfully reopened, the function returns the pointer passed as parameter stream, which can be used to identify the reopened stream.
Otherwise, a null pointer is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!fopen Open file (function )
fclose Close file (function )!X
Cplusplus!int fscanf ( FILE * stream, const char * format, ... );
Read formatted data from stream
Reads data from the stream and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!fscanf!stream
Pointer to a FILE object that identifies the input stream to read data from.
format
C string that contains a sequence of characters that control how characters extracted from the stream are treated:
Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
Non-whitespace character, except format specifier (%): Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.
Format specifiers: A sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

A format specifier for fscanf follows this prototype:

%[*][width][length]specifier 

Where the specifier character at the end is the most significant component, since it defines which characters are extracted, their interpretation and the type of its corresponding argument:
specifier Description Characters extracted
i, u Integer Any number of digits, optionally preceded by a sign (+ or -).
Decimal digits assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x hexadecimal digits (0-f).
d Decimal integer Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).
o Octal integer Any number of octal digits (0-7), optionally preceded by a sign (+ or -).
x Hexadecimal integer Any number of hexadecimal digits (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).
f, e, g Floating point number A series of decimal digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by strtod).
Implementations complying with C99 also support hexadecimal floating-point format when preceded by 0x or 0X.
a
c Character The next character. If a width other than 1 is specified, the function reads exactly width characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end.
s String of characters Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.
p Pointer address A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.
[characters] Scanset Any number of the characters specified between the brackets.
A dash (-) that is not the first character may produce non-portable behavior in some library implementations.
[^characters] Negated scanset Any number of characters none of them specified as characters between the brackets.
n Count No input is consumed. The number of characters read so far from stream is stored in the pointed location.
% % A % followed by another % matches a single %.
Except for n, at least one character shall be consumed by any specifier. Otherwise the match fails, and the scan ends there.

The format specifier can also contain sub-specifiers: asterisk (*), width and length (in that order), which are optional and follow these specifications:
sub-specifier description
* An optional starting asterisk indicates that the data is to be read from the stream but ignored (i.e. it is not stored in the location pointed by an argument).
width Specifies the maximum number of characters to be read in the current reading operation (optional).
length One of hh, h, l, ll, j, z, t, L (optional).
This alters the expected type of the storage pointed by the corresponding argument (see below).

This is a chart showing the types expected for the corresponding arguments where input is stored (both with and without a length sub-specifier):
specifiers
length d i u o x f e g a c s [] [^] p n
(none) int* unsigned int* float* char* void** int*
hh signed char* unsigned char*    signed char*
h short int* unsigned short int*    short int*
l long int* unsigned long int* double* wchar_t*  long int*
ll long long int* unsigned long long int*    long long int*
j intmax_t* uintmax_t*    intmax_t*
z size_t* size_t*    size_t*
t ptrdiff_t* ptrdiff_t*    ptrdiff_t*
L   long double*   
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.
These arguments are expected to be pointers: to store the result of a fscanf operation on a regular variable, its name should be preceded by the reference operator (&) (see example).!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!scanf Read formatted data from stdin (function )
fprintf Write formatted data to stream (function )
fread Read block of data from stream (function )
fgets Get string from stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced by C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.
Cplusplus!int fseek ( FILE * stream, long int offset, int origin );
Reposition stream position indicator
Sets the position indicator associated with the stream to a new position.

For streams open in binary mode, the new position is defined by adding offset to a reference position specified by origin.

For streams open in text mode, offset shall either be zero or a value returned by a previous call to ftell, and origin shall necessarily be SEEK_SET.

If the function is called with other values for these arguments, support depends on the particular system and library implementation (non-portable).

The end-of-file internal indicator of the stream is cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to fseek allows to switch between reading and writing.!fseek!stream
Pointer to a FILE object that identifies the stream.
offset
Binary files: Number of bytes to offset from origin.
Text files: Either zero, or a value returned by ftell.
origin
Position used as reference for the offset. It is specified by one of the following constants defined in <cstdio> exclusively to be used as arguments for this function:
Constant Reference position
SEEK_SET Beginning of file
SEEK_CUR Current position of the file pointer
SEEK_END End of file *
* Library implementations are allowed to not meaningfully support SEEK_END (therefore, code using it has no real standard portability).!If successful, the function returns zero.
Otherwise, it returns non-zero value.
If a read or write error occurs, the error indicator (ferror) is set.!ftell Get current position in stream (function )
fsetpos Set position indicator of stream (function )
rewind Set position of stream to the beginning (function )!X
Cplusplus!int fsetpos ( FILE * stream, const fpos_t * pos );
Set position indicator of stream
Restores the current position in the stream to pos.

The internal file position indicator associated with stream is set to the position represented by pos, which is a pointer to an fpos_t object whose value shall have been previously obtained by a call to fgetpos.

The end-of-file internal indicator of the stream is cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to fsetpos allows to switch between reading and writing.

A similar function, fseek, can be used to set arbitrary positions on streams open in binary mode.
!fsetpos!stream
Pointer to a FILE object that identifies the stream.
position
Pointer to a fpos_t object containing a position previously obtained with fgetpos.
!If successful, the function returns zero.
On failure, a non-zero value is returned and errno is set to a system-specific positive value.!fgetpos Get current position in stream (function )
fseek Reposition stream position indicator (function )
rewind Set position of stream to the beginning (function )!X
Cplusplus!long int ftell ( FILE * stream );
Get current position in stream
Returns the current value of the position indicator of the stream.

For binary streams, this is the number of bytes from the beginning of the file.

For text streams, the numerical value may not be meaningful but can still be used to restore the position to the same position later using fseek (if there are characters put back using ungetc still pending of being read, the behavior is undefined).!ftell!stream
Pointer to a FILE object that identifies the stream.!On success, the current value of the position indicator is returned.
On failure, -1L is returned, and errno is set to a system-specific positive value.!fseek Reposition stream position indicator (function )
fgetpos Get current position in stream (function )
rewind Set position of stream to the beginning (function )!X
Cplusplus!size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
Write block of data to stream
Writes an array of count elements, each one with a size of size bytes, from the block of memory pointed by ptr to the current position in the stream.

The position indicator of the stream is advanced by the total number of bytes written.

Internally, the function interprets the block pointed by ptr as if it was an array of (size*count) elements of type unsigned char, and writes them sequentially to stream as if fputc was called for each byte.!fwrite!ptr
Pointer to the array of elements to be written, converted to a const void*.
size
Size in bytes of each element to be written.
size_t is an unsigned integral type.
count
Number of elements, each one with a size of size bytes.
size_t is an unsigned integral type.
stream
Pointer to a FILE object that specifies an output stream.!The total number of elements successfully written is returned.
If this number differs from the count parameter, a writing error prevented the function from completing. In this case, the error indicator (ferror) will be set for the stream.
If either size or count is zero, the function returns zero and the error indicator remains unchanged.
size_t is an unsigned integral type.!fread Read block of data from stream (function )
fprintf Write formatted data to stream (function )
putc Write character to stream (function )
fputc Write character to stream (function )!X
Cplusplus!int getc ( FILE * stream );
Get character from stream
Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character.

If the stream is at the end-of-file when called, the function returns EOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns EOF and sets the error indicator for the stream (ferror).

getc and fgetc are equivalent, except that getc may be implemented as a macro in some libraries. See getchar for a similar function that reads directly from stdin.!getc !stream
Pointer to a FILE object that identifies an input stream.
Because some libraries may implement this function as a macro, and this may evaluate the stream expression more than once, this should be an expression without side effects.!On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the position indicator was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stream.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!fgetc Get character from stream (function )
fputc Write character to stream (function )
fread Read block of data from stream (function )
fwrite Write block of data to stream (function )!X
Cplusplus!int getchar ( void );
Get character from stdin
Returns the next character from the standard input (stdin).

It is equivalent to calling getc with stdin as argument.!getchar!(none) !On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the standard input was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stdin.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!getc Get character from stream (function )
putchar Write character to stdout (function )
scanf Read formatted data from stdin (function )!X
Cplusplus!char * gets ( char * str );
Get string from stdin
Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.

The newline character, if found, is not copied into str.

A terminating null character is automatically appended after the characters copied to str.

Notice that gets is quite different from fgets: not only gets uses stdin as source, but it does not include the ending newline character in the resulting string and does not allow to specify a maximum size for str (which can lead to buffer overflows).!gets!str
Pointer to a block of memory (array of char) where the string read is copied as a C string.!On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).!fgets Get string from stream (function )
getchar Get character from stdin (function )
scanf Read formatted data from stdin (function )!The most recent revision of the C standard (2011) has definitively removed this function from its specification.
The function is deprecated in C++ (as of 2011 standard, which follows C99+TC3).
Cplusplus!void perror ( const char * str );
Print error message
Interprets the value of errno as an error message, and prints it to stderr (the standard error output stream, usually the console), optionally preceding it with the custom message specified in str.

errno is an integral variable whose value describes the error condition or diagnostic information produced by a call to a library function (any function of the C standard library may set a value for errno, even if not explicitly specified in this reference, and even if no error happened), see errno for more info.

The error message produced by perror is platform-depend.

If the parameter str is not a null pointer, str is printed followed by a colon (:) and a space. Then, whether str was a null pointer or not, the generated error description is printed followed by a newline character ('\n').

perror should be called right after the error was produced, otherwise it can be overwritten by calls to other functions.!perror!str
C string containing a custom message to be printed before the error message itself.
If it is a null pointer, no preceding custom message is printed, but the error message is still printed.
By convention, the name of the application itself is generally used as parameter.
!none !clearerr Clear error indicators (function )
ferror Check error indicator (function )!X
Cplusplus!int printf ( const char * format, ... );
Print formatted data to stdout
Writes the C string pointed by format to the standard output (stdout). If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.!printf!format
C string that contains the text to be written to stdout.
It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested.

A format specifier follows this prototype: [see compatibility note below] 
%[flags][width][.precision][length]specifier 

Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
specifier Output Example
d or i Signed decimal integer 392
u Unsigned decimal integer 7235
o Unsigned octal 610
x Unsigned hexadecimal integer 7fa
X Unsigned hexadecimal integer (uppercase) 7FA
f Decimal floating point, lowercase 392.65
F Decimal floating point, uppercase 392.65
e Scientific notation (mantissa/exponent), lowercase 3.9265e+2
E Scientific notation (mantissa/exponent), uppercase 3.9265E+2
g Use the shortest representation: %e or %f 392.65
G Use the shortest representation: %E or %F 392.65
a Hexadecimal floating point, lowercase -0xc.90fep-2
A Hexadecimal floating point, uppercase -0XC.90FEP-2
c Character a
s String of characters sample
p Pointer address b8000000
n Nothing printed.
The corresponding argument must be a pointer to a signed int.
The number of characters written so far is stored in the pointed location. 
% A % followed by another % character will write a single % to the stream. %

The format specifier can also contain sub-specifiers: flags, width, .precision and modifiers (in that order), which are optional and follow these specifications:

flags description
- Left-justify within the given field width; Right justification is the default (see width sub-specifier).
+ Forces to preceed the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign.
(space) If no sign is going to be written, a blank space is inserted before the value.
# Used with o, x or X specifiers the value is preceeded with 0, 0x or 0X respectively for values different than zero.
Used with a, A, e, E, f, F, g or G it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.
0 Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier).

width description
(number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.
* The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

.precision description
.number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.
For a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).
For g and G specifiers: This is the maximum number of significant digits to be printed.
For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.
If the period is specified without an explicit value for precision, 0 is assumed.
.* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

The length sub-specifier modifies the length of the data type. This is a chart showing the types used to interpret the corresponding arguments with and without length specifier (if a different type is used, the proper type promotion or conversion is performed, if allowed):
specifiers
length d i u o x X f F e E g G a A c s p n
(none) int unsigned int double int char* void* int*
hh signed char unsigned char     signed char*
h short int unsigned short int     short int*
l long int unsigned long int  wint_t wchar_t*  long int*
ll long long int unsigned long long int     long long int*
j intmax_t uintmax_t     intmax_t*
z size_t size_t     size_t*
t ptrdiff_t ptrdiff_t     ptrdiff_t*
L   long double    
Note that the c specifier takes an int (or wint_t) as argument, but performs the proper conversion to a char value (or a wchar_t) before formatting it for output.

Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. See <cinttypes> for the specifiers for extended types.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!puts Write string to stdout (function )
scanf Read formatted data from stdin (function )
fprintf Write formatted data to stream (function )
fwrite Write block of data to stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.
Cplusplus!int putc ( int character, FILE * stream );
Write character to stream
Writes a character to the stream and advances the position indicator.

The character is written at the position indicated by the internal position indicator of the stream, which is then automatically advanced by one.

putc and fputc are equivalent, except that putc may be implemented as a macro in some libraries. See putchar for a similar function that writes directly to stdout.!putc !character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.
Because some libraries may implement this function as a macro, and this may evaluate the stream expression more than once, this should be an expression without side effects.
stream
Pointer to a FILE object that identifies an output stream.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.
!putchar Write character to stdout (function )
fputc Write character to stream (function )
getc Get character from stream (function )
fwrite Write block of data to stream (function )
fprintf Write formatted data to stream (function )!X
Cplusplus!int putchar ( int character );
Write character to stdout
Writes a character to the standard output (stdout).

It is equivalent to calling putc with stdout as second argument.!putchar!character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.!putc Write character to stream (function )
fputc Write character to stream (function )
getchar Get character from stdin (function )!X
Cplusplus!int puts ( const char * str );
Write string to stdout
Writes the C string pointed by str to the standard output (stdout) and appends a newline character ('\n').

The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream.

Notice that puts not only differs from fputs in that it uses stdout as destination, but it also appends a newline character at the end automatically (which fputs does not).!puts!str
C string to be printed.
!On success, a non-negative value is returned.
On error, the function returns EOF and sets the error indicator (ferror).
!fputs Write string to stream (function )
printf Print formatted data to stdout (function )
putchar Write character to stdout (function )
gets Get string from stdin (function )!X
Cplusplus!int remove ( const char * filename );
Remove file
Deletes the file whose name is specified in filename.

This is an operation performed directly on a file identified by its filename; No streams are involved in the operation.

Proper file access shall be available.!remove!filename
C string containing the name of the file to be deleted.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).!If the file is successfully deleted, a zero value is returned.
On failure, a nonzero value is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!rename Rename file (function )!X
Cplusplus!int rename ( const char * oldname, const char * newname );
Rename file
Changes the name of the file or directory specified by oldname to newname.

This is an operation performed directly on a file; No streams are involved in the operation.

If oldname and newname specify different paths and this is supported by the system, the file is moved to the new location.

If newname names an existing file, the function may either fail or override the existing file, depending on the specific system and library implementation.

Proper file access shall be available.!rename!oldname
C string containing the name of an existing file to be renamed and/or moved.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
newname
C string containing the new name for the file.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).!If the file is successfully renamed, a zero value is returned.
On failure, a nonzero value is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!remove Remove file (function )!X
Cplusplus!void rewind ( FILE * stream );
Set position of stream to the beginning
Sets the position indicator associated with stream to the beginning of the file.

The end-of-file and error internal indicators associated to the stream are cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to rewind allows to switch between reading and writing.!rewind !stream
Pointer to a FILE object that identifies the stream.!none!fseek Reposition stream position indicator (function )
fsetpos Set position indicator of stream (function )
fflush Flush stream (function )!X
Cplusplus!int scanf ( const char * format, ... );
Read formatted data from stdin
Reads data from stdin and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!scanf!format
C string that contains a sequence of characters that control how characters extracted from the stream are treated:
Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
Non-whitespace character, except format specifier (%): Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.
Format specifiers: A sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

A format specifier for scanf follows this prototype:

%[*][width][length]specifier 

Where the specifier character at the end is the most significant component, since it defines which characters are extracted, their interpretation and the type of its corresponding argument:
specifier Description Characters extracted
i, u Integer Any number of digits, optionally preceded by a sign (+ or -).
Decimal digits assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x hexadecimal digits (0-f).
d Decimal integer Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).
o Octal integer Any number of octal digits (0-7), optionally preceded by a sign (+ or -).
x Hexadecimal integer Any number of hexadecimal digits (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).
f, e, g Floating point number A series of decimal digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by strtod).
Implementations complying with C99 also support hexadecimal floating-point format when preceded by 0x or 0X.
a
c Character The next character. If a width other than 1 is specified, the function reads exactly width characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end.
s String of characters Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.
p Pointer address A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.
[characters] Scanset Any number of the characters specified between the brackets.
A dash (-) that is not the first character may produce non-portable behavior in some library implementations.
[^characters] Negated scanset Any number of characters none of them specified as characters between the brackets.
n Count No input is consumed.
The number of characters read so far from stdin is stored in the pointed location.
% % A % followed by another % matches a single %.
Except for n, at least one character shall be consumed by any specifier. Otherwise the match fails, and the scan ends there.

The format specifier can also contain sub-specifiers: asterisk (*), width and length (in that order), which are optional and follow these specifications:
sub-specifier description
* An optional starting asterisk indicates that the data is to be read from the stream but ignored (i.e. it is not stored in the location pointed by an argument).
width Specifies the maximum number of characters to be read in the current reading operation (optional).
length One of hh, h, l, ll, j, z, t, L (optional).
This alters the expected type of the storage pointed by the corresponding argument (see below).

This is a chart showing the types expected for the corresponding arguments where input is stored (both with and without a length sub-specifier):
specifiers
length d i u o x f e g a c s [] [^] p n
(none) int* unsigned int* float* char* void** int*
hh signed char* unsigned char*    signed char*
h short int* unsigned short int*    short int*
l long int* unsigned long int* double* wchar_t*  long int*
ll long long int* unsigned long long int*    long long int*
j intmax_t* uintmax_t*    intmax_t*
z size_t* size_t*    size_t*
t ptrdiff_t* ptrdiff_t*    ptrdiff_t*
L   long double*   
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.
These arguments are expected to be pointers: to store the result of a scanf operation on a regular variable, its name should be preceded by the reference operator (&) (see example).!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.
!fscanf Read formatted data from stream (function )
printf Print formatted data to stdout (function )
gets Get string from stdin (function )
fopen Open file (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced by C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.
Cplusplus!void setbuf ( FILE * stream, char * buffer );
Set stream buffer
Specifies the buffer to be used by the stream for I/O operations, which becomes a fully buffered stream. Or, alternatively, if buffer is a null pointer, buffering is disabled for the stream, which becomes an unbuffered stream.

This function should be called once the stream has been associated with an open file, but before any input or output operation is performed with it.

The buffer is assumed to be at least BUFSIZ bytes in size (see setvbuf to specify a size of the buffer).

A stream buffer is a block of data that acts as intermediary between the i/o operations and the physical file associated to the stream: For output buffers, data is output to the buffer until its maximum capacity is reached, then it is flushed (i.e.: all data is sent to the physical file at once and the buffer cleared). Likewise, input buffers are filled from the physical file, from which data is sent to the operations until exhausted, at which point new data is acquired from the file to fill the buffer again.

Stream buffers can be explicitly flushed by calling fflush. They are also automatically flushed by fclose and freopen, or when the program terminates normally.

A full buffered stream uses the entire size of the buffer as buffer whenever enough data is available (see setvbuf for other buffer modes).

All files are opened with a default allocated buffer (fully buffered) if they are known to not refer to an interactive device. This function can be used to either set a specific memory block to be used as buffer or to disable buffering for the stream.

The default streams stdin and stdout are fully buffered by default if they are known to not refer to an interactive device. Otherwise, they may either be line buffered or unbuffered by default, depending on the system and library implementation. The same is true for stderr, which is always either line buffered or unbuffered by default.

A call to this function is equivalent to calling setvbuf with _IOFBF as mode and BUFSIZ as size (when buffer is not a null pointer), or equivalent to calling it with _IONBF as mode (when it is a null pointer).!setbuf!stream
Pointer to a FILE object that identifies an open stream.
buffer
User allocated buffer. Shall be at least BUFSIZ bytes long.
Alternatively, a null pointer can be specified to disable buffering.!none!setvbuf Change stream buffering (function )
fopen Open file (function )
fflush Flush stream (function )!X
Cplusplus!int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );
Change stream buffering
Specifies a buffer for stream. The function allows to specify the mode and size of the buffer (in bytes).

If buffer is a null pointer, the function automatically allocates a buffer (using size as a hint on the size to use). Otherwise, the array pointed by buffer may be used as a buffer of size bytes.

This function should be called once the stream has been associated with an open file, but before any input or output operation is performed with it.

A stream buffer is a block of data that acts as intermediary between the i/o operations and the physical file associated to the stream: For output buffers, data is output to the buffer until its maximum capacity is reached, then it is flushed (i.e.: all data is sent to the physical file at once and the buffer cleared). Likewise, input buffers are filled from the physical file, from which data is sent to the operations until exhausted, at which point new data is acquired from the file to fill the buffer again.

Stream buffers can be explicitly flushed by calling fflush. They are also automatically flushed by fclose and freopen, or when the program terminates normally.

All files are opened with a default allocated buffer (fully buffered) if they are known to not refer to an interactive device. This function can be used to either redefine the buffer size or mode, to define a user-allocated buffer or to disable buffering for the stream.

The default streams stdin and stdout are fully buffered by default if they are known to not refer to an interactive device. Otherwise, they may either be line buffered or unbuffered by default, depending on the system and library implementation. The same is true for stderr, which is always either line buffered or unbuffered by default.!setvbuf!stream
Pointer to a FILE object that identifies an open stream.
buffer
User allocated buffer. Shall be at least size bytes long.
If set to a null pointer, the function automatically allocates a buffer.
mode
Specifies a mode for file buffering. Three special macro constants (_IOFBF, _IOLBF and _IONBF) are defined in <cstdio> to be used as the value for this parameter:
_IOFBF Full buffering: On output, data is written once the buffer is full (or flushed). On Input, the buffer is filled when an input operation is requested and the buffer is empty.
_IOLBF Line buffering: On output, data is written when a newline character is inserted into the stream or when the buffer is full (or flushed), whatever happens first. On Input, the buffer is filled up to the next newline character when an input operation is requested and the buffer is empty.
_IONBF No buffering: No buffer is used. Each I/O operation is written as soon as possible. In this case, the buffer and size parameters are ignored.
size
Buffer size, in bytes.
If the buffer argument is a null pointer, this value may determine the size automatically allocated by the function for the buffer.!If the buffer is correctly assigned to the file, a zero value is returned.
Otherwise, a non-zero value is returned; This may be due to an invalid mode parameter or to some other error allocating or assigning the buffer.!setbuf Set stream buffer (function )
fopen Open file (function )
fflush Flush stream (function )!X
Cplusplus!int snprintf ( char * s, size_t n, const char * format, ... );
Write formatted output to sized buffer
Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by s (taking n as the maximum buffer capacity to fill).

If the resulting string would be longer than n-1 characters, the remaining characters are discarded and not stored, but counted for the value returned by the function.

A terminating null character is automatically appended after the content written.

After the format parameter, the function expects at least as many additional arguments as needed for format.!snprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should have a size of at least n characters.
n
Maximum number of bytes to be used in the buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null character.
size_t is an unsigned integral type.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!The number of characters that would have been written if n had been sufficiently large, not counting the terminating null character.
If an encoding error occurs, a negative number is returned.
Notice that only when this returned value is non-negative and less than n, the string has been completely written.
!printf Print formatted data to stdout (function )
sprintf Write formatted data to string (function )
strcat Concatenate strings (function )
sscanf Read formatted data from string (function )!X
Cplusplus!int sprintf ( char * str, const char * format, ... );
Write formatted data to string
Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by str.

The size of the buffer should be large enough to contain the entire resulting string (see snprintf for a safer version).

A terminating null character is automatically appended after the content.

After the format parameter, the function expects at least as many additional arguments as needed for format.!sprintf!str
Pointer to a buffer where the resulting C-string is stored.
The buffer should be large enough to contain the resulting string.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned. This count does not include the additional null-character automatically appended at the end of the string.
On failure, a negative number is returned.!snprintf Write formatted output to sized buffer (function )
printf Print formatted data to stdout (function )
sscanf Read formatted data from string (function )!X
Cplusplus!int sscanf ( const char * s, const char * format, ...);
Read formatted data from string
Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin).

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!sscanf!s
C string that the function processes as its source to retrieve the data.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.!scanf Read formatted data from stdin (function )
sprintf Write formatted data to string (function )!X
Cplusplus!FILE * tmpfile ( void );
Open a temporary file
Creates a temporary binary file, open for update ("wb+" mode, see fopen for details) with a filename guaranteed to be different from any other existing file.

The temporary file created is automatically deleted when the stream is closed (fclose) or when the program terminates normally. If the program terminates abnormally, whether the file is deleted depends on the specific system and library implementation.!tmpfile!none!If successful, the function returns a stream pointer to the temporary file created.
On failure, NULL is returned.!fopen Open file (function )
tmpnam Generate temporary filename (function )!X
Cplusplus!char * tmpnam ( char * str );
Generate temporary filename
Returns a string containing a file name different from the name of any existing file, and thus suitable to safely create a temporary file without risking to overwrite an existing file.

If str is a null pointer, the resulting string is stored in an internal static array that can be accessed by the return value. The content of this string is preserved at least until a subsequent call to this same function, which may overwrite it.

If str is not a null pointer, it shall point to an array of at least L_tmpnam characters that will be filled with the proposed temporary file name.

The file name returned by this function can be used to create a regular file using fopen to be used as a temporary file. The file created this way, unlike those created with tmpfile is not automatically deleted when closed; A program shall call remove to delete this file once closed.!tmpnam!str
Pointer to an array of characters where the proposed temporary name will be stored as a C string. The suggested size of this array is at least L_tmpnam characters.
Alternativelly, a null pointer can be specified to use an internal static array to store the proposed temporary name, whose pointer is returned by the function.!On success, a pointer to the C string containing the proposed name for a temporary file:
If str was a null pointer, this points to an internal buffer (whose content is preserved at least until the next call to this function).
If str was not a null pointer, str is returned.
If the function fails to create a suitable filename, it returns a null pointer.!fopen Open file (function )
tmpfile Open a temporary file (function )!X
Cplusplus!int ungetc ( int character, FILE * stream );
Unget character from stream
A character is virtually put back into an input stream, decreasing its internal file position as if a previous getc operation was undone.

This character may or may not be the one read from the stream in the preceding input operation. In any case, the next character retrieved from stream is the character passed to this function, independently of the original one.

Notice though, that this only affects further input operations on that stream, and not the content of the physical file associated with it, which is not modified by any calls to this function.

Some library implementations may support this function to be called multiple times, making the characters available in the reverse order in which they were put back. Although this behavior has no standard portability guarantees, and further calls may simply fail after any number of calls beyond the first.

If successful, the function clears the end-of-file indicator of stream (if it was currently set), and decrements its internal file position indicator if it operates in binary mode; In text mode, the position indicator has unspecified value until all characters put back with ungetc have been read or discarded.

A call to fseek, fsetpos or rewind on stream will discard any characters previously put back into it with this function.

If the argument passed for the character parameter is EOF, the operation fails and the input stream remains unchanged.
!ungetc!character
The int promotion of the character to be put back.
The value is internally converted to an unsigned char when put back.
stream
Pointer to a FILE object that identifies an input stream.!On success, the character put back is returned.
If the operation fails, EOF is returned.!getc Get character from stream (function )
fgetc Get character from stream (function )
putc Write character to stream (function )!X
Cplusplus!int vfprintf ( FILE * stream, const char * format, va_list arg );
Write formatted data from variable argument list to stream
Writes the C string pointed by format to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vfprintf!stream
Pointer to a FILE object that identifies an output stream.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!vprintf Print formatted data from variable argument list to stdout (function )
vsprintf Write formatted data from variable argument list to string (function )
fprintf Write formatted data to stream (function )
printf Print formatted data to stdout (function )!X
Cplusplus!int vfscanf ( FILE * stream, const char * format, va_list arg );
Read formatted data from stream into variable argument list
Reads data from the stream and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vfscanf!stream
Pointer to a FILE object that identifies an input stream.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!vscanf Read formatted data into variable argument list (function )
vsscanf Read formatted data from string into variable argument list (function )
fscanf Read formatted data from stream (function )
scanf Read formatted data from stdin (function )!X
Cplusplus!int vprintf ( const char * format, va_list arg );
Print formatted data from variable argument list to stdout
Writes the C string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.
!vprintf!format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!vfprintf Write formatted data from variable argument list to stream (function )
vsprintf Write formatted data from variable argument list to string (function )
printf Print formatted data to stdout (function )!X
Cplusplus!int vscanf ( const char * format, va_list arg );
Read formatted data into variable argument list
Reads data from the standard input (stdin) and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vscanf!format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.
!vfscanf Read formatted data from stream into variable argument list (function )
vsscanf Read formatted data from string into variable argument list (function )
fscanf Read formatted data from stream (function )
scanf Read formatted data from stdin (function )!X
Cplusplus!int vsnprintf (char * s, size_t n, const char * format, va_list arg );
Write formatted data from variable argument list to sized buffer
Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by s (taking n as the maximum buffer capacity to fill).

If the resulting string would be longer than n-1 characters, the remaining characters are discarded and not stored, but counted for the value returned by the function.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsnprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should have a size of at least n characters.
n
Maximum number of bytes to be used in the buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null character.
size_t is an unsigned integral type.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!The number of characters that would have been written if n had been sufficiently large, not counting the terminating null character.
If an encoding error occurs, a negative number is returned.
Notice that only when this returned value is non-negative and less than n, the string has been completely written.!vfprintf Write formatted data from variable argument list to stream (function )
vprintf Print formatted data from variable argument list to stdout (function )
sprintf Write formatted data to string (function )
printf Print formatted data to stdout (function )!X
Cplusplus!int vsprintf (char * s, const char * format, va_list arg );
Write formatted data from variable argument list to string
Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by s.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should be large enough to contain the resulting string.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.
!On success, the total number of characters written is returned.
On failure, a negative number is returned.!vfprintf Write formatted data from variable argument list to stream (function )
vprintf Print formatted data from variable argument list to stdout (function )
sprintf Write formatted data to string (function )
printf Print formatted data to stdout (function )!X
Cplusplus!int vsscanf ( const char * s, const char * format, va_list arg );
Read formatted data from string into variable argument list
Reads data from s and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsscanf!s
C string that the function processes as its source to retrieve the data.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less -even zero- in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.!vscanf Read formatted data into variable argument list (function )
vfscanf Read formatted data from stream into variable argument list (function )
sscanf Read formatted data from string (function )
scanf Read formatted data from stdin (function )
vsprintf Write formatted data from variable argument list to string (function )!X
Cplusplus!FILE * stderr;
Standard error stream
The standard error stream is the default destination for error messages and other diagnostic warnings. Like stdout, it is usually also directed by default to the text console (generally, on the screen).

stderr can be used as an argument for any function that takes an argument of type FILE* expecting an output stream, like fputs or fprintf.

Although in many cases both stdout and stderr are associated with the same output device (like the console), applications may differentiate between what is sent to stdout and what to stderr for the case that one of them is redirected. For example, it is frequent to redirect the regular output of a console program (stdout) to a file while expecting the error messages to keep appearing in the console.

It is also possible to redirect stderr to some other destination from within a program using the freopen function.

stderr is is never fully buffered on startup. It is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stderr!X!X!stdin Standard input stream (object )
stdout Standard output stream (object )!X
Cplusplus!FILE * stdin;
Standard input stream
The standard input stream is the default source of data for applications. In most systems, it is usually directed by default to the keyboard.

stdin can be used as an argument for any function that expects an input stream (FILE*) as one of its parameters, like fgets or fscanf.

Although it is commonly assumed that the source of data for stdin is going to be a keyboard, this may not be the case even in regular console systems, since stdin can generally be redirected on most operating systems at the time of invoking the application. For example, many systems, among them DOS/Windows and most UNIX shells, support the following command syntax:

myapplication < example.txt 

to use the content of the file example.txt as the primary source of data for myapplication instead of the console keyboard.

It is also possible to redirect stdin to some other source of data from within a program by using the freopen function.

If stdin is known to not refer to an interactive device, the stream is fully buffered. Otherwise, it is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stdin!X!X!stdout Standard output stream (object )
stderr Standard error stream (object )!X
Cplusplus!FILE * stdout;
Standard output stream
The standard output stream is the default destination of output for applications. In most systems, it is usually directed by default to the text console (generally, on the screen).

stdout can be used as an argument for any function that takes an argument of type FILE* expecting an output stream, like fputs or fprintf.

Although it is commonly assumed that the default destination for stdout is going to be the screen, this may not be the case even in regular console systems, since stdout can generally be redirected on most operating systems at the time of invoking the application. For example, many systems, among them DOS/Windows and most UNIX shells, support the following command syntax:

myapplication > example.txt 
to redirect the output of myapplication to the file example.txt instead of the console.

It is also possible to redirect stdout to some other source of data from within a program using the freopen function.

If stdout is known to not refer to an interactive device, the stream is fully buffered. Otherwise, it is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stdout!X!X!stdin Standard input stream (object )
stderr Standard error stream (object )!X
Cplusplus!Object containing information to control a stream
Object type that identifies a stream and contains the information needed to control it, including a pointer to its buffer, its position indicator and all its state indicators.

FILE objects are usually created by a call to either fopen or tmpfile, which both return a pointer to one of these objects.

The content of a FILE object is not meant to be accessed from outside the functions of the <cstdio> and <cwchar> headers; In fact, portable programs shall only use them in the form of pointers to identify streams, since for some implementations, even the value of the pointer itself could be significant to identify the stream (i.e., the pointer to a copy of a FILE object could be interpreted differently than a pointer to the original).

Its memory allocation is automatically managed: it is allocated by either fopen or tmpfile, and it is the responsibility of the library to free the resources once either the stream has been closed using fclose or the program terminates normally.

On inclusion of the <cstdio> header file, three objects of this type are automatically created, and pointers to them are declared: stdin, stdout and stderr, associated with the standard input stream, standard output stream and standard error stream, respectively.!FILE!X!X!fopen Open file (function )
fclose Close file (function )!X
Cplusplus!Object containing information to specify a position within a file
This type of object is used to specify a position within a file. An object of this type is capable of specifying uniquely any position within a file.

The information in fpos_t objects is usually filled by a call to fgetpos, which takes a pointer to an object of this type as argument.

The content of an fpos_t object is not meant to be read directly, but only to be used as an argument in a call to fsetpos.!fpos_t!X!X!X!X
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.

In <cstdio>, it is used as the type of some parameters in the functions fread, fwrite and setvbuf, and in the case of fread and fwrite also as its returning type.!size_t!X!X!X!X
Cplusplus!Buffer size
This macro constant expands to an integral expression with the size of the buffer used by the setbuf function.!BUFSIZ!X!X!setbuf Set stream buffer (function )!X
Cplusplus!End-of-File
It is a macro definition of type int that expands into a negative integral constant expression (generally, -1).

It is used as the value returned by several functions in header <cstdio> to indicate that the End-of-File has been reached or to signal some other failure conditions.

It is also used as the value to represent an invalid character.

In C++, this macro corresponds to the value of char_traits<char>::eof().
!EOF!X!X!feof Check end-of-file indicator (function )
ferror Check error indicator (function )!X
Cplusplus!Maximum length of file names
This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string allowed by the library. Or, if the library imposes no such restriction, it is set to the recommended size for character arrays intended to hold a file name.
!FILENAME_MAX!X!X!L_tmpnam Minimum length for temporary file name (constant )
FOPEN_MAX Potential limit of simultaneous open streams (constant )
TMP_MAX Number of temporary files (constant )!X
Cplusplus!Potential limit of simultaneous open streams
This macro constant expands to an integral expression representing the minimum number of files that can be open simultaneously.

Particular library implementations may count files opened by tmpfile towards this limit.

FOPEN_MAX is a value greater than 7.!FOPEN_MAX!X!X!TMP_MAX Number of temporary files (constant )!X
Cplusplus!Minimum length for temporary file name
This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string possibly generated by tmpnam.
!L_tmpnam!X!X!FILENAME_MAX Maximum length of file names (constant )
FOPEN_MAX Potential limit of simultaneous open streams (constant )
TMP_MAX Number of temporary files (constant )!X
Cplusplus!Null pointer
This macro expands to a null pointer constant.!NULL!X!X!X!X
Cplusplus!Number of temporary files
This macro expands to the minimum number of unique temporary file names that are guaranteed to be possible to generate using tmpnam.

This value cannot be lower than 25.

Particular library implementations may count file names used by files created with tmpfile towards this limit.!TMP_MAX!X!X!FOPEN_MAX Potential limit of simultaneous open streams (constant )!X
Cplusplus!void assert (int expression);
Evaluate assertion
If the argument expression of this macro with functional form compares equal to zero (i.e., the expression is false), a message is written to the standard error device and abort is called, terminating the program execution.

The specifics of the message shown depend on the particular library implementation, but it shall at least include: the expression whose assertion failed, the name of the source file, and the line number where it happened. A usual expression format is:

Assertion failed: expression, file filename, line line number 

This macro is disabled if, at the moment of including <assert.h>, a macro with the name NDEBUG has already been defined. This allows for a coder to include as many assert calls as needed in a source code while debugging the program and then disable all of them for the production version by simply including a line like:
 
#define NDEBUG 

at the beginning of its code, before the inclusion of <assert.h>.

Therefore, this macro is designed to capture programming errors, not user or run-time errors, since it is generally disabled after a program exits its debugging phase.
!assert!expression
Expression to be evaluated. If this expression evaluates to 0, this causes an assertion failure that terminates the program.!none!X!X
Cplusplus!int isalnum ( int c );
Check if character is alphanumeric
Checks whether c is either a decimal digit or an uppercase or lowercase letter.

The result is true if either isalpha or isdigit would also return true.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, what constitutes a letter is what returns true by either isupper or islower.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isalnum) exists in header <locale>.!isalnum!c
Character to be checked, casted as an int, or EOF.!A value different from zero (i.e., true) if indeed c is either a digit or a letter. Zero (i.e., false) otherwise.
!isalpha Check if character is alphabetic (function )
isdigit Check if character is decimal digit (function )!X
Cplusplus!int isalpha ( int c );
Check if character is alphabetic
Checks whether c is an alphabetic letter.

Notice that what is considered a letter depends on the locale being used; In the default "C" locale, what constitutes a letter is only what returns true by either isupper or islower.

Using other locales, an alphabetic character is a character for which isupper or islower would return true, or another character explicitly considered alphabetic by the locale (in this case, the character cannot be iscntrl, isdigit, ispunct or isspace).

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isalpha) exists in header <locale>.!isalpha!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is an alphabetic letter. Zero (i.e., false) otherwise.!isalnum Check if character is alphanumeric (function )
isdigit Check if character is decimal digit (function )!X
Cplusplus!int isblank ( int c );
Check if character is blank
Checks whether c is a blank character.

A blank character is a space character used to separate words within a line of text.

The standard "C" locale considers blank characters the tab character ('\t') and the space character (' ').

Other locales may consider blank a different selection of characters, but they must all also be space characters by isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isblank) exists in header <locale>.

Compatibility note: Standardized in C99 (C++11).!isblank!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a blank character. Zero (i.e., false) otherwise.!isspace Check if character is a white-space (function )
isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )
isalnum Check if character is alphanumeric (function )
isblank (locale) Check if character is blank using locale (function template )!X
Cplusplus!int iscntrl ( int c );
Check if character is a control character
Checks whether c is a control character.

A control character is a character that does not occupy a printing position on a display (this is the opposite of a printable character, checked with isprint).

For the standard ASCII character set (used by the "C" locale), control characters are those between ASCII codes 0x00 (NUL) and 0x1f (US), plus 0x7f (DEL).

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (iscntrl) exists in header <locale>.!iscntrl!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a control character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )!X
Cplusplus!int isdigit ( int c );
Check if character is decimal digit
Checks whether c is a decimal digit character.

Decimal digits are any of: 0 1 2 3 4 5 6 7 8 9 

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isdigit) exists in header <locale>.!isdigit!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a decimal digit. Zero (i.e., false) otherwise.!isalnum Check if character is alphanumeric (function )
isalpha Check if character is alphabetic (function )!X
Cplusplus!int isgraph ( int c );
Check if character has graphical representation
Checks whether c is a character with graphical representation.

The characters with graphical representation are all those characters than can be printed (as determined by isprint) except the space character (' ').

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isgraph) exists in header <locale>.!isgraph!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c has a graphical representation as character. Zero (i.e., false) otherwise.!isprint Check if character is printable (function )
isspace Check if character is a white-space (function )
isalnum Check if character is alphanumeric (function )!X
Cplusplus!int islower ( int c );
Check if character is lowercase letter
Checks whether c is a lowercase letter.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, a lowercase letter is any of: a b c d e f g h i j k l m n o p q r s t u v w x y z.

Other locales may consider a different selection of characters as lowercase characters, but never characters that returns true for iscntrl, isdigit, ispunct or isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (islower) exists in header <locale>.!islower!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a lowercase alphabetic letter. Zero (i.e., false) otherwise.!isupper Check if character is uppercase letter (function )
isalpha Check if character is alphabetic (function )
toupper Convert lowercase letter to uppercase (function )
tolower Convert uppercase letter to lowercase (function )!X
Cplusplus!int isprint ( int c );
Check if character is printable
Checks whether c is a printable character.

A printable character is a character that occupies a printing position on a display (this is the opposite of a control character, checked with iscntrl).

For the standard ASCII character set (used by the "C" locale), printing characters are all with an ASCII code greater than 0x1f (US), except 0x7f (DEL).

isgraph returns true for the same cases as isprint except for the space character (' '), which returns true when checked with isprint but false when checked with isgraph.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isprint) exists in header <locale>.
!isprint!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a printable character. Zero (i.e., false) otherwise.!iscntrl Check if character is a control character (function )
isspace Check if character is a white-space (function )
isalnum Check if character is alphanumeric (function )!X
Cplusplus!int ispunct ( int c );
Check if character is a punctuation character
Checks whether c is a punctuation character.

The standard "C" locale considers punctuation characters all graphic characters (as in isgraph) that are not alphanumeric (as in isalnum).

Other locales may consider a different selection of characters as punctuation characters, but in any case they are isgraph but not isalnum.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (ispunct) exists in header <locale>.
!ispunct!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a punctuation character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
iscntrl Check if character is a control character (function )!X
Cplusplus!int isspace ( int c );
Check if character is a white-space
Checks whether c is a white-space character.

For the "C" locale, white-space characters are any of:
' ' (0x20) space (SPC)
'\t' (0x09) horizontal tab (TAB)
'\n' (0x0a) newline (LF)
'\v' (0x0b) vertical tab (VT)
'\f' (0x0c) feed (FF)
'\r' (0x0d) carriage return (CR)

Other locales may consider a different selection of characters as white-spaces, but never a character that returns true for isalnum.

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isspace) exists in header <locale>.!isspace!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a white-space character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )
isalnum Check if character is alphanumeric (function )
isspace (locale) Check if character is a white-space using locale (function template )!X
Cplusplus!int isupper ( int c );
Check if character is uppercase letter
Checks if parameter c is an uppercase alphabetic letter.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, an uppercase letter is any of: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

Other locales may consider a different selection of characters as uppercase characters, but never characters that returns true for iscntrl, isdigit, ispunct or isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isupper) exists in header <locale>.
!isupper!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is an uppercase alphabetic letter. Zero (i.e., false) otherwise.!islower Check if character is lowercase letter (function )
isalpha Check if character is alphabetic (function )
toupper Convert lowercase letter to uppercase (function )
tolower Convert uppercase letter to lowercase (function )!X
Cplusplus!int isxdigit ( int c );
Check if character is hexadecimal digit
Checks whether c is a hexdecimal digit character.

Hexadecimal digits are any of: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isxdigit) exists in header <locale>.!isxdigit!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a hexadecimal digit. Zero (i.e., false) otherwise.!isdigit Check if character is decimal digit (function )
isalnum Check if character is alphanumeric (function )
isalpha Check if character is alphabetic (function )!X
Cplusplus!int tolower ( int c );
Convert uppercase letter to lowercase
Converts c to its lowercase equivalent if c is an uppercase letter and has a lowercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, an uppercase letter is any of: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z, which translate respectively to: a b c d e f g h i j k l m n o p q r s t u v w x y z.

In other locales, if an uppercase character has more than one correspondent lowercase character, this function always returns the same character for the same value of c.

In C++, a locale-specific template version of this function (tolower) exists in header <locale>.!tolower!c
Character to be converted, casted to an int, or EOF.
!The lowercase equivalent to c, if such value exists, or c (unchanged) otherwise.
The value is returned as an int value that can be implicitly casted to char.!toupper Convert lowercase letter to uppercase (function )
isupper Check if character is uppercase letter (function )
islower Check if character is lowercase letter (function )
isalpha Check if character is alphabetic (function )!X
Cplusplus!int toupper ( int c );
Convert lowercase letter to uppercase
Converts c to its uppercase equivalent if c is a lowercase letter and has an uppercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, a lowercase letter is any of: a b c d e f g h i j k l m n o p q r s t u v w x y z, which translate respectively to: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

In other locales, if a lowercase character has more than one correspondent uppercase character, this function always returns the same character for the same value of c.

In C++, a locale-specific template version of this function (toupper) exists in header <locale>.!toupper!c
Character to be converted, casted to an int, or EOF.!The uppercase equivalent to c, if such value exists, or c (unchanged) otherwise. The value is returned as an int value that can be implicitly casted to char.!tolower Convert uppercase letter to lowercase (function )
islower Check if character is lowercase letter (function )
isupper Check if character is uppercase letter (function )
isalpha Check if character is alphabetic (function )!X
Cplusplus!int
Last error number
This macro expands to a modifiable lvalue of type int. Therefore, it can be both read and modified by a program.

errno is set to zero at program startup, and any function of the standard C library can modify its value to some value different from zero, generally to signal specific categories of error (no library function sets its value back to zero once changed).

A program can also modify its value. In fact, if this variable is intended to be used for error checking after a library function call, it should be reset by the program to zero before the call (since any previous call to a library function may have altered its value).

The same header that declares errno (<cerrno>) also declares at least the following macro constants with values different from zero:

macro meaning when errno is set to this
EDOM Domain error: Some mathematical functions are only defined for certain real values, which is called its domain, for example the square root function is only defined for non-negative numbers, therefore the sqrt function sets errno to EDOM if called with a negative argument.
ERANGE Range error: The range of values that can be represented with a variable is limited. For example, mathematical functions such as pow can easily outbound the range representable by a floating point variable, or functions such as strtod can encounter sequences of digits longer than the range representable by an int value. In these cases, errno is set to ERANGE.
EILSEQ Illegal sequence: Multibyte character sequence may have a restricted set of valid sequences. When a set of multibyte characters is translated by functions such as mbrtowc, errno is set to EILSEQ when an invalid sequence is encountered.

The functions of the standard library may set errno to any value (not only to the portable values listed above). Particular library implementations may define additional names in this header.

C++11 expands the basic set of values required to be defined in this header by including many names also available in POSIX environments, increasing the total number of portable errno values to 78. For a full list, see errc.

The particular error messages associated with values of errno can be obtained using strerror or directly printed using function perror.

In C++, errno is always declared as a macro, but in C it may also be implemented as an int object with external linkage.!errno!X!X!X!X
Cplusplus!int feclearexcept (int excepts);
Clear floating-point exceptions
Attempts to clear the floating-point exceptions specified by excepts.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.
!feclearexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if all exceptions in excepts were successfully cleared (or if excepts was zero).
A non-zero value otherwise.!feraiseexcept Raise floating-point exception (function )
fetestexcept Test for floating-point exceptions (function )!X
Cplusplus!int fegetenv (fenv_t* envp);
Get floating-point environment
Attempts to store the current state of the floating-point environment in the object pointed by envp.

The floating point environment is a set of status flags and control modes affecting floating-point calculations (including both floating-point exceptions and the rounding direction mode).

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fegetenv!envp
Pointer to a fenv_t object where the state of the floating-point environment is stored.!Zero, if the state was successfully stored.
A non-zero value otherwise.!feholdexcept Hold floating-point exceptions (function )
fesetenv Set floating-point environment (function )!X
Cplusplus!int fegetexceptflag (fexcept_t* flagp, int excepts);
Get floating-point exception flags
Attempts to store a representation of the floating-point exceptions specified by excepts into the fexcept_t object pointed by flagp.!fegetexceptflag!flagp
Pointer to a fexcept_t object where the representation is stored.
excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if the representation was successfully stored.
A non-zero value otherwise.!fesetexceptflag Set floating-point exception flags (function )
feholdexcept Hold floating-point exceptions (function )!X
Cplusplus!int fegetround (void);
Get rounding direction mode
Returns a value that indicates the rounding direction mode, as specified in the current floating point environment.

Whether the value returned by this function is the same as FLT_ROUNDS in <cfloat> is unspecified.!fegetround!none!If the current rounding mode was successfully determined by the function and is supported by the implementation, the function returns a value for which a corresponding macro is defined:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
Certain library implementations may support additional floating-point rounding directions values (with their corresponding macros also beginning with FE_).!fesetround Set rounding direction mode (function )
fegetenv Get floating-point environment (function )
rint Round to integral value (function )!X
Cplusplus!int feholdexcept (fenv_t* envp);
Hold floating-point exceptions
Saves the current state of the floating-point environment in the object pointed by envp. It then resets the current state and -if supported- puts the environment in non-stop mode.

The non-stop mode prevents floating-point exceptions from stopping the normal flow of the program when raised (with traps or abortions).

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feholdexcept!envp
Pointer to a fenv_t object where the state of the floating-point environment is stored.!Zero, if the function completed successfully, including setting the floating point environment to non-stop mode.
A non-zero value otherwise.!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )
feclearexcept Clear floating-point exceptions (function )!X
Cplusplus!int feraiseexcept (int excepts);
Raise floating-point exception
Attempts to raise the floating-point exceptions specified by excepts.

If more than one exception is specified, the order in which they are raised is unspecified.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feraiseexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if all exceptions in excepts were successfully raised (or if excepts was zero).
A non-zero value otherwise.!feclearexcept Clear floating-point exceptions (function )
fetestexcept Test for floating-point exceptions (function )!X
Cplusplus!int fesetenv (const fenv_t* envp);
Set floating-point environment
Attempts to establish the state of the floating-point environment as represented by the object pointed by envp.

The floating point environment is a set of status flags and control modes affecting floating-point calculations (including both floating-point exceptions and the rounding direction mode).

If successful, the function changes the current state of the floating-point environment without actually raising the exceptions specified in such state.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetenv!envp
Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values:
value description
FE_DFL_ENV Default floating-point environment (the same as at program startup).
Certain library implementations may support additional floating-point environment state values (with their corresponding macros also beginning with FE_).!Zero, if the state was successfully established.
A non-zero value otherwise.!feupdateenv Update floating-point environment (function )
fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X
Cplusplus!int fesetexceptflag (const fexcept_t* flagp, int excepts);
Set floating-point exception flags
Attempts to set the exceptions indicated by excepts with the states stored in the object pointed by flagp.

If successful, the function changes the current state of the floating-point environment, setting the requested exception flags, but without actually raising the exceptions.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetexceptflag!flagp
Pointer to a fexcept_t object with a representation of floating-point exceptions.
The value pointed by flagp shall have been previously set by a call to fegetexceptflag with at least the exceptions specified by excepts.
excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if the function successfully set the flags in the (or if excepts was zero).
A non-zero value otherwise.!fegetexceptflag Get floating-point exception flags (function )
feraiseexcept Raise floating-point exception (function )!X
Cplusplus!int fesetround (int rdir);
Set rounding direction mode
Sets rdir as the current rounding direction mode for the floating point environment.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetround!rdir
One of the values defined as rounding direction mode:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
Certain library implementations may support additional floating-point rounding directions values (with their corresponding macros also beginning with FE_).!Zero, if the requested rounding direction was successfully set.
Otherwise, a non-zero value.!fegetround Get rounding direction mode (function )
fesetenv Set floating-point environment (function )
rint Round to integral value (function )!X
Cplusplus!int fetestexcept (int excepts);
Test for floating-point exceptions
Returns the exceptions currently set, among those specified by excepts.

The value returned is the bitwise OR representation of the subset of excepts that are currently set in the floating point environment. Or zero, if none of the exceptions in excepts are currently set.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fetestexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).
C99C++11
Libraries may define in <fenv.h> only the macro values above they support (the others may not be defined).
!Zero, if none of the exceptions in excepts are set.
Otherwise, the exceptions (among those of excepts) currently set.!feraiseexcept Raise floating-point exception (function )
feclearexcept Clear floating-point exceptions (function )
feholdexcept Hold floating-point exceptions (function )!X
Cplusplus!int feupdateenv (const fenv_t* envp);
Update floating-point environment
Attempts to establish the state of the floating-point environment as represented by the object pointed by envp. It then attempts to raise the exceptions that were set in the floating-point environment before the call.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feupdateenv!envp
Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values:
value description
FE_DFL_ENV Default floating-point environment (the same as at program startup).
Certain library implementations may support additional floating-point environment state values (with their corresponding macros also beginning with FE_).!Zero, if successful.
A non-zero value otherwise.!feupdateenv Update floating-point environment (function )
fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X
Cplusplus!Floating-point environment type
Type that can represent the entire state of the floating-point environment, including its status flags (such as the active floating-point exceptions) and control modes (such as the rounding direction mode).

Specifics about this type depend on the library implementation: Its value shall be set by calling either fegetenv or feholdexcept, and can be applied by calling fesetenv or feupdateenv.!fenv_t!X!X!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )
fexcept_t Floating-point exceptions type (type )!X
Cplusplus!Floating-point exceptions type
Type that can represent the state of all floating-point status flags collectively, including the active floating-point exceptions along with any additional information the implementation associates with their status.

Specifics about this type depend on the library implementation: Its value shall be set by calling fegetexceptflag, and can be applied by calling fesetexceptflag.!fexcept_t!X!X!fegetexceptflag Get floating-point exception flags (function )
fesetexceptflag Set floating-point exception flags (function )
fenv_t Floating-point environment type (type )!X
Cplusplus!on (1)  #pragma STDC FENV_ACCESS on
off (2)  #pragma STDC FENV_ACCESS off
Access to Floating-point environment
If set to on, the program informs the compiler that it might access the floating-point environment to test its status flags (exceptions) or run under control modes other than the one by default.

If set to off, the compiler may perform certain optimizations that can subvert these tests and mode changes, and thus accessing the floating-point environment in the cases described above, causes undefined behavior.

Whether the state of this pragma by default is on or off depends on the compiler settings and library implementation.

The pragma declaration shall occur either:
outside any external declaration: Its effects last until another FENV_ACCESS pragma is encountered, or until the end of the translation unit.
inside a compound statement: In this case it shall precede all explicit declarations and statements. Its effects last until another FENV_ACCESS pragma is encountered (such as in a nested compound statement), or until the end of the compound statement. After the compound statement, the state of the pragma is restored to the condition it had before entering it.
If this pragma appears in other contexts, the behavior is undefined.

When the state is changed by this pragma directive, the floating-point control modes (such as rounding direction) have their default settings, but the state of the floating point status flags is unspecified.
!FENV_ACCESS!X!X!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X
Cplusplus!int
All exceptions
This macro expands to a value of type int that combines the value of all the possible floating-point exceptions defined in <cfenv> (with bitwise OR).

If no floating-point exceptions are supported by the implementation, this macro is defined as 0 (zero).

It can be used on functions that expect a bitmask of possible floating point exceptions as one of its arguments: feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, or fetestexcept.!FE_ALL_EXCEPT!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
feraiseexcept Raise floating-point exception (function )!X
Cplusplus!fenv_t*
Default environment
This macro expands to a pointer to fenv_t that can be used to select the default environment for functions fesetenv and feupdateenv.

The default environment is the state of the floating-point environment on program startup.!FE_DFL_ENV!X!X!fesetenv Set floating-point environment (function )
feupdateenv Update floating-point environment (function )
fenv_t Floating-point environment type (type )!X
Cplusplus!int
Pole error exception
This macro expands to a value of type int that identifies the floating-point exception raised on pole errors.

Pole errors occur when an operation has a result that is asymptotically infinite, such as divisions by zero, or log(0.0).

It is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).
!FE_DIVBYZERO!X!X!FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X
Cplusplus!int
Downward rounding direction mode
This macro expands to a value of type int that identifies the downward rounding direction mode for functions fegetround and fesetround.

Rounding x downward selects the largest possible value that is not greater than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_DOWNWARD!X!X!FE_TONEAREST To-nearest rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X
Cplusplus!int
Inexact result exception
This macro expands to a value of type int that identifies the floating-point exception raised on inexact results.

Inexact exceptions are raised to signal when the return type of an operation cannot represent the result with exact accuracy (such as 1.0/3.0 or sqrt(2.0) on most implementations), or when a function cannot produce an exact result for some other reason.

It is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_INEXACT!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X
Cplusplus!int
Invalid argument exception
This macro expands to a value of type int that identifies the floating-point exception raised on invalid arguments.

Invalid argument exceptions are raised to signal that the argument passed to a function is out of its domain (i.e., the function is not defined for that value), such as sqrt(-1.0).

The value returned by a function that raises this exception is unspecified.

FE_INVALID is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_INVALID!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X
Cplusplus!int
Overflow range error exception
This macro expands to a value of type int that identifies the floating-point exception raised on overflow range errors.

Overflow range errors occur when the result of an operation cannot be represented as a value of its return type because its magnitude is too large (with either positive or negative sign).

Operations that overflow while the default rounding mode is in effect, return a positive or a negative HUGE_VAL (or HUGE_VALF or HUGE_VALL).

FE_OVERFLOW is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_OVERFLOW!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X
Cplusplus!int
To-nearest rounding direction mode
This macro expands to a value of type int that identifies the to-nearest rounding direction mode for functions fegetround and fesetround.

Rounding x to-nearest selects the possible value that is nearest to x, with halfway cases rounded away from zero.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_TONEAREST!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X
Cplusplus!int
Toward-zero rounding direction mode
This macro expands to a value of type int that identifies the toward-zero rounding direction mode for functions fegetround and fesetround.

Rounding x toward zero selects the nearest possible value that is not larger in magnitude than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_TOWARDZERO!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TONEAREST To-nearest rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X
Cplusplus!int
Underflow range error exception
This macro expands to a value of type int that identifies the floating-point exception raised on underflow range errors.

Underflow range errors occur when the result of an operation cannot be represented as a value of its return type because its magnitude is too small (with either positive or negative sign).

Operations that overflow return an unspecified value whose magnitude is no greater than the smallest normalized positive number.

Whether an operation raises this exception is implementation-defined: there are no operations required to raise this exception, but an implementation may choose to do so.

FE_UNDERFLOW is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_UNDERFLOW!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X
Cplusplus!int
Upward rounding direction mode
This macro expands to a value of type int that identifies the upward rounding direction mode for functions fegetround and fesetround.

Rounding x upward selects the smallest possible value that is not less than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_UPWARD!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TONEAREST To-nearest rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X
Cplusplus!struct lconv* localeconv (void);
Get locale formatting parameters for quantities
Retrieves the values provided in the current locale object to format parameters for quantities. These are returned in an object of type struct lconv (see lconv for the description of its members).!localeconv!none!A pointer to a structure object of the structure type lconv with the corresponding values for the current locale filled in. The data pointed by this should not be modified by the program. Its data may be overriden by a further call to this same function or to setlocale with a category affecting these settings.!struct lconv Formatting info for numeric values (type )
setlocale Set or retrieve locale (function )!X
Cplusplus!char* setlocale (int category, const char* locale);
Set or retrieve locale
Sets locale information to be used by the current program, either changing the entire locale or portions of it. The function can also be used to retrieve the current locale's name by passing NULL as the value for argument locale.

Locales contain information on how to interpret and perform certain input/output and transformation operations taking into consideration location and language specific settings.

Most running environments have certain locale information set according to the user preferences or localization. But, independently of this system locale, on start, all C programs have the "C" locale set, which is a rather neutral locale with minimal locale information that allows the result of programs to be predictable. In order to use the default locale set in the environment, this function can be called with "" as argument locale.

On program startup, the locale selected is the "C" locale, which is the same as would be set by calling setlocale(LC_ALL,"C").

The locale settings selected in the environment can be selected by calling setlocale(LC_ALL,"").

The portions of the current locale affected by a call to this function are specified by argument category.!setlocale!category
Portion of the locale affected. It is one of the following constant values defined as macros in <clocale>:
value Portion of the locale affected
LC_ALL The entire locale.
LC_COLLATE Affects the behavior of strcoll and strxfrm.
LC_CTYPE Affects character handling functions (all functions of <cctype>, except isdigit and isxdigit), and the multibyte and wide character functions.
LC_MONETARY Affects monetary formatting information returned by localeconv.
LC_NUMERIC Affects the decimal-point character in formatted input/output operations and string formatting functions, as well as non-monetary information returned by localeconv.
LC_TIME Affects the behavior of strftime.
locale
C string containing the name of a C locale. These are system specific, but at least the two following locales must exist:
locale name description
"C" Minimal "C" locale
"" Environment's default locale
If the value of this parameter is NULL, the function does not make any changes to the current locale, but the name of the current locale is still returned by the function.!On success, A pointer to a C string identifying the locale currently set for the category. If category is LC_ALL and different portions of the locale are set to different values, the string returned gives this information in a format which may vary between library implementations.

If the function failed to set a new locale, this is not modified and a null pointer is returned.!localeconv Get locale formatting parameters for quantities (function )!X
Cplusplus!Null pointer
This macro expands to a null pointer constant.!NULL!X!X!X!X
Cplusplus!struct lconv;
Formatting info for numeric values
This structure holds formatting information on how numeric values, both monetary and non-monetary, are to be written.

The function localeconv returns an object of this type.

It contains the following members (not necessarily in this in order):

Member constants
member type value in "C" locale description
decimal_point char* "." Decimal-point separator used for non-monetary quantities.
thousands_sep char* "" Separators used to delimit groups of digits to the left of the decimal point for non-monetary quantities.
grouping char* "" Specifies the amount of digits that form each of the groups to be separated by thousands_sep separator for non-monetary quantities. This is a zero-terminated sequence of char values that may contain different grouping sizes for each successive group starting from the right, each number indicating the amount of digits for the group; the last number before the ending zero in this string is used for the remaining groups. For example, assuming thousand_sep is set to "," and the number to represent is one million (1000000):
with grouping set to "\3", the number would be represented as: 1,000,000 
with grouping set to "\1\2\3", the number would be represented as: 1,000,00,0 
with grouping set to "\3\1", the number would be represented as: 1,0,0,0,000 
CHAR_MAX indicates that no further grouping is to be performed.
int_curr_symbol char* "" International currency symbol. This is formed by the three-letter ISO-4217 entry code for the currency, like "USD" for U.S.-Dollar or "GBP" for Pound Sterling, followed by the character used to separate this symbol from the monetary quantity
currency_symbol char* "" Local currency symbol, like "$".
mon_decimal_point char* "" Decimal-point separator used for monetary quantities.
mon_thousands_sep char* "" Separators used to delimit groups of digits to the left of the decimal point for monetary quantities.
mon_grouping char* "" Specifies the amount of digits that form each of the groups to be separated by mon_thousands_sep separator for monetary quantities. See grouping description above.
positive_sign char* "" Sign to be used for nonnegative (positive or zero) monetary quantities.
negative_sign char* "" Sign to be used for negative monetary quantities.
char frac_digits char CHAR_MAX Amount of fractional digits to the right of the decimal point for monetary quantities in the local format.
p_cs_precedes char CHAR_MAX Whether the currency symbol should precede nonnegative (positive or zero) monetary quantities. If this value is 1, the currency symbol should precede; if it is 0, it should follow.
n_cs_precedes char CHAR_MAX Whether the currency symbol should precede negative monetary quantities. If this value is 1, the currency symbol should precede; if it is 0 it should follow.
p_sep_by_space char CHAR_MAX Whether a space should appear between the currency symbol and nonnegative (positive or zero) monetary quantities. If this value is 1, a space should appear; if it is 0 it should not.
n_sep_by_space char CHAR_MAX Whether a space should appear between the currency symbol and negative monetary quantities. If this value is 1, a space should appear; if it is 0 it should not.
p_sign_posn char CHAR_MAX Position of the sign for nonnegative (positive or zero) monetary quantities:
0 : Currency symbol and quantity surrounded by parentheses.
1 : Sign before the quantity and currency symbol.
2 : Sign after the quantity and currency symbol.
3 : Sign right before currency symbol.
4 : Sign right after currency symbol.
CHAR_MAX : Unspecified.
n_sign_posn char CHAR_MAX Position of the sign for negative monetary quantities. See p_sign_posn above.
int_frac_digits char CHAR_MAX Same as frac_digits, but for the international format (instead of the local format).
int_p_cs_precedes char CHAR_MAX Same as p_cs_precedes, but for the international format.
int_n_cs_precedes char CHAR_MAX Same as n_cs_precedes, but for the international format.
int_p_sep_by_space char CHAR_MAX Same as p_sep_by_space, but for the international format.
int_n_sep_by_space char CHAR_MAX Same as n_sep_by_space, but for the international format.
int_p_sign_posn char CHAR_MAX Same as p_sign_posn, but for the international format.
int_n_sign_posn char CHAR_MAX Same as n_sign_posn, but for the international format.

A value of "" for a member of type char* or a value of CHAR_MAX for a member of type char indicates that the value is not available in the locale.!struct lconv!X!X!localeconv Get locale formatting parameters for quantities (function )!The members that begin with int_p and int_n (in yellow above) are defined for libraries complying with the C standard of 1999 or later (which is only required by the C++ standard since 2011: C++11).
Cplusplus!double abs (double x);
float abs (float x);
long double abs (long double x);
Compute absolute value
Returns the absolute value of x: |x|.

These convenience abs overloads are exclusive of C++. In C, abs is only declared in <stdlib.h> (and operates on int values).

Since C++11, additional overloads are provided in this header (<cmath>) for the integral types: These overloads effectively cast x to a double before calculations (defined for T being any integral type).!abs!x
Value whose absolute value is returned.!The absolute value of x.!abs (cstdlib) Absolute value (function )
fabs Compute absolute value (function )
labs Absolute value (function )!X
Cplusplus!double acos (double x);
float acos (float x);
long double acos (long double x);
Compute arc cosine
Returns the principal value of the arc cosine of x, expressed in radians.

In trigonometrics, arc cosine is the inverse operation of cosine.!acos!x
Value whose arc cosine is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.!Principal arc cosine of x, in the interval [0,pi] radians.
One radian is equivalent to 180/PI degrees.!cos Compute cosine (function )
asin Compute arc sine (function )!X
Cplusplus!double acosh  (double x);
float acoshf (float x);
long double acoshl (long double x);
Compute arc hyperbolic cosine
Returns the nonnegative arc hyperbolic cosine of x, expressed in radians.

The arc hyperbolic cosine is the inverse operation of the hyperbolic cosine.!acosh!x
Value whose arc hyperbolic cosine is computed.
If the argument is less than 1, a domain error occurs.!Nonnegative arc hyperbolic cosine of x, in the interval [0,+INFINITY] radians.
Note that the negative of this value is also a valid arc hyperbolic cosine of x One radian is equivalent to 180/PI degrees.

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!cosh Compute hyperbolic cosine (function )
asinh Compute arc hyperbolic sine (function )!X
Cplusplus!Compute arc sine
Returns the principal value of the arc sine of x, expressed in radians.

In trigonometrics, arc sine is the inverse operation of sine.!asin!x
Value whose arc sine is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.!Principal arc sine of x, in the interval [-pi/2,+pi/2] radians.
One radian is equivalent to 180/PI degrees.!sin Compute sine (function )
acos Compute arc cosine (function )!X
Cplusplus!double asinh  (double x);
float asinhf (float x);
long double asinhl (long double x);
Compute arc hyperbolic sine
Returns the arc hyperbolic sine of x, expressed in radians.

The arc hyperbolic sine is the inverse operation of the hyperbolic sine.!asinh!x
Value whose arc hyperbolic sine is computed.!Arc hyperbolic sine of x, in radians.
One radian is equivalent to 180/PI degrees.!sinh Compute hyperbolic sine (function )
acosh Compute arc hyperbolic cosine (function )!X
Cplusplus!double atan (double x);
float atan (float x);
long double atan (long double x);
Compute arc tangent
Returns the principal value of the arc tangent of x, expressed in radians.

In trigonometrics, arc tangent is the inverse operation of tangent.

Notice that because of the sign ambiguity, the function cannot determine with certainty in which quadrant the angle falls only by its tangent value. See atan2 for an alternative that takes a fractional argument instead.!atan!x
Value whose arc tangent is computed.!Principal arc tangent of x, in the interval [-pi/2,+pi/2] radians.
One radian is equivalent to 180/PI degrees.
!atan2 Compute arc tangent with two parameters (function )
tan Compute tangent (function )
sin Compute sine (function )
cos Compute cosine (function )!X
Cplusplus!double atan2 (double y     , double x);
float atan2 (float y      , float x);
long double atan2 (long double y, long double x);
Compute arc tangent with two parameters
Returns the principal value of the arc tangent of y/x, expressed in radians.

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

In C++, this function is overloaded in <valarray> (see valarray atan2).!atan2!y
Value representing the proportion of the y-coordinate.
x
Value representing the proportion of the x-coordinate.
If both arguments passed are zero, a domain error occurs.!Principal arc tangent of y/x, in the interval [-pi,+pi] radians.
One radian is equivalent to 180/PI degrees.!atan Compute arc tangent (function )
tan Compute tangent (function )
sin Compute sine (function )
cos Compute cosine (function )!X
Cplusplus!double atanh  (double x);
float atanhf (float x);
long double atanhl (long double x);
Compute arc hyperbolic tangent
Returns the arc hyperbolic tangent of x, expressed in radians.

The arc hyperbolic tangent is the inverse operation of the hyperbolic tangent.!atanh!x
Value whose arc hyperbolic tangent is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.
For values of -1 and +1, a pole error may occur.!Arc hyperbolic tangent of x, in radians.
One radian is equivalent to 180/PI degrees.

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!tanh Compute hyperbolic tangent (function )
asinh Compute arc hyperbolic sine (function )
acosh Compute arc hyperbolic cosine (function )!X
Cplusplus!double cbrt  (double x);
float cbrtf (float x);
long double cbrtl (long double x);
Compute cubic root
Returns the cubic root of x.!cbrt!x
Value whose cubit root is computed.!Cubic root of x.!sqrt Compute square root (function )
pow Raise to power (function )!X
Cplusplus!double ceil (double x);
Round up value
Rounds x upward, returning the smallest integral value that is not less than x.!ceil!x
Value to round up.!The smallest integral value that is not less than x (as a floating-point value).!floor Round down value (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X
Cplusplus!double copysign  (double x     , double y);
float copysignf (float x      , float y);
long double copysignl (long double x, long double y);
Copy sign
Returns a value with the magnitude of x and the sign of y.!copysign!x
Value with the magnitude of the resulting value.
y
Value with the sign of the resulting value.!The value with a magnitude of x and the sign of y.!fabs Compute absolute value (function )!X
Cplusplus!double cos (double x);
Compute cosine
Returns the cosine of an angle of x radians.!cos!x
Value representing an angle expressed in radians.
One radian is equivalent to 180/PI degrees.!Cosine of x radians.!sin Compute sine (function )
tan Compute tangent (function )!X
Cplusplus!double cosh (double x);
Compute hyperbolic cosine
Returns the hyperbolic cosine of x radians.!cosh!x
Value representing an angle, expressed in radians.!Hyperbolic cosine of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!sinh Compute hyperbolic sine (function )
tanh Compute hyperbolic tangent (function )!X
Cplusplus!double erf  (double x);
float erff (float x);
long double erfl (long double x);
Compute error function
error function Returns the error function value for x.!erf!x
Parameter for the error function.!Error function value for x.!erfc Compute complementary error function (function )
lgamma Compute log-gamma function (function )
tgamma Compute gamma function (function )!X
Cplusplus!double erfc  (double x);
float erfcf (float x);
long double erfcl (long double x);
Compute complementary error function
complementary error function Returns the complementary error function value for x.

The complementary error function is equivalent to:
erfc(x) = 1-erf(x) !erfc!x
Parameter for the complementary error function.!Complementary error function value for x.
If x is too large, an underflow range error occurs.

If an underflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_UNDERFLOW is raised.!erf Compute error function (function )
lgamma Compute log-gamma function (function )
tgamma Compute gamma function (function )!X
Cplusplus!double exp (double x);
Compute exponential function
Returns the base-e exponential function of x, which is e raised to the power x: ex.!exp!x
Value of the exponent.!Exponential value of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!log Compute natural logarithm (function )
pow Raise to power (function )!X
Cplusplus!double exp2  (double x);
float exp2f (float x);
long double exp2l (long double x);
Compute binary exponential function
Returns the base-2 exponential function of x, which is 2 raised to the power x: 2x.!exp2!x
Value of the exponent.!2 raised to the power of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!log2 Compute binary logarithm (function )
pow Raise to power (function )
exp Compute exponential function (function )!X
Cplusplus!double expm1  (double x);
float expm1f (float x);
long double expm1l (long double x);
Compute exponential minus one
Returns e raised to the power x minus one: ex-1.

For small magnitude values of x, expm1 may be more accurate than exp(x)-1.!expm1!x
Value of the exponent.!e raised to the power of x, minus one.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.
!exp Compute exponential function (function )
log1p Compute logarithm plus one (function )
pow Raise to power (function )!X
Cplusplus!double fabs (double x);
Compute absolute value
Returns the absolute value of x: |x|.!fabs!x
Value whose absolute value is returned.!The absolute value of x.!abs Absolute value (function )
labs Absolute value (function )
floor Round down value (function )
ceil Round up value (function )
modf Break into fractional and integral parts (function )!X
Cplusplus!double fdim  (double x     , double y);
float fdimf (float x      , float y);
long double fdiml (long double x, long double y);
Positive difference
Returns the positive difference between x and y.

The function returns x-y if x>y, and zero otherwise.!fdim!x, y
Values whose difference is calculated.!The positive difference between x and y.!fmax Maximum value (function )
fmin Minimum value (function )!X
Cplusplus!double floor (double x);
Round down value
Rounds x downward, returning the largest integral value that is not greater than x.!floor!x
Value to round down.!The value of x rounded downward (as a floating-point value).!ceil Round up value (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X
Cplusplus!double fma  (double x     , double y     , double z);
float fmaf (float x      , float y      , float z);
long double fmal (long double x, long double y, long double z);
Multiply-add
Returns x*y+z.

The function computes the result without losing precision in any intermediate result.

The following macro constants may be defined in an implementation to signal that this function generally provides an efficiency improvement over performing the arithmetic operations in x*y+z (such as when a hardware multiply-add instruction is used):

macro description
FP_FAST_FMA For arguments of type double, it generally executes about as fast as, or faster than, x*y+z.
FP_FAST_FMAF For arguments of type float, it generally executes about as fast as, or faster than, x*y+z.
FP_FAST_FMAL For arguments of type long double, it generally executes about as fast as, or faster than, x*y+z.
!fma!x, y
Values to be multiplied.
z
Value to be added.!The result of x*y+z!fmin Minimum value (function )
fdim Positive difference (function )!X
Cplusplus!double fmax  (double x     , double y);
float fmaxf (float x      , float y);
long double fmaxl (long double x, long double y);
Maximum value
Returns the larger of its arguments: either x or y.

If one of the arguments in a NaN, the other is returned.!fmax!x, y
Values among which the function selects a maximum.!The maximum numeric value of its arguments.!fmin Minimum value (function )
fdim Positive difference (function )!X
Cplusplus!double fmin  (double x     , double y);
      float fminf (float x      , float y);
long double fminl (long double x, long double y);
Minimum value
Returns the smaller of its arguments: either x or y.

If one of the arguments in a NaN, the other is returned.!fmin!x, y
Values among which the function selects a minimum.!The minimum numeric value of its arguments.!fmax Maximum value (function )
fdim Positive difference (function )!X
Cplusplus!double fmod (double numer, double denom);
Compute remainder of division
Returns the floating-point remainder of numer/denom (rounded towards zero):

fmod = numer - tquot * denom 

Where tquot is the truncated (i.e., rounded towards zero) result of: numer/denom.

A similar function, remainder, returns the same but with the quotient rounded to the nearest integer (instead of truncated).!fmod!numer
Value of the quotient numerator.
denom
Value of the quotient denominator.!The remainder of dividing the arguments.
If denom is zero, the function may either return zero or cause a domain error (depending on the library implementation).
!remainder Compute remainder (IEC 60559) (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X
Cplusplus!macro 
fpclassify(x)
Classify floating-point value
Returns a value of type int that matches one of the classification macro constants, depending on the value of x:

value description
FP_INFINITE Positive or negative infinity (overflow)
FP_NAN Not-A-Number
FP_ZERO Value of zero
FP_SUBNORMAL Sub-normal value (underflow)
FP_NORMAL Normal value (none of the above)
Note that each value pertains to a single category: zero is not a normal value.

These macro constants of type int are defined in header <cmath> (<math.h>).!fpclassify!x
The value to classify.!One of the followoing int values: FP_INFINITE, FP_NAN, FP_ZERO, FP_SUBNORMAL or FP_NORMAL.!isfinite Is finite value (macro )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
signbit Sign bit (macro/function )!X
Cplusplus!double frexp (double x, int* exp);
Get significand and exponent
Breaks the floating point number x into its binary significand (a floating point value between 0.5(included) and 1.0(excluded)) and an integral exponent for 2, such that:

x = significand * 2 exponent 
The exponent is stored in the location pointed by exp, and the significand is the value returned by the function.

If x is zero, both parts (significand and exponent) are zero.!frexp!x
Value to be decomposed.
exp
Pointer to an int where the value of the exponent is stored.!The binary significand of x.
This value is the floating point value in the interval [0.5,1) which, once multiplied by 2 raised to the power of exp, yields x.!ldexp Generate value from significand and exponent (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X
Cplusplus!double hypot  (double x     , double y);
float hypotf (float x      , float y);
long double hypotl (long double x, long double y);
Compute hypotenuse
Returns the hypotenuse of a right-angled triangle whose legs are x and y.

The function returns what would be the square root of the sum of the squares of x and y (as per the Pythagorean theorem), but without incurring in undue overflow or underflow of intermediate values.
!hypot!x, y
Floating point values corresponding to the legs of a right-angled triangle for which the hypotenuse is computed.
!The square root of (x2+y2).
If the magnitude of the result is too large to be represented by a value of the return type, the function may return HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign (in which case, an overflow range error occurs):

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!sqrt Compute square root (function )
pow Raise to power (function )!X
Cplusplus!int ilogb  (double x);
int ilogbf (float x);
int ilogbl (long double x);
Integer binary logarithm
Returns the integral part of the logarithm of |x|, using FLT_RADIX as base for the logarithm.

This is the exponent used internally by the machine to express the floating-point value x, when it uses a significand between 1.0 and FLT_RADIX, so that, for a positive x:

x = significand * FLT_RADIX exponent 

Generally, FLT_RADIX is 2, and the value returned by this function is one less than the exponent obtained with frexp (because of the different significand normalization as [1.0,2.0) instead of [0.5,1.0)).
!ilogb!x
Value whose ilogb is returned.!If x is normal, the base-FLT_RADIX logarithm of x.
If x is subnormal, the value returned is the one corresponding to the normalized representation (negative exponent).
If x is zero, it returns FP_LOGB0 (a special value, only returned by this function, defined in <cmath>).
If x is infinite, it returns INT_MAX.
If x is NaN, it returns FP_ILOGBNAN (a special value, only returned by this function, defined in <cmath>).
If the magnitude of the result is too large to be represented by a value of the return type, the function returns an unspecified value, and an overflow range error occurs.
A zero, infinite or NaN value of x may also cause either a domain error or an overflow range error.

If an domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!logb Compute floating-point base logarithm (function )
log2 Compute binary logarithm (function )
pow Raise to power (function )!X
Cplusplus!macro 
isfinite(x)
Is finite value
Returns whether x is a finite value.

A finite value is any floating-point value that is neither infinite nor NaN (Not-A-Number).!isfinite!x
A floating-point value.!A non-zero value (true) if x is finite; and zero (false) otherwise.!isinf Is infinity (macro/function )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X
Cplusplus!macro 
isgreater(x,y)
Is greater
Returns whether x is greater than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x>y may raise such an exception in this case).!isgreater!x, y
Values to be compared.!The same as (x)>(y):
true (1) if x is greater than y.
false (0) otherwise.!isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X
Cplusplus!macro 
isgreaterequal(x,y)
Is greater or equal
Returns whether x is greater than or equal to y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x>=y may raise such an exception in this case).!isgreaterequal!x, y
Values to be compared.!The same as (x)>=(y):
true (1) if x is greater than or equal to y.
false (0) otherwise.!isgreater Is greater (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X
Cplusplus!macro 
isinf(x)
Is infinity
Returns whether x is an infinity value (either positive infinity or negative infinity).!isinf!x
A floating-point value.!A non-zero value (true) if x is an infinity; and zero (false) otherwise.!isfinite Is finite value (macro )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X
Cplusplus!macro 
isless(x,y)
Is less
Returns whether x is less than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<y may raise such an exception in this case).
!isless!x, y
Values to be compared.!The same as (x)<(y):
true (1) if x is less than y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X
Cplusplus!
macro 
islessequal(x,y)
Is less or equal
Returns whether x is less than or equal to y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<=y may raise such an exception in this case).!islessequal!x, y
Values to be compared.!The same as (x)<=(y):
true (1) if x is less than or equal to y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X
Cplusplus!macro 
islessgreater(x,y)
Is less or greater
Returns whether x is less than or greater than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<y||x>y may raise such an exception in this case).!islessgreater!x, y
Values to be compared.!The same as (x)<(y)||(x)>(y):
true (1) if x is less than or greater than y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
isunordered Is unordered (macro )!X
Cplusplus!macro 
isnan(x)
Is Not-A-Number
Returns whether x is a NaN (Not-A-Number) value.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.!isnan!x
A floating-point value.!A non-zero value (true) if x is a NaN value; and zero (false) otherwise.!NAN Not-A-Number (constant )
isfinite Is finite value (macro )
isinf Is infinity (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X
Cplusplus!macro 
isnormal(x)
Is normal
Returns whether x is a normal value: i.e., whether it is neither infinity, NaN, zero or subnormal.!isnormal!x
A floating-point value.!A non-zero value (true) if x is normal; and zero (false) otherwise.!isfinite Is finite value (macro )
isinf Is infinity (macro/function )
isnan Is Not-A-Number (macro/function )
fpclassify Classify floating-point value (macro/function )!X
Cplusplus!macro 
isunordered(x,y)
Is unordered
Returns whether x or y are unordered values:

If one or both arguments are NaN, the arguments are unordered and the function returns true. In no case the function raises a FE_INVALID exception.!isunordered!x, y
Values to check whether they are unordered.!true (1) if either x or y is NaN.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X
Cplusplus!double ldexp (double x, int exp);
Generate value from significand and exponent
Returns the result of multiplying x (the significand) by 2 raised to the power of exp (the exponent).

lexpr(x,exp) = x * 2 exp !ldexp!x
Floating point value representing the significand.
exp
Value of the exponent.!The function returns:

x * 2 exp 

If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!frexp Get significand and exponent (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X
Cplusplus!double lgamma  (double x);
float lgammaf (float x);
long double lgammal (long double x);
Compute log-gamma function
log-gamma function Returns the natural logarithm of the absolute value of the gamma function of x.!lgamma!x
Parameter for the log-gamma function.!Log-gamma function of x.
If x is too large, an overflow range error occurs.
If x is zero or a negative integer for which the function is asymptotic, it may cause a pole error (depending on implementation).

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!tgamma Compute gamma function (function )
erf Compute error function (function )
erfc Compute complementary error function (function )!X
Cplusplus!long long int llrint  (double x);
long long int llrintf (float x);
long long int llrintl (long double x);
Round and cast to long long integer
Rounds x to an integral value, using the rounding direction specified by fegetround, and returns it as a value of type long long int.

See lrint for an equivalent function that returns a long int.!llrint!x
Value to round.!The value of x rounded to a nearby integral, casted to a value of type long long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nearbyint Round to nearby integral value (function )
rint Round to integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X
Cplusplus!long long int llround  (double x);
long long int llroundf (float x);
long long int llroundl (long double x);
Round to nearest and cast to long long integer
Returns the integer value that is nearest in value to x, with halfway cases rounded away from zero.

The rounded value is returned as a value of type long long int. See lround for an equivalent function that returns a long int instead.!llround!x
Value to round.!The value of x rounded to the nearest integral, casted to a value of type long long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!llrint Round and cast to long long integer (function )
round Round to nearest (function )
lround Round to nearest and cast to long integer (function )
nearbyint Round to nearby integral value (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X
Cplusplus!double log (double x);
Compute natural logarithm
Returns the natural logarithm of x.

The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp). For common (base-10) logarithms, see log10.!log!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!Natural logarithm of x.
If x is negative, it causes a domain error.
If x is zero, it may cause a pole error (depending on the library implementation).If a domain error occurs, the global variable errno is set to EDOM.
If a pole error occurs, the global variable errno is set ERANGE.!log10 Compute common logarithm (function )
exp Compute exponential function (function )
pow Raise to power (function )!X
Cplusplus!double log10 (double x);
Compute common logarithm
Returns the common (base-10) logarithm of x.!log10!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!Common logarithm of x.
If x is negative, it causes a domain error.
If x is zero, it may cause a pole error (depending on the library implementation).!log Compute natural logarithm (function )
exp Compute exponential function (function )
pow Raise to power (function )!X
Cplusplus!double log1p  (double x);
float log1pf (float x);
long double log1pl (long double x);
Compute logarithm plus one
Returns the natural logarithm of one plus x.

For small magnitude values of x, logp1 may be more accurate than log(1+x).!log1p!x
Value whose logarithm is calculated.
If the argument is less than -1, a domain error occurs.!The natural logarithm of (1+x).
If x is less than -1, it causes a domain error.
If x is -1, it may cause a pole error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!exp Compute exponential function (function )
log1p Compute logarithm plus one (function )
pow Raise to power (function )!X
Cplusplus!double log2  (double x);
float log2f (float x);
long double log2l (long double x);
Compute binary logarithm
Returns the binary (base-2) logarithm of x.!log2!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!The binary logarithm of x: log2x.
If x is negative, it causes a domain error:
If x is zero, it may cause a pole error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.
!exp2 Compute binary exponential function (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X
Cplusplus!double logb  (double x);
      float logbf (float x);
long double logbl (long double x);
Compute floating-point base logarithm
Returns the logarithm of |x|, using FLT_RADIX as base for the logarithm.

On most platforms, FLT_RADIX is 2, and thus this function is equivalent to log2 for positive values.!logb!x
Value whose logarithm is calculated.
!The base-FLT_RADIX logarithm of x.
If x is zero it may cause a domain error or a pole error (or no error, depending on the library implementation).

If an domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!ilogb Integer binary logarithm (function )
log2 Compute binary logarithm (function )
pow Raise to power (function )!X
Cplusplus!long int lrint  (double x);
long int lrintf (float x);
long int lrintl (long double x);
Round and cast to long integer
Rounds x to an integral value, using the rounding direction specified by fegetround, and returns it as a value of type long int.

See llrint for an equivalent function that returns a long long int.!lrint!x
Value to round.!The value of x rounded to a nearby integral, casted to a value of type long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!See also
nearbyint
Round to nearby integral value (function )
rint
Round to integral value (function )
llrint
Round and cast to long long integer (function )
round
Round to nearest (function )
floor
Round down value (function )
ceil
Round up value (function )
trunc
Truncate value (function )!X
Cplusplus!long int lround  (double x);
long int lroundf (float x);
long int lroundl (long double x);
Round to nearest and cast to long integer
Returns the integer value that is nearest in value to x, with halfway cases rounded away from zero.

The rounded value is returned as a value of type long int. See llround for an equivalent function that returns a long long int instead.!lround!x
Value to round.!The value of x rounded to the nearest integral, casted to a value of type long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!lrint Round and cast to long integer (function )
round Round to nearest (function )
llround Round to nearest and cast to long long integer (function )
nearbyint Round to nearby integral value (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X
Cplusplus!double modf (double x, double* intpart);
Break into fractional and integral parts
Breaks x into an integral and a fractional part.

The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function.

Both parts have the same sign as x.!modf!x
Floating point value to break into parts.
intpart
Pointer to an object (of the same type as x) where the integral part is stored with the same sign as x.!The fractional part of x, with the same sign.!ldexp Generate value from significand and exponent (function )
frexp Get significand and exponent (function )!X
Cplusplus!double nan (const char* tagp);
Generate quiet NaN
Returns a quiet NaN (Not-A-Number) value of type double.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nanf and nanl return NaN values of type float and long double, respectively.!nan!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtod).!A quiet NaN value.
!isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )
NAN Not-A-Number (constant )!X
Cplusplus!float nanf (const char* tagp);
Generate quiet NaN (float)
Returns a quiet NaN (Not-A-Number) value of type float.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nan and nanl return NaN values of type double and long double, respectively.!nanf!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtof).!A quiet NaN value.!NAN Not-A-Number (constant )
nan Generate quiet NaN (function )
isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )!X
Cplusplus!float nanl (const char* tagp);
Generate quier NaN (long double)
Returns a quiet NaN (Not-A-Number) value of type long double.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nan and nanf return NaN values of type double and float, respectively.!nanl!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtold).!A quiet NaN value.!NAN Not-A-Number (constant )
nan Generate quiet NaN (function )
isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )!X
Cplusplus!double nearbyint  (double x);
float nearbyintf (float x);
long double nearbyintl (long double x);
Round to nearby integral value
Rounds x to an integral value, using the rounding direction specified by fegetround.

This function does not raise FE_INEXACT exceptions. See rint for an equivalent function that may do.!nearbyint!x
Value to round.!The value of x rounded to a nearby integral (as a floating-point value).!rint Round to integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X
Cplusplus!double nextafter  (double x     , double y);
float nextafterf (float x      , float y);
long double nextafterl (long double x, long double y);
Next representable value
Returns the next representable value after x in the direction of y.

The similar function, nexttoward has the same behavior, but it takes a long double as second argument.!nextafter!x
Base value.
y
Value toward which the return value is approximated.
If both parameters compare equal, the function returns y.
!The next representable value after x in the direction of y.

If x is the largest finite value representable in the type, and the result is infinite or not representable, an overflow range error occurs.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nexttoward Next representable value toward precise value (function )!X
Cplusplus!double nexttoward  (double x     , long double y);
float nexttowardf (float x      , long double y);
long double nexttowardl (long double x, long double y);
Next representable value toward precise value
Returns the next representable value after x in the direction of y.

This function behaves as nextafter, but with a potentially more precise y.!nexttoward!x
Base value.
y
Value toward which the return value is approximated.
If both parameters compare equal, the function returns y (converted to the return type).
!The next representable value after x in the direction of y.

If x is the largest finite value representable in the type, and the result is infinite or not representable, an overflow range error occurs.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nextafter Next representable value (function )!X
Cplusplus!double pow (double base, double exponent);
Raise to power
Returns base raised to the power exponent:

baseexponent !pow!base
Base value.
exponent
Exponent value.!The result of raising base to the power exponent.

If the base is finite negative and the exponent is finite but not an integer value, it causes a domain error.
If both base and exponent are zero, it may also cause a domain error on certain implementations.
If base is zero and exponent is negative, it may cause a domain error or a pole error (or none, depending on the library implementation).
The function may also cause a range error if the result is too great or too small to be represented by a value of the return type.

C90 (C++98)C99 (C+11)
If a domain error occurs, the global variable errno is set to EDOM.
If a pole or range error occurs, the global variable errno is set ERANGE.!log Compute natural logarithm (function )
exp Compute exponential function (function )
sqrt Compute square root (function )!X
Cplusplus!double remainder  (double numer     , double denom);
      float remainderf (float numer      , float denom);
long double remainderl (long double numer, long double denom);
Compute remainder (IEC 60559)
Returns the floating-point remainder of numer/denom (rounded to nearest):

remainder = numer - rquot * denom 

Where rquot is the result of: numer/denom, rounded toward the nearest integral value (with halfway cases rounded toward the even number).

A similar function, fmod, returns the same but with the quotient truncated (rounded towards zero) instead.
The function remquo has a behavior identical to this function, but it additionally provides access to the intermediate quotient value used.!remainder!numer
Value of the quotient numerator.
denom
Value of the quotient denominator.!The remainder of dividing the arguments.
If this remainder is zero, its sign shall be that of numer.
If denom is zero, the function may either return zero or cause a domain error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!fmod Compute remainder of division (function )
fabs Compute absolute value (function )
round Round to nearest (function )!X
Cplusplus!double remquo  (double numer     , double denom     , int* quot);
 float remquof (float numer      , float denom      , int* quot);
long double remquol (long double numer, long double denom, int* quot);
Compute remainder and quotient
Returns the same as remainder, but it additionally stores the quotient internally used to determine its result in the object pointed by quot.

The value pointed by quot contains the congruent modulo with at least 3 bits of the integral quotient numer/denom.
!remquo!numer
Floating point value with the quotient numerator.
denom
Floating point value with the quotient denominator.
quot
Pointer to an object where the quotient internally used to determine the remainder is stored as a value of type int.!The remainder of dividing the arguments.
If this remainder is zero, its sign shall be that of x; In this case, the value stored in quot is unspecified.
If denominator is zero, the function may either return zero or cause a domain error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.
!remainder Compute remainder (IEC 60559) (function )
fmod Compute remainder of division (function )
fabs Compute absolute value (function )
round Round to nearest (function )!X
Cplusplus!double rint  (double x);
float rintf (float x);
long double rintl (long double x);
Round to integral value
Rounds x to an integral value, using the rounding direction specified by fegetround.

This function may raise an FE_INEXACT exception if the value returned differs in value from x. See nearbyint for an equivalent function that cannot raise such exception.!rint!x
Value to round.
!The value of x rounded to a nearby integral (as a floating-point value).
If this value differs from x, a FE_INEXACT exception may be raised (depending on the implementation).!nearbyint Round to nearby integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X
Cplusplus!double round  (double x);
float roundf (float x);
long double roundl (long double x);
Round to nearest
Returns the integral value that is nearest to x, with halfway cases rounded away from zero.!round!x
Value to round.!The value of x rounded to the nearest integral (as a floating-point value).!floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )
nearbyint Round to nearby integral value (function )
rint Round to integral value (function )!X
Cplusplus!double scalbln  (double x     , long int n);
float scalblnf (float x      , long int n);
long double scalblnl (long double x, long int n);
Scale significand using floating-point base exponent (long)
Scales x by FLT_RADIX raised to the power of n, returning the result of computing:

scalbn(x,n) = x * FLT_RADIXn 

Presumably, x and n are the components of a floating-point number in the system; In such a case, this function may be optimized to be more efficient than the theoretical operations to compute the value explicitly.

There also exists another version of this function: scalbn, which is identical, except that it takes an int as second argument.!scalbln!Value representing the significand.</dd>
exp
Value of the exponent.!Returns x * FLT_RADIXn.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error may occur (if too small, the function returns zero, and an underflow range error may occur).

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.!scalbn Scale significand using floating-point base exponent (function )
ldexp Generate value from significand and exponent (function )
logb Compute floating-point base logarithm (function )!X
Cplusplus!double scalbn  (double x     , int n);
float scalbnf (float x      , int n);
long double scalbnl (long double x, int n);
Scale significand using floating-point base exponent
Scales x by FLT_RADIX raised to the power of n, returning the same as:

scalbn(x,n) = x * FLT_RADIXn 

Presumably, x and n are the components of a floating-point number in the system; In such a case, this function may be optimized to be more efficient than the theoretical operations to compute the value explicitly.

On most platforms, FLT_RADIX is 2, making this function equivalent to ldexp.!scalbn!x
Value representing the significand.
exp
Value of the exponent.!Returns x * FLT_RADIXn.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error may occur (if too small, the function returns zero, and an underflow range error may occur).

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.!ldexp Generate value from significand and exponent (function )
logb Compute floating-point base logarithm (function )!X
Cplusplus!macro 
signbit(x)
Sign bit
Returns whether the sign of x is negative.

This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive).!signbit!x
A floating-point value.!A non-zero value (true) if the sign of x is negative; and zero (false) otherwise.!isinf Is infinity (macro/function )
isnormal Is normal (macro/function )
isnan Is Not-A-Number (macro/function )
fpclassify Classify floating-point value (macro/function )!X
Cplusplus!double sin  (double x);
float sinf (float x);
long double sinl (long double x);
Compute sine
Returns the sine of an angle of x radians.
!sin!x
Value representing an angle expressed in radians.
One radian is equivalent to 180/PI degrees.!Sine of x radians.!cos Compute cosine (function )
tan Compute tangent (function )!X
Cplusplus!double sinh  (double x);
float sinhf (float x);
long double sinhl (long double x);
Compute hyperbolic sine
Returns the hyperbolic sine of x radians.!sinh!x
Value representing an angle, expressed in radians.!Hyperbolic sine of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!cosh Compute hyperbolic cosine (function )
tanh Compute hyperbolic tangent (function )!X
Cplusplus!double sqrt  (double x);
float sqrtf (float x);
long double sqrtl (long double x);
Compute square root
Returns the square root of x.!sqrt!x
Value whose square root is computed.
If the argument is negative, a domain error occurs.!Square root of x.
If x is negative, a domain error occurs:If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!pow Raise to power (function )
log Compute natural logarithm (function )!X
Cplusplus!double tan  (double x);
float tanf (float x);
long double tanl (long double x);
Compute tangent
Returns the tangent of an angle of x radians.!tan!x
Value representing an angle, expressed in radians.
One radian is equivalent to 180/PI degrees.!Tangent of x radians.!sin Compute sine (function )
cos Compute cosine (function )
atan Compute arc tangent (function )!X
Cplusplus!double tanh  (double x);
float tanhf (float x);
long double tanhl (long double x);
Compute hyperbolic tangent
Returns the hyperbolic tangent of x radians.!tanh!x
Value representing an angle, expressed in radians.!Hyperbolic tangent of x.!sinh Compute hyperbolic sine (function )
cosh Compute hyperbolic cosine (function )!X
Cplusplus!double tgamma  (     double x);
float tgammaf (      float x);
long double tgammal (long double x);
Compute gamma function
gamma function Returns the gamma function of x.!tgamma!x
Parameter for the gamma function.!Gamma function of x.
If the magnitude of x is too large, an overflow range error occurs. If too small, an underflow range error may occur.
If x is zero or a negative integer for which the function is asymptotic, it may cause a domain error or a pole error (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_DIVBYZERO is raised.
!lgamma Compute log-gamma function (function )
erf Compute error function (function )
erfc Compute complementary error function (function )!X
Cplusplus!double trunc  (     double x);
float truncf (      float x);
long double truncl (long double x);
Truncate value
Rounds x toward zero, returning the nearest integral value that is not larger in magnitude than x.
!trunc!x
Value to truncate.!The nearest integral value that is not larger in magnitude than x (as a floating-point value).
!floor Round down value (function )
ceil Round up value (function )
round Round to nearest (function )
rint Round to integral value (function )!X
Cplusplus!Huge value
Macro constant that expands to a positive expression of type double.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VAL (HUGE_VAL or -HUGE_VAL) to indicate the sign of the result.!HUGE_VAL!X!X!X!X
Cplusplus!Huge float value
Macro constant that expands to a positive expression of type float.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VALF (HUGE_VALF or -HUGE_VALF) to indicate the sign of the result.!HUGE_VALF!X!X!X!X
Cplusplus!Huge long double value
Macro constant that expands to a positive expression of type long double.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VALL (HUGE_VALL or -HUGE_VALL) to indicate the sign of the result.!HUGE_VALL!X!X!X!X
Cplusplus!Infinity
Macro constant that expands to an expression of type float.

If the implementation supports infinity values, this is defined as the value that represents a positive or unsigned infinity. Otherwise, it is a positive constant that overflows at translation time.

This may be returned by a function that signals a range error by setting errno to ERANGE.!INFINITY!X!X!X!X
Cplusplus!int
Error handling
Expands to an expression that identifies the error handling mechanism employed by the functions in the <cmath> header:

constant value description
MATH_ERRNO 1 errno is used to signal errors:
- On domain error: errno is set to EDOM.
- On range error (including pole error, overflow, and possibly underflow): errno is set to ERANGE.
MATH_ERREXCEPT 2 The proper C exception is raised:
- On domain error: FE_INVALID is raised.
- On pole error: FE_DIVBYZERO is raised.
- On overflow: FE_OVERFLOW is raised.
- On underflow: FE_UNDERFLOW may be raised.
MATH_ERRNO|MATH_ERREXCEPT 3 Both of the above

Both MATH_ERRNO and MATH_ERREXCEPT are macro constant expressions defined in <cmath> as 1 and 2 respectivelly.!math_errhandling!X!X!X!X
Cplusplus!float
Not-A-Number
Macro constant that expands to an expression of type float that represents a NaN if the implementation supports quiet NaNs (otherwise, it is not defined).!NAN!X!X!nan Generate quiet NaN (function )
nanf Generate quiet NaN (float) (function )
isnan Is Not-A-Number (macro/function )!X
Cplusplus!Floating-point type
Alias of one of the fundamental floating-point types at least as wide as double.

It is the type used by the implementation to evaluate values of type double, as determined by FLT_EVAL_METHOD:

FLT_EVAL_METHOD float_t double_t
0 float double
1 double double
2 long double long double
other implementation-defined implementation-defined
!double_t!X!X!X!X
Cplusplus!Floating-point type
Alias of one of the fundamental floating-point types at least as wide as float.

It is the type used by the implementation to evaluate values of type float, as determined by FLT_EVAL_METHOD:

FLT_EVAL_METHOD float_t double_t
0 float double
1 double double
2 long double long double
other implementation-defined implementation-defined
!float_t!X!X!X!X
Cplusplus!Type to hold information to restore calling environment
This is an array type capable of storing the information of a calling environment to be restored later.

This information is filled by calling macro setjmp and can be restored by calling function longjmp.!jmp_buf!X!X!setjmp Save calling environment for long jump (macro )
longjmp Long jump (function )!X
Cplusplus!void longjmp (jmp_buf env, int val);
Long jump
Restores the environment to the state indicated by env, evaluating the setjmp expression that filled env as val.

The function never returns to the point where it has been invoked. Instead, the function transfers the control to the point where setjmp was last used to fill the env, and evaluates the whole expression as val (unless this is zero, in which case it evaluates as value of 1).

If env was not filled by a previous call to setjmp or if the function with such call has terminated execution, it causes undefined behavior.

In C++, the implementation may perform stack unwinding that destroys objects with automatic duration. If this invokes any non-trivial destructors, it causes undefined behavior.!longjmp!env
Object of type jmp_buf filled by a previous call to setjmp that contains information to restore the environment to that point.
val
Value to which the setjmp expression evaluates.
If this is zero, the expression evaluates as 1.!none (the function never returns).!setjmp Save calling environment for long jump (macro )
jmp_buf Type to hold information to restore calling environment (type )!X
Cplusplus!int setjmp (jmp_buf env);
Save calling environment for long jump
This macro with functional form fills env with information about the current state of the calling environment in that point of code execution, so that it can be restored by a later call to longjmp.

Calling longjmp with the information stored in env restores this same state and returns the control to that same point (the call to setjmp), which is evaluated as a particular non-zero value.

The state of the calling environment includes the values of all accessible objects, except those of automatic duration local to the function which do not have volatile-qualified types and which change before the call to longjmp; these have indeterminate values.

The invocation of setjmp shall be an expression statement by itself, or be evaluated in a selection or iteration statement either as the (potentially negated) entire controlling expression or compared against an integer constant expression. Otherwise, it causes undefined behavior.!setjmp!env
Object of type jmp_buf where the environment information is stored.!This macro may return more than once: A first time, on its direct invocation; In this case it always returns zero.
When longjmp is called with the information set to env, the macro returns again; this time it returns the value passed to longjmp as second argument if this is different from zero, or 1 if it is zero.!longjmp Long jump (function )
jmp_buf Type to hold information to restore calling environment (type )!X
Cplusplus!int raise (int sig);
Generates a signal
Sends signal sig to the current executing program.

The signal is handled as specified by function signal.
!raise!sig
The signal value to raise. The following macro constant expressions identify standard signal values:

macro signal
SIGABRT (Signal Abort) Abnormal termination, such as is initiated by the abort function.
SIGFPE (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
SIGILL (Signal Illegal Instruction) Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
SIGINT (Signal Interrupt) Interactive attention signal. Generally generated by the application user.
SIGSEGV (Signal Segmentation Violation) Invalid access to storage: When a program tries to read or write outside the memory it is allocated for it.
SIGTERM (Signal Terminate) Termination request sent to program.

Each library implentation may provide additional signal value macro constants to be used with this function.!Returns zero if successful, and a value different from zero otherwise.!signal Set function to handle signal (function )!X
Cplusplus!void (*signal(int sig, void (*func)(int)))(int);
Set function to handle signal
Specifies a way to handle the signals with the signal number specified by sig.

Parameter func specifies one of the three ways in which a signal can be handled by a program:
Default handling (SIG_DFL): The signal is handled by the default action for that particular signal.
Ignore signal (SIG_IGN): The signal is ignored and the code execution will continue even if not meaningful.
Function handler: A specific function is defined to handle the signal.

Either SIG_DFL or SIG_IGN is set as the default signal handling behavior at program startup for each of the supported signals .
!signal!sig
The signal value to which a handling function is set. The following macro constant expressions identify standard signal values:

macro signal
SIGABRT (Signal Abort) Abnormal termination, such as is initiated by the abort function.
SIGFPE (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
SIGILL (Signal Illegal Instruction) Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
SIGINT (Signal Interrupt) Interactive attention signal. Generally generated by the application user.
SIGSEGV (Signal Segmentation Violation) Invalid access to storage: When a program tries to read or write outside the memory it has allocated.
SIGTERM (Signal Terminate) Termination request sent to program.

Each library implementation may provide additional signal value macro constants that can be used with this function.

Notice that not all running environments are required to generate automatic signals, not even in the specific cases described above, although all running environments must deliver signals generated by a explicit call to the raise function.
func
A pointer to a function. This may either be a function defined by the programmer or one of the following predefined functions:

SIG_DFL Default handling: The signal is handled by the default action for that particular signal.
SIG_IGN Ignore Signal: The signal is ignored.

If a function, it should follow the following prototype (with C linkage):
 
void handler_function (int parameter);
!The return type is the same as the type of parameter func.

If the request is successful, the function returns a pointer to the particular handler function which was in charge of handling this signal before the call, if any. Or either SIG_DFL or SIG_IGN if before the call the signal was being handled by the default handler or was being ignored, respectivelly.

If the function was not successful in registering the new signal handling procedure, it returns SIG_ERR and errno may be set to a positive value.
!raise Generates a signal (function )!X
Cplusplus!Integral type
Integral type of an object that can be accessed as an atomic entity, even in the presence of asynchronous signals.!sig_atomic_t!X!X!X!X
Cplusplus!type va_arg (va_list ap, type)
Retrieve next argument
This macro expands to an expression of type type with the value of the current argument in the variable arguments list identified by ap.

Each call to this macro modifies the state of ap so that the next call to this macro will expand to the argument that follows the one it evaluates to.

Notice that va_arg cannot determine the actual type of the argument passed to the function, but uses whatever type is passed as the type macro argument as its type.

Notice also that va_arg does not determine either whether the retrieved argument is the last argument passed to the function (or even if it is an element past the end of that list). The function should be designed in such a way that the number of parameters can be inferred in some way by the values of either the named parameters or the additional arguments already read.!va_arg!ap
Object of type va_list carrying information about the current retrieval state of a variable argument list. This object shall have been initialized by an initial call to va_start or va_copy and not have been released with va_end.
type
A type name. This type name is used as the type of the expression this macro expands to (i.e., its return type). 
For a type expression to be suitable for its use with va_arg, it must be such that type* produces a pointer to type.
The type shall be compatible with type of the extracted argument (as promoted according to the default argument promotions), or one be the unsigned version of the other, or one be a void pointer and the other some other pointer type.
!Returns the current additional argument as an expression of type type.!va_start Initialize a variable argument list (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )
vsprintf Write formatted data from variable argument list to string (function )!X
Cplusplus!void va_copy (va_list dest, va_list src);
Copy variable argument list
Initializes dest as a copy of src (in its current state).

The next argument to be extracted from dest is the same as the one that would be extracted from src.

A function that invokes va_copy, shall also invoke va_end on dest before it returns.!va_copy!dest
Uninitialized object of type va_list.
After the call, it carries the information needed to retrieve the same additional arguments as src.
If src has already been passed as first argument to a previous call to va_start or va_copy, it shall be passed to va_end before calling this function.
src
Object of type va_list that already carries information to retrieve additional arguments with va_arg (i.e., it has already been passed as first argument to va_start or va_copy ans has not yet been released with va_end).!none!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )!X
Cplusplus!void va_end (va_list ap);
End using variable argument list
Performs the appropriate actions to facilitate a normal return by a function that has used the va_list object ap to retrieve its additional arguments.

This macro should be invoked before the function returns whenever va_start has been invoked from that function.!va_end!ap
va_list object previously initialized by va_start or va_copy.!none!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_list Type to hold information about variable arguments (type )!X
Cplusplus!void va_start (va_list ap, paramN);
Initialize a variable argument list
Initializes ap to retrieve the additional arguments after parameter paramN.

A function that invokes va_start, shall also invoke va_end before it returns.!va_start!ap
Uninitialized object of type va_list.
After the call, it carries the information needed to retrieve the additional arguments using va_arg.
If ap has already been passed as first argument to a previous call to va_start or va_copy, it shall be passed to va_end before calling this function.
paramN
Name of the last named parameter in the function definition. The arguments extracted by subsequent calls to va_arg are those after paramN.
CC++
The parameter shall not be a parameter declared with register storage class, with function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions.
!none!va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )
vsprintf Write formatted data from variable argument list to string (function )!X
Cplusplus!Type to hold information about variable arguments
This type is used as a parameter for the macros defined in <cstdarg> to retrieve the additional arguments of a function.

va_start initializes an object of this type in such a way that subsequent calls to va_arg sequentially retrieve the additional arguments passed to the function.

Before a function that has initialized a va_list object with va_start returns, the va_end macro shall be invoked.

The specifics of this type depend on the particular library implementation. Objects of this type shall only be used as argument for the va_start, va_arg, va_end and va_copy macros, or functions that use them, like the variable argument functions in <cstdio> (vprintf, vscanf, vsnprintf, vsprintf and vsscanf).!va_list!X!X!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )!X
Cplusplus!Null pointer
This macro expands to a null pointer constant.A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X
Cplusplus!offsetof (type,member)
Return member offset
This macro with functional form returns the offset value in bytes of member member in the data structure or union type type.

The value returned is an unsigned integral value of type size_t with the number of bytes between the specified member and the beginning of its structure.!offsetof!type
A type in which member is a valid member designator.
CC++98C++11
type shall be a structure or union type.
member
A member of type.!A value of type size_t with the offset value of member in type.!X!X
Cplusplus!Type with widest scalar alignment
Alias of a POD type whose alignment requirement is at least as great as that of any possible scalar type, and whose alignment requirement is supported in every context.!max_align_t!!X!X!X
Cplusplus!typedef decltype(nullptr) nullptr_t;
Null pointer type (C++)
Type of the null pointer constant nullptr.

This type can only take one value: nullptr, which when converted to a pointer type takes the proper null pointer value.

Even though nullptr_t it is not a keyword, it identifies a distinct fundamental type: the type of nullptr. As such, it participates in overload resolution as a different type.

This type is only defined for C++ (since C++11).!nullptr_t!X!X!X!X
Cplusplus!Result of pointer subtraction
Alias of one of the fundamental signed integer types.

It is a type able to represent the result of any valid pointer subtraction operation.

A pointer subtraction is only guaranteed to have a valid defined value for pointers to elements of the same array (or for the element just past the last in the array).!ptrdiff_t!X!X!X!X
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.!size_t!X!X!X!X
Cplusplus!void abort (void);
Abort current process
Aborts the current process, producing an abnormal program termination.

The function raises the SIGABRT signal (as if raise(SIGABRT) was called). This, if uncaught, causes the program to terminate returning a platform-dependent unsuccessful termination error code to the host environment.

The program is terminated without destroying any object and without calling any of the functions passed to atexit or at_quick_exit.!abort!none!none (the function never returns).!exit Terminate calling process (function )
atexit Set function to be executed on exit (function )!X
Cplusplus!int abs (int n);
Absolute value
Returns the absolute value of parameter n ( /n/ ).

In C++, this function is also overloaded in header <cmath> for floating-point types (see cmath abs), in header <complex> for complex numbers (see complex abs), and in header <valarray> for valarrays (see valarray abs).!abs!n
Integral value.!The absolute value of n.!labs Absolute value (function )
fabs Compute absolute value (function )
div Integral division (function )!X
Cplusplus!int atexit (void (*func)(void));
Set function to be executed on exit
The function pointed by func is automatically called without arguments when the program terminates normally.

If more than one atexit function has been specified by different calls to this function, they are all executed in reverse order as a stack (i.e. the last function specified is the first to be executed at exit).

A single function can be registered to be executed at exit more than once.

If atexit is called after exit, the call may or may not succeed depending on the particular system and library implementation (unspecified behavior).

If a function registered with atexit throws an exception for which it does not provide a handler when called on termination, terminate is automatically called (C++).

Particular library implementations may impose a limit on the number of functions call that can be registered with atexit, but this cannot be less than 32 function calls.
!atexit!function
Function to be called. The function shall return no value and take no arguments.!A zero value is returned if the function was successfully registered.
If it failed, a non-zero value is returned.!exit Terminate calling process (function )
abort Abort current process (function )!X
Cplusplus!Convert string to double
Parses the C string str, interpreting its content as a floating point number and returns its value as a double.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax resembling that of floating point literals (see below), and interprets them as a numerical value. The rest of the string after the last valid character is ignored and has no effect on the behavior of this function.
A valid floating point number for atof using the "C" locale is formed by an optional sign character (+ or -), followed by one of:
- A sequence of digits, optionally containing a decimal-point character (.), optionally followed by an exponent part (an e or E character followed by an optional sign and a sequence of digits).
- A 0x or 0X prefix, then a sequence of hexadecimal digits (as in isxdigit) optionally containing a period which separates the whole and fractional number parts. Optionally followed by a power of 2 exponent (a p or P character followed by an optional sign and a sequence of hexadecimal digits).
- INF or INFINITY (ignoring case).
- NAN or NANsequence (ignoring case), where sequence is a sequence of characters, where each character is either an alphanumeric character (as in isalnum) or the underscore character (_).

If the first sequence of non-whitespace characters in str does not form a valid floating-point number as just defined, or if no such sequence exists because either str is empty or contains only whitespace characters, no conversion is performed and the function returns 0.0.!atof!str
C-string beginning with the representation of a floating-point number.!On success, the function returns the converted floating point number as a double value.
If no valid conversion could be performed, the function returns zero (0.0).
If the converted value would be out of the range of representable values by a double, it causes undefined behavior. See strtod for a more robust cross-platform alternative when this is a possibility.!strtod Convert string to double (function )
atoi Convert string to integer (function )
atol Convert string to long integer (function )!X
Cplusplus!int atoi (const char * str);
Convert string to integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type int.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed and zero is returned.!atoi!!X!X!X
Cplusplus!long int atol ( const char * str );
Convert string to long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long int.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed and zero is returned.
!atol!str
C-string containing the representation of an integral number.!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned.
If the converted value would be out of the range of representable values by a long int, it causes undefined behavior. See strtol for a more robust cross-platform alternative when this is a possibility.!atoi Convert string to integer (function )
atof Convert string to double (function )
strtol Convert string to long integer (function )!X
Cplusplus!long long int atoll ( const char * str );
Convert string to long long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long long int.

This function operates like atol to interpret the string, but produces numbers of type long long int (see atol for details on the interpretation process).!atoll!str
C-string containing the representation of an integral number.!On success, the function returns the converted integral number as a long long int value.
If no valid conversion could be performed, a zero value is returned.
If the converted value would be out of the range of representable values by a long long int, it causes undefined behavior. See strtoll for a more robust cross-platform alternative when this is a possibility.!atoi
Convert string to integer (function )
atol
Convert string to long integer (function )
strtoll
Convert string to long long integer (function )!X
