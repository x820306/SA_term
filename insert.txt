Cplusplus!void clearerr ( FILE * stream );
Clear error indicators
Resets both the error and the eof indicators of the stream.

When a i/o function fails either because of an error or because the end of the file has been reached, one of these internal indicators may be set for the stream. The state of these indicators is cleared by a call to this function, or by a call to any of: rewind, fseek, fsetpos and freopen.!cleareer!stream
Pointer to a FILE object that identifies the stream.!None!feof Check end-of-file indicator (function )
ferror Check error indicator (function )
rewind Set position of stream to the beginning (function )!X!
Cplusplus!int fclose ( FILE * stream );
Close file
Closes the file associated with the stream and disassociates it.

All internal buffers associated with the stream are disassociated from it and flushed: the content of any unwritten output buffer is written and the content of any unread input buffer is discarded.

Even if the call fails, the stream passed as parameter will no longer be associated with the file nor its buffers.!fclose!stream
Pointer to a FILE object that specifies the stream to be closed.!If the stream is successfully closed, a zero value is returned.
On failure, EOF is returned.!fopen Open file (function )
fflush Flush stream (function )!X!
Cplusplus!int feof ( FILE * stream );
Check end-of-file indicator
Checks whether the end-of-File indicator associated with stream is set, returning a value different from zero if it is.

This indicator is generally set by a previous operation on the stream that attempted to read at or past the end-of-file.

Notice that stream's internal position indicator may point to the end-of-file for the next operation, but still, the end-of-file indicator may not be set until an operation attempts to read at that point.

This indicator is cleared by a call to clearerr, rewind, fseek, fsetpos or freopen. Although if the position indicator is not repositioned by such a call, the next i/o operation is likely to set the indicator again.!feof!stream
Pointer to a FILE object that identifies the stream.!A non-zero value is returned in the case that the end-of-file indicator associated with the stream is set.
Otherwise, zero is returned.!clearerr Clear error indicators (function )
ferror Check error indicator (function )!X!
Cplusplus!int ferror ( FILE * stream );
Check error indicator
Checks if the error indicator associated with stream is set, returning a value different from zero if it is.

This indicator is generally set by a previous operation on the stream that failed, and is cleared by a call to clearerr, rewind or freopen.!ferror!stream
Pointer to a FILE object that identifies the stream.!A non-zero value is returned in the case that the error indicator associated with the stream is set.
Otherwise, zero is returned.!feof Check end-of-file indicator (function )
clearerr Clear error indicators (function )
perror Print error message (function )!X!
Cplusplus!int fflush ( FILE * stream );
Flush stream
If the given stream was open for writing (or if it was open for updating and the last i/o operation was an output operation) any unwritten data in its output buffer is written to the file.

If stream is a null pointer, all such streams are flushed.

In all other cases, the behavior depends on the specific library implementation. In some implementations, flushing a stream open for reading causes its input buffer to be cleared (but this is not portable expected behavior).

The stream remains open after this call.

When a file is closed, either because of a call to fclose or because the program terminates, all the buffers associated with it are automatically flushed.!fflush!stream
Pointer to a FILE object that specifies a buffered stream.!A zero value indicates success.
If an error occurs, EOF is returned and the error indicator is set (see ferror).!fclose Close file (function )
fopen Open file (function )
setbuf Set stream buffer (function )
setvbuf Change stream buffering (function )!X!
Cplusplus!int fgetc ( FILE * stream );
Get character from stream
Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character.

If the stream is at the end-of-file when called, the function returns EOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns EOF and sets the error indicator for the stream (ferror).

fgetc and getc are equivalent, except that getc may be implemented as a macro in some libraries.!fgetc!stream
Pointer to a FILE object that identifies an input stream.!On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the position indicator was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stream.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!getc Get character from stream (function )
fputc Write character to stream (function )
fread Read block of data from stream (function )
fscanf Read formatted data from stream (function )!X!
Cplusplus!int fgetpos ( FILE * stream, fpos_t * pos );
Get current position in stream
Retrieves the current position in the stream.

The function fills the fpos_t object pointed by pos with the information needed from the stream's position indicator to restore the stream to its current position (and multibyte state, if wide-oriented) with a call to fsetpos.

The ftell function can be used to retrieve the current position in the stream as an integer value.!fgetpos!stream
Pointer to a FILE object that identifies the stream.
pos
Pointer to a fpos_t object.
This should point to an object already allocated.!On success, the function returns zero.
In case of error, errno is set to a platform-specific positive value and the function returns a non-zero value.!fsetpos Set position indicator of stream (function )
ftell Get current position in stream (function )
fseek Reposition stream position indicator (function )!X!
Cplusplus!char * fgets ( char * str, int num, FILE * stream );
Get string from stream
Reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first.

A newline character makes fgets stop reading, but it is considered a valid character by the function and included in the string copied to str.

A terminating null character is automatically appended after the characters copied to str.

Notice that fgets is quite different from gets: not only fgets accepts a stream argument, but also allows to specify the maximum size of str and includes in the string any ending newline character.
!fgets!str : 
Pointer to an array of chars where the string read is copied.
num : 
Maximum number of characters to be copied into str (including the terminating null-character).
stream :
Pointer to a FILE object that identifies an input stream.
stdin can be used as argument to read from the standard input.
!On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).!fputs Write string to stream (function )
fgetc Get character from stream (function )
gets Get string from stdin (function )!¢æ!
Cplusplus!FILE * fopen ( const char * filename, const char * mode );
Open file
Opens the file whose name is specified in the parameter filename and associates it with a stream that can be identified in future operations by the FILE pointer returned.

The operations that are allowed on the stream and how these are performed are defined by the mode parameter.

The returned stream is fully buffered by default if it is known to not refer to an interactive device (see setbuf).

The returned pointer can be disassociated from the file by calling fclose or freopen. All opened files are automatically closed on normal program termination.

The running environment supports at least FOPEN_MAX files open simultaneously.!fopen!filename
C string containing the name of the file to be opened.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
mode
C string containing a file access mode. It can be:
"r" read: Open file for input operations. The file must exist.
"w" write: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file.
"a" append: Open file for output at the end of a file. Output operations always write data at the end of the file, expanding it. Repositioning operations (fseek, fsetpos, rewind) are ignored. The file is created if it does not exist.
"r+" read/update: Open a file for update (both for input and output). The file must exist.
"w+" write/update: Create an empty file and open it for update (both for input and output). If a file with the same name already exists its contents are discarded and the file is treated as a new empty file.
"a+" append/update: Open a file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file. The file is created if it does not exist.
With the mode specifiers above the file is open as a text file. In order to open a file as a binary file, a "b" character has to be included in the mode string. This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").

The new C standard (C2011, which is not part of C++) adds a new standard subspecifier ("x"), that can be appended to any "w" specifier (to form "wx", "wbx", "w+x" or "w+bx"/"wb+x"). This subspecifier forces the function to fail if the file exists, instead of overwriting it.

If additional characters follow the sequence, the behavior depends on the library implementation: some implementations may ignore additional characters so that for example an additional "t" (sometimes used to explicitly state a text file) is accepted.

On some library implementations, opening or creating a text file with update mode may treat the stream instead as a binary file.

Text files are files containing sequences of lines of text. Depending on the environment where the application runs, some special character conversion may occur in input/output operations in text mode to adapt them to a system-specific text file format. Although on some environments no conversions occur and both text files and binary files are treated the same way, using the appropriate mode improves portability.

For files open for update (those which include a "+" sign), on which both input and output operations are allowed, the stream shall be flushed (fflush) or repositioned (fseek, fsetpos, rewind) before a reading operation that follows a writing operation. The stream shall be repositioned (fseek, fsetpos, rewind) before a writing operation that follows a reading operation (whenever that operation did not reach the end-of-file).!If the file is successfully opened, the function returns a pointer to a FILE object that can be used to identify the stream on future operations.
Otherwise, a null pointer is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.
!fclose Close file (function )
freopen Reopen stream with different file or mode (function )
setbuf Set stream buffer (function )
setvbuf Change stream buffering (function )
tmpfile Open a temporary file (function )
tmpnam Generate temporary filename (function )!X!
Cplusplus!int fprintf ( FILE * stream, const char * format, ... );
Write formatted data to stream
Writes the C string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.

After the format parameter, the function expects at least as many additional arguments as specified by format.!fprintf !stream
Pointer to a FILE object that identifies an output stream.
format
C string that contains the text to be written to the stream.
It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested.

A format specifier follows this prototype:

%[flags][width][.precision][length]specifier 

Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
specifier Output Example
d or i Signed decimal integer 392
u Unsigned decimal integer 7235
o Unsigned octal 610
x Unsigned hexadecimal integer 7fa
X Unsigned hexadecimal integer (uppercase) 7FA
f Decimal floating point, lowercase 392.65
F Decimal floating point, uppercase 392.65
e Scientific notation (mantissa/exponent), lowercase 3.9265e+2
E Scientific notation (mantissa/exponent), uppercase 3.9265E+2
g Use the shortest representation: %e or %f 392.65
G Use the shortest representation: %E or %F 392.65
a Hexadecimal floating point, lowercase -0xc.90fep-2
A Hexadecimal floating point, uppercase -0XC.90FEP-2
c Character a
s String of characters sample
p Pointer address b8000000
n Nothing printed.
The corresponding argument must be a pointer to a signed int.
The number of characters written so far is stored in the pointed location. 
% A % followed by another % character will write a single % to the stream. %

The format specifier can also contain sub-specifiers: flags, width, .precision and modifiers (in that order), which are optional and follow these specifications:

flags description
- Left-justify within the given field width; Right justification is the default (see width sub-specifier).
+ Forces to preceed the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign.
(space) If no sign is going to be written, a blank space is inserted before the value.
# Used with o, x or X specifiers the value is preceeded with 0, 0x or 0X respectively for values different than zero.
Used with a, A, e, E, f, F, g or G it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.
0 Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier).

width description
(number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.
* The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

.precision description
.number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.
For a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).
For g and G specifiers: This is the maximum number of significant digits to be printed.
For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.
If the period is specified without an explicit value for precision, 0 is assumed.
.* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

The length sub-specifier modifies the length of the data type. This is a chart showing the types used to interpret the corresponding arguments with and without length specifier (if a different type is used, the proper type promotion or conversion is performed, if allowed):
specifiers
length d i u o x X f F e E g G a A c s p n
(none) int unsigned int double int char* void* int*
hh signed char unsigned char     signed char*
h short int unsigned short int     short int*
l long int unsigned long int  wint_t wchar_t*  long int*
ll long long int unsigned long long int     long long int*
j intmax_t uintmax_t     intmax_t*
z size_t size_t     size_t*
t ptrdiff_t ptrdiff_t     ptrdiff_t*
L   long double    
Note that the c specifier takes an int (or wint_t) as argument, but performs the proper conversion to a char value (or a wchar_t) before formatting it for output.

Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. See <cinttypes> for the specifiers for extended types.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!printf Print formatted data to stdout (function )
fscanf Read formatted data from stream (function )
fwrite Write block of data to stream (function )
fputs Write string to stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.!
Cplusplus!int fputc ( int character, FILE * stream );
Write character to stream
Writes a character to the stream and advances the position indicator.

The character is written at the position indicated by the internal position indicator of the stream, which is then automatically advanced by one.!fputc!character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.
stream
Pointer to a FILE object that identifies an output stream.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.!putc Write character to stream (function )
fgetc Get character from stream (function )
fwrite Write block of data to stream (function )
fopen Open file (function )!X!
Cplusplus!int fputs ( const char * str, FILE * stream );
Write string to stream
Writes the C string pointed by str to the stream.

The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream.

Notice that fputs not only differs from puts in that the destination stream can be specified, but also fputs does not write additional characters, while puts appends a newline character at the end automatically.!fputs!str
C string with the content to be written to stream.
stream
Pointer to a FILE object that identifies an output stream.!On success, a non-negative value is returned.
On error, the function returns EOF and sets the error indicator (ferror).!puts Write string to stdout (function )
fgets Get string from stream (function )
fputc Write character to stream (function )
fprintf Write formatted data to stream (function )
fwrite Write block of data to stream (function )!X!
Cplusplus!size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
Read block of data from stream
Reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by ptr.

The position indicator of the stream is advanced by the total amount of bytes read.

The total amount of bytes read if successful is (size*count).!fread!ptr
Pointer to a block of memory with a size of at least (size*count) bytes, converted to a void*.
size
Size, in bytes, of each element to be read.
size_t is an unsigned integral type.
count
Number of elements, each one with a size of size bytes.
size_t is an unsigned integral type.
stream
Pointer to a FILE object that specifies an input stream.!The total number of elements successfully read is returned.
If this number differs from the count parameter, either a reading error occurred or the end-of-file was reached while reading. In both cases, the proper indicator is set, which can be checked with ferror and feof, respectively.
If either size or count is zero, the function returns zero and both the stream state and the content pointed by ptr remain unchanged.
size_t is an unsigned integral type.!fwrite Write block of data to stream (function )
fgetc Get character from stream (function )
fscanf Read formatted data from stream (function )!X!
Cplusplus!FILE * freopen ( const char * filename, const char * mode, FILE * stream );
Reopen stream with different file or mode
Reuses stream to either open the file specified by filename or to change its access mode.

If a new filename is specified, the function first attempts to close any file already associated with stream (third parameter) and disassociates it. Then, independently of whether that stream was successfuly closed or not, freopen opens the file specified by filename and associates it with the stream just as fopen would do using the specified mode.

If filename is a null pointer, the function attempts to change the mode of the stream. Although a particular library implementation is allowed to restrict the changes permitted, and under which circumstances.

The error indicator and eof indicator are automatically cleared (as if clearerr was called).

This function is especially useful for redirecting predefined streams like stdin, stdout and stderr to specific files (see the example below).!freopen!filename
C string containing the name of the file to be opened.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
If this parameter is a null pointer, the function attempts to change the mode of the stream, as if the file name currently associated with that stream had been used.
mode
C string containing a file access mode. It can be:
"r" read: Open file for input operations. The file must exist.
"w" write: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file.
"a" append: Open file for output at the end of a file. Output operations always write data at the end of the file, expanding it. Repositioning operations (fseek, fsetpos, rewind) are ignored. The file is created if it does not exist.
"r+" read/update: Open a file for update (both for input and output). The file must exist.
"w+" write/update: Create an empty file and open it for update (both for input and output). If a file with the same name already exists its contents are discarded and the file is treated as a new empty file.
"a+" append/update: Open a file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file. The file is created if it does not exist.
With the mode specifiers above the file is open as a text file. In order to open a file as a binary file, a "b" character has to be included in the mode string. This additional "b" character can either be appended at the end of the string (thus making the following compound modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").

The new C standard (C2011, wich is not part of C++) adds a new standard subspecifier ("x"), that can be appended to any "w" speficier (to form "wx", "wbx", "w+x" or "w+bx"/"wb+x"). This subspecifier forces the function to fail if the file exists, instead of overwriting it.

If additional characters follow the sequence, the behavior depends on the library implementation: some implementations may ignore additional characters so that for example an additional "t" (sometimes used to explicitly state a text file) is accepted.

On some library implementations, opening or creating a text file with update mode may treat the stream instead as a binary file.
stream
pointer to a FILE object that identifies the stream to be reopened.!If the file is successfully reopened, the function returns the pointer passed as parameter stream, which can be used to identify the reopened stream.
Otherwise, a null pointer is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!fopen Open file (function )
fclose Close file (function )!X!
Cplusplus!int fscanf ( FILE * stream, const char * format, ... );
Read formatted data from stream
Reads data from the stream and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!fscanf!stream
Pointer to a FILE object that identifies the input stream to read data from.
format
C string that contains a sequence of characters that control how characters extracted from the stream are treated:
Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
Non-whitespace character, except format specifier (%): Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.
Format specifiers: A sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

A format specifier for fscanf follows this prototype:

%[*][width][length]specifier 

Where the specifier character at the end is the most significant component, since it defines which characters are extracted, their interpretation and the type of its corresponding argument:
specifier Description Characters extracted
i, u Integer Any number of digits, optionally preceded by a sign (+ or -).
Decimal digits assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x hexadecimal digits (0-f).
d Decimal integer Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).
o Octal integer Any number of octal digits (0-7), optionally preceded by a sign (+ or -).
x Hexadecimal integer Any number of hexadecimal digits (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).
f, e, g Floating point number A series of decimal digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by strtod).
Implementations complying with C99 also support hexadecimal floating-point format when preceded by 0x or 0X.
a
c Character The next character. If a width other than 1 is specified, the function reads exactly width characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end.
s String of characters Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.
p Pointer address A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.
[characters] Scanset Any number of the characters specified between the brackets.
A dash (-) that is not the first character may produce non-portable behavior in some library implementations.
[^characters] Negated scanset Any number of characters none of them specified as characters between the brackets.
n Count No input is consumed. The number of characters read so far from stream is stored in the pointed location.
% % A % followed by another % matches a single %.
Except for n, at least one character shall be consumed by any specifier. Otherwise the match fails, and the scan ends there.

The format specifier can also contain sub-specifiers: asterisk (*), width and length (in that order), which are optional and follow these specifications:
sub-specifier description
* An optional starting asterisk indicates that the data is to be read from the stream but ignored (i.e. it is not stored in the location pointed by an argument).
width Specifies the maximum number of characters to be read in the current reading operation (optional).
length One of hh, h, l, ll, j, z, t, L (optional).
This alters the expected type of the storage pointed by the corresponding argument (see below).

This is a chart showing the types expected for the corresponding arguments where input is stored (both with and without a length sub-specifier):
specifiers
length d i u o x f e g a c s [] [^] p n
(none) int* unsigned int* float* char* void** int*
hh signed char* unsigned char*    signed char*
h short int* unsigned short int*    short int*
l long int* unsigned long int* double* wchar_t*  long int*
ll long long int* unsigned long long int*    long long int*
j intmax_t* uintmax_t*    intmax_t*
z size_t* size_t*    size_t*
t ptrdiff_t* ptrdiff_t*    ptrdiff_t*
L   long double*   
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.
These arguments are expected to be pointers: to store the result of a fscanf operation on a regular variable, its name should be preceded by the reference operator (&) (see example).!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!scanf Read formatted data from stdin (function )
fprintf Write formatted data to stream (function )
fread Read block of data from stream (function )
fgets Get string from stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced by C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.!
Cplusplus!int fseek ( FILE * stream, long int offset, int origin );
Reposition stream position indicator
Sets the position indicator associated with the stream to a new position.

For streams open in binary mode, the new position is defined by adding offset to a reference position specified by origin.

For streams open in text mode, offset shall either be zero or a value returned by a previous call to ftell, and origin shall necessarily be SEEK_SET.

If the function is called with other values for these arguments, support depends on the particular system and library implementation (non-portable).

The end-of-file internal indicator of the stream is cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to fseek allows to switch between reading and writing.!fseek!stream
Pointer to a FILE object that identifies the stream.
offset
Binary files: Number of bytes to offset from origin.
Text files: Either zero, or a value returned by ftell.
origin
Position used as reference for the offset. It is specified by one of the following constants defined in <cstdio> exclusively to be used as arguments for this function:
Constant Reference position
SEEK_SET Beginning of file
SEEK_CUR Current position of the file pointer
SEEK_END End of file *
* Library implementations are allowed to not meaningfully support SEEK_END (therefore, code using it has no real standard portability).!If successful, the function returns zero.
Otherwise, it returns non-zero value.
If a read or write error occurs, the error indicator (ferror) is set.!ftell Get current position in stream (function )
fsetpos Set position indicator of stream (function )
rewind Set position of stream to the beginning (function )!X!
Cplusplus!int fsetpos ( FILE * stream, const fpos_t * pos );
Set position indicator of stream
Restores the current position in the stream to pos.

The internal file position indicator associated with stream is set to the position represented by pos, which is a pointer to an fpos_t object whose value shall have been previously obtained by a call to fgetpos.

The end-of-file internal indicator of the stream is cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to fsetpos allows to switch between reading and writing.

A similar function, fseek, can be used to set arbitrary positions on streams open in binary mode.
!fsetpos!stream
Pointer to a FILE object that identifies the stream.
position
Pointer to a fpos_t object containing a position previously obtained with fgetpos.
!If successful, the function returns zero.
On failure, a non-zero value is returned and errno is set to a system-specific positive value.!fgetpos Get current position in stream (function )
fseek Reposition stream position indicator (function )
rewind Set position of stream to the beginning (function )!X!
Cplusplus!long int ftell ( FILE * stream );
Get current position in stream
Returns the current value of the position indicator of the stream.

For binary streams, this is the number of bytes from the beginning of the file.

For text streams, the numerical value may not be meaningful but can still be used to restore the position to the same position later using fseek (if there are characters put back using ungetc still pending of being read, the behavior is undefined).!ftell!stream
Pointer to a FILE object that identifies the stream.!On success, the current value of the position indicator is returned.
On failure, -1L is returned, and errno is set to a system-specific positive value.!fseek Reposition stream position indicator (function )
fgetpos Get current position in stream (function )
rewind Set position of stream to the beginning (function )!X!
Cplusplus!size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );
Write block of data to stream
Writes an array of count elements, each one with a size of size bytes, from the block of memory pointed by ptr to the current position in the stream.

The position indicator of the stream is advanced by the total number of bytes written.

Internally, the function interprets the block pointed by ptr as if it was an array of (size*count) elements of type unsigned char, and writes them sequentially to stream as if fputc was called for each byte.!fwrite!ptr
Pointer to the array of elements to be written, converted to a const void*.
size
Size in bytes of each element to be written.
size_t is an unsigned integral type.
count
Number of elements, each one with a size of size bytes.
size_t is an unsigned integral type.
stream
Pointer to a FILE object that specifies an output stream.!The total number of elements successfully written is returned.
If this number differs from the count parameter, a writing error prevented the function from completing. In this case, the error indicator (ferror) will be set for the stream.
If either size or count is zero, the function returns zero and the error indicator remains unchanged.
size_t is an unsigned integral type.!fread Read block of data from stream (function )
fprintf Write formatted data to stream (function )
putc Write character to stream (function )
fputc Write character to stream (function )!X!
Cplusplus!int getc ( FILE * stream );
Get character from stream
Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character.

If the stream is at the end-of-file when called, the function returns EOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns EOF and sets the error indicator for the stream (ferror).

getc and fgetc are equivalent, except that getc may be implemented as a macro in some libraries. See getchar for a similar function that reads directly from stdin.!getc !stream
Pointer to a FILE object that identifies an input stream.
Because some libraries may implement this function as a macro, and this may evaluate the stream expression more than once, this should be an expression without side effects.!On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the position indicator was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stream.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!fgetc Get character from stream (function )
fputc Write character to stream (function )
fread Read block of data from stream (function )
fwrite Write block of data to stream (function )!X!
Cplusplus!int getchar ( void );
Get character from stdin
Returns the next character from the standard input (stdin).

It is equivalent to calling getc with stdin as argument.!getchar!(none) !On success, the character read is returned (promoted to an int value).
The return type is int to accommodate for the special value EOF, which indicates failure:
If the standard input was at the end-of-file, the function returns EOF and sets the eof indicator (feof) of stdin.
If some other reading error happens, the function also returns EOF, but sets its error indicator (ferror) instead.!getc Get character from stream (function )
putchar Write character to stdout (function )
scanf Read formatted data from stdin (function )!X!
Cplusplus!char * gets ( char * str );
Get string from stdin
Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.

The newline character, if found, is not copied into str.

A terminating null character is automatically appended after the characters copied to str.

Notice that gets is quite different from fgets: not only gets uses stdin as source, but it does not include the ending newline character in the resulting string and does not allow to specify a maximum size for str (which can lead to buffer overflows).!gets!str
Pointer to a block of memory (array of char) where the string read is copied as a C string.!On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).!fgets Get string from stream (function )
getchar Get character from stdin (function )
scanf Read formatted data from stdin (function )!The most recent revision of the C standard (2011) has definitively removed this function from its specification.
The function is deprecated in C++ (as of 2011 standard, which follows C99+TC3).!
Cplusplus!void perror ( const char * str );
Print error message
Interprets the value of errno as an error message, and prints it to stderr (the standard error output stream, usually the console), optionally preceding it with the custom message specified in str.

errno is an integral variable whose value describes the error condition or diagnostic information produced by a call to a library function (any function of the C standard library may set a value for errno, even if not explicitly specified in this reference, and even if no error happened), see errno for more info.

The error message produced by perror is platform-depend.

If the parameter str is not a null pointer, str is printed followed by a colon (:) and a space. Then, whether str was a null pointer or not, the generated error description is printed followed by a newline character ('\n').

perror should be called right after the error was produced, otherwise it can be overwritten by calls to other functions.!perror!str
C string containing a custom message to be printed before the error message itself.
If it is a null pointer, no preceding custom message is printed, but the error message is still printed.
By convention, the name of the application itself is generally used as parameter.
!none !clearerr Clear error indicators (function )
ferror Check error indicator (function )!X!
Cplusplus!int printf ( const char * format, ... );
Print formatted data to stdout
Writes the C string pointed by format to the standard output (stdout). If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.!printf!format
C string that contains the text to be written to stdout.
It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested.

A format specifier follows this prototype: [see compatibility note below] 
%[flags][width][.precision][length]specifier 

Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
specifier Output Example
d or i Signed decimal integer 392
u Unsigned decimal integer 7235
o Unsigned octal 610
x Unsigned hexadecimal integer 7fa
X Unsigned hexadecimal integer (uppercase) 7FA
f Decimal floating point, lowercase 392.65
F Decimal floating point, uppercase 392.65
e Scientific notation (mantissa/exponent), lowercase 3.9265e+2
E Scientific notation (mantissa/exponent), uppercase 3.9265E+2
g Use the shortest representation: %e or %f 392.65
G Use the shortest representation: %E or %F 392.65
a Hexadecimal floating point, lowercase -0xc.90fep-2
A Hexadecimal floating point, uppercase -0XC.90FEP-2
c Character a
s String of characters sample
p Pointer address b8000000
n Nothing printed.
The corresponding argument must be a pointer to a signed int.
The number of characters written so far is stored in the pointed location. 
% A % followed by another % character will write a single % to the stream. %

The format specifier can also contain sub-specifiers: flags, width, .precision and modifiers (in that order), which are optional and follow these specifications:

flags description
- Left-justify within the given field width; Right justification is the default (see width sub-specifier).
+ Forces to preceed the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign.
(space) If no sign is going to be written, a blank space is inserted before the value.
# Used with o, x or X specifiers the value is preceeded with 0, 0x or 0X respectively for values different than zero.
Used with a, A, e, E, f, F, g or G it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.
0 Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier).

width description
(number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.
* The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

.precision description
.number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.
For a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).
For g and G specifiers: This is the maximum number of significant digits to be printed.
For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.
If the period is specified without an explicit value for precision, 0 is assumed.
.* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

The length sub-specifier modifies the length of the data type. This is a chart showing the types used to interpret the corresponding arguments with and without length specifier (if a different type is used, the proper type promotion or conversion is performed, if allowed):
specifiers
length d i u o x X f F e E g G a A c s p n
(none) int unsigned int double int char* void* int*
hh signed char unsigned char     signed char*
h short int unsigned short int     short int*
l long int unsigned long int  wint_t wchar_t*  long int*
ll long long int unsigned long long int     long long int*
j intmax_t uintmax_t     intmax_t*
z size_t size_t     size_t*
t ptrdiff_t ptrdiff_t     ptrdiff_t*
L   long double    
Note that the c specifier takes an int (or wint_t) as argument, but performs the proper conversion to a char value (or a wchar_t) before formatting it for output.

Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. See <cinttypes> for the specifiers for extended types.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!puts Write string to stdout (function )
scanf Read formatted data from stdin (function )
fprintf Write formatted data to stream (function )
fwrite Write block of data to stream (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.!
Cplusplus!int putc ( int character, FILE * stream );
Write character to stream
Writes a character to the stream and advances the position indicator.

The character is written at the position indicated by the internal position indicator of the stream, which is then automatically advanced by one.

putc and fputc are equivalent, except that putc may be implemented as a macro in some libraries. See putchar for a similar function that writes directly to stdout.!putc !character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.
Because some libraries may implement this function as a macro, and this may evaluate the stream expression more than once, this should be an expression without side effects.
stream
Pointer to a FILE object that identifies an output stream.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.
!putchar Write character to stdout (function )
fputc Write character to stream (function )
getc Get character from stream (function )
fwrite Write block of data to stream (function )
fprintf Write formatted data to stream (function )!X!
Cplusplus!int putchar ( int character );
Write character to stdout
Writes a character to the standard output (stdout).

It is equivalent to calling putc with stdout as second argument.!putchar!character
The int promotion of the character to be written.
The value is internally converted to an unsigned char when written.!On success, the character written is returned.
If a writing error occurs, EOF is returned and the error indicator (ferror) is set.!putc Write character to stream (function )
fputc Write character to stream (function )
getchar Get character from stdin (function )!X!
Cplusplus!int puts ( const char * str );
Write string to stdout
Writes the C string pointed by str to the standard output (stdout) and appends a newline character ('\n').

The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream.

Notice that puts not only differs from fputs in that it uses stdout as destination, but it also appends a newline character at the end automatically (which fputs does not).!puts!str
C string to be printed.
!On success, a non-negative value is returned.
On error, the function returns EOF and sets the error indicator (ferror).
!fputs Write string to stream (function )
printf Print formatted data to stdout (function )
putchar Write character to stdout (function )
gets Get string from stdin (function )!X!
Cplusplus!int remove ( const char * filename );
Remove file
Deletes the file whose name is specified in filename.

This is an operation performed directly on a file identified by its filename; No streams are involved in the operation.

Proper file access shall be available.!remove!filename
C string containing the name of the file to be deleted.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).!If the file is successfully deleted, a zero value is returned.
On failure, a nonzero value is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!rename Rename file (function )!X!
Cplusplus!int rename ( const char * oldname, const char * newname );
Rename file
Changes the name of the file or directory specified by oldname to newname.

This is an operation performed directly on a file; No streams are involved in the operation.

If oldname and newname specify different paths and this is supported by the system, the file is moved to the new location.

If newname names an existing file, the function may either fail or override the existing file, depending on the specific system and library implementation.

Proper file access shall be available.!rename!oldname
C string containing the name of an existing file to be renamed and/or moved.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).
newname
C string containing the new name for the file.
Its value shall follow the file name specifications of the running environment and can include a path (if supported by the system).!If the file is successfully renamed, a zero value is returned.
On failure, a nonzero value is returned.
On most library implementations, the errno variable is also set to a system-specific error code on failure.!remove Remove file (function )!X!
Cplusplus!void rewind ( FILE * stream );
Set position of stream to the beginning
Sets the position indicator associated with stream to the beginning of the file.

The end-of-file and error internal indicators associated to the stream are cleared after a successful call to this function, and all effects from previous calls to ungetc on this stream are dropped.

On streams open for update (read+write), a call to rewind allows to switch between reading and writing.!rewind !stream
Pointer to a FILE object that identifies the stream.!none!fseek Reposition stream position indicator (function )
fsetpos Set position indicator of stream (function )
fflush Flush stream (function )!X!
Cplusplus!int scanf ( const char * format, ... );
Read formatted data from stdin
Reads data from stdin and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!scanf!format
C string that contains a sequence of characters that control how characters extracted from the stream are treated:
Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
Non-whitespace character, except format specifier (%): Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.
Format specifiers: A sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

A format specifier for scanf follows this prototype:

%[*][width][length]specifier 

Where the specifier character at the end is the most significant component, since it defines which characters are extracted, their interpretation and the type of its corresponding argument:
specifier Description Characters extracted
i, u Integer Any number of digits, optionally preceded by a sign (+ or -).
Decimal digits assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x hexadecimal digits (0-f).
d Decimal integer Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).
o Octal integer Any number of octal digits (0-7), optionally preceded by a sign (+ or -).
x Hexadecimal integer Any number of hexadecimal digits (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).
f, e, g Floating point number A series of decimal digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by strtod).
Implementations complying with C99 also support hexadecimal floating-point format when preceded by 0x or 0X.
a
c Character The next character. If a width other than 1 is specified, the function reads exactly width characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end.
s String of characters Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.
p Pointer address A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.
[characters] Scanset Any number of the characters specified between the brackets.
A dash (-) that is not the first character may produce non-portable behavior in some library implementations.
[^characters] Negated scanset Any number of characters none of them specified as characters between the brackets.
n Count No input is consumed.
The number of characters read so far from stdin is stored in the pointed location.
% % A % followed by another % matches a single %.
Except for n, at least one character shall be consumed by any specifier. Otherwise the match fails, and the scan ends there.

The format specifier can also contain sub-specifiers: asterisk (*), width and length (in that order), which are optional and follow these specifications:
sub-specifier description
* An optional starting asterisk indicates that the data is to be read from the stream but ignored (i.e. it is not stored in the location pointed by an argument).
width Specifies the maximum number of characters to be read in the current reading operation (optional).
length One of hh, h, l, ll, j, z, t, L (optional).
This alters the expected type of the storage pointed by the corresponding argument (see below).

This is a chart showing the types expected for the corresponding arguments where input is stored (both with and without a length sub-specifier):
specifiers
length d i u o x f e g a c s [] [^] p n
(none) int* unsigned int* float* char* void** int*
hh signed char* unsigned char*    signed char*
h short int* unsigned short int*    short int*
l long int* unsigned long int* double* wchar_t*  long int*
ll long long int* unsigned long long int*    long long int*
j intmax_t* uintmax_t*    intmax_t*
z size_t* size_t*    size_t*
t ptrdiff_t* ptrdiff_t*    ptrdiff_t*
L   long double*   
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.
These arguments are expected to be pointers: to store the result of a scanf operation on a regular variable, its name should be preceded by the reference operator (&) (see example).!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.
!fscanf Read formatted data from stream (function )
printf Print formatted data to stdout (function )
gets Get string from stdin (function )
fopen Open file (function )!Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced by C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.!
Cplusplus!void setbuf ( FILE * stream, char * buffer );
Set stream buffer
Specifies the buffer to be used by the stream for I/O operations, which becomes a fully buffered stream. Or, alternatively, if buffer is a null pointer, buffering is disabled for the stream, which becomes an unbuffered stream.

This function should be called once the stream has been associated with an open file, but before any input or output operation is performed with it.

The buffer is assumed to be at least BUFSIZ bytes in size (see setvbuf to specify a size of the buffer).

A stream buffer is a block of data that acts as intermediary between the i/o operations and the physical file associated to the stream: For output buffers, data is output to the buffer until its maximum capacity is reached, then it is flushed (i.e.: all data is sent to the physical file at once and the buffer cleared). Likewise, input buffers are filled from the physical file, from which data is sent to the operations until exhausted, at which point new data is acquired from the file to fill the buffer again.

Stream buffers can be explicitly flushed by calling fflush. They are also automatically flushed by fclose and freopen, or when the program terminates normally.

A full buffered stream uses the entire size of the buffer as buffer whenever enough data is available (see setvbuf for other buffer modes).

All files are opened with a default allocated buffer (fully buffered) if they are known to not refer to an interactive device. This function can be used to either set a specific memory block to be used as buffer or to disable buffering for the stream.

The default streams stdin and stdout are fully buffered by default if they are known to not refer to an interactive device. Otherwise, they may either be line buffered or unbuffered by default, depending on the system and library implementation. The same is true for stderr, which is always either line buffered or unbuffered by default.

A call to this function is equivalent to calling setvbuf with _IOFBF as mode and BUFSIZ as size (when buffer is not a null pointer), or equivalent to calling it with _IONBF as mode (when it is a null pointer).!setbuf!stream
Pointer to a FILE object that identifies an open stream.
buffer
User allocated buffer. Shall be at least BUFSIZ bytes long.
Alternatively, a null pointer can be specified to disable buffering.!none!setvbuf Change stream buffering (function )
fopen Open file (function )
fflush Flush stream (function )!X!
Cplusplus!int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );
Change stream buffering
Specifies a buffer for stream. The function allows to specify the mode and size of the buffer (in bytes).

If buffer is a null pointer, the function automatically allocates a buffer (using size as a hint on the size to use). Otherwise, the array pointed by buffer may be used as a buffer of size bytes.

This function should be called once the stream has been associated with an open file, but before any input or output operation is performed with it.

A stream buffer is a block of data that acts as intermediary between the i/o operations and the physical file associated to the stream: For output buffers, data is output to the buffer until its maximum capacity is reached, then it is flushed (i.e.: all data is sent to the physical file at once and the buffer cleared). Likewise, input buffers are filled from the physical file, from which data is sent to the operations until exhausted, at which point new data is acquired from the file to fill the buffer again.

Stream buffers can be explicitly flushed by calling fflush. They are also automatically flushed by fclose and freopen, or when the program terminates normally.

All files are opened with a default allocated buffer (fully buffered) if they are known to not refer to an interactive device. This function can be used to either redefine the buffer size or mode, to define a user-allocated buffer or to disable buffering for the stream.

The default streams stdin and stdout are fully buffered by default if they are known to not refer to an interactive device. Otherwise, they may either be line buffered or unbuffered by default, depending on the system and library implementation. The same is true for stderr, which is always either line buffered or unbuffered by default.!setvbuf!stream
Pointer to a FILE object that identifies an open stream.
buffer
User allocated buffer. Shall be at least size bytes long.
If set to a null pointer, the function automatically allocates a buffer.
mode
Specifies a mode for file buffering. Three special macro constants (_IOFBF, _IOLBF and _IONBF) are defined in <cstdio> to be used as the value for this parameter:
_IOFBF Full buffering: On output, data is written once the buffer is full (or flushed). On Input, the buffer is filled when an input operation is requested and the buffer is empty.
_IOLBF Line buffering: On output, data is written when a newline character is inserted into the stream or when the buffer is full (or flushed), whatever happens first. On Input, the buffer is filled up to the next newline character when an input operation is requested and the buffer is empty.
_IONBF No buffering: No buffer is used. Each I/O operation is written as soon as possible. In this case, the buffer and size parameters are ignored.
size
Buffer size, in bytes.
If the buffer argument is a null pointer, this value may determine the size automatically allocated by the function for the buffer.!If the buffer is correctly assigned to the file, a zero value is returned.
Otherwise, a non-zero value is returned; This may be due to an invalid mode parameter or to some other error allocating or assigning the buffer.!setbuf Set stream buffer (function )
fopen Open file (function )
fflush Flush stream (function )!X!
Cplusplus!int snprintf ( char * s, size_t n, const char * format, ... );
Write formatted output to sized buffer
Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by s (taking n as the maximum buffer capacity to fill).

If the resulting string would be longer than n-1 characters, the remaining characters are discarded and not stored, but counted for the value returned by the function.

A terminating null character is automatically appended after the content written.

After the format parameter, the function expects at least as many additional arguments as needed for format.!snprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should have a size of at least n characters.
n
Maximum number of bytes to be used in the buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null character.
size_t is an unsigned integral type.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!The number of characters that would have been written if n had been sufficiently large, not counting the terminating null character.
If an encoding error occurs, a negative number is returned.
Notice that only when this returned value is non-negative and less than n, the string has been completely written.
!printf Print formatted data to stdout (function )
sprintf Write formatted data to string (function )
strcat Concatenate strings (function )
sscanf Read formatted data from string (function )!X!
Cplusplus!int sprintf ( char * str, const char * format, ... );
Write formatted data to string
Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by str.

The size of the buffer should be large enough to contain the entire resulting string (see snprintf for a safer version).

A terminating null character is automatically appended after the content.

After the format parameter, the function expects at least as many additional arguments as needed for format.!sprintf!str
Pointer to a buffer where the resulting C-string is stored.
The buffer should be large enough to contain the resulting string.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned. This count does not include the additional null-character automatically appended at the end of the string.
On failure, a negative number is returned.!snprintf Write formatted output to sized buffer (function )
printf Print formatted data to stdout (function )
sscanf Read formatted data from string (function )!X!
Cplusplus!int sscanf ( const char * s, const char * format, ...);
Read formatted data from string
Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin).

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.!sscanf!s
C string that the function processes as its source to retrieve the data.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.!scanf Read formatted data from stdin (function )
sprintf Write formatted data to string (function )!X!
Cplusplus!FILE * tmpfile ( void );
Open a temporary file
Creates a temporary binary file, open for update ("wb+" mode, see fopen for details) with a filename guaranteed to be different from any other existing file.

The temporary file created is automatically deleted when the stream is closed (fclose) or when the program terminates normally. If the program terminates abnormally, whether the file is deleted depends on the specific system and library implementation.!tmpfile!none!If successful, the function returns a stream pointer to the temporary file created.
On failure, NULL is returned.!fopen Open file (function )
tmpnam Generate temporary filename (function )!X!
Cplusplus!char * tmpnam ( char * str );
Generate temporary filename
Returns a string containing a file name different from the name of any existing file, and thus suitable to safely create a temporary file without risking to overwrite an existing file.

If str is a null pointer, the resulting string is stored in an internal static array that can be accessed by the return value. The content of this string is preserved at least until a subsequent call to this same function, which may overwrite it.

If str is not a null pointer, it shall point to an array of at least L_tmpnam characters that will be filled with the proposed temporary file name.

The file name returned by this function can be used to create a regular file using fopen to be used as a temporary file. The file created this way, unlike those created with tmpfile is not automatically deleted when closed; A program shall call remove to delete this file once closed.!tmpnam!str
Pointer to an array of characters where the proposed temporary name will be stored as a C string. The suggested size of this array is at least L_tmpnam characters.
Alternativelly, a null pointer can be specified to use an internal static array to store the proposed temporary name, whose pointer is returned by the function.!On success, a pointer to the C string containing the proposed name for a temporary file:
If str was a null pointer, this points to an internal buffer (whose content is preserved at least until the next call to this function).
If str was not a null pointer, str is returned.
If the function fails to create a suitable filename, it returns a null pointer.!fopen Open file (function )
tmpfile Open a temporary file (function )!X!
Cplusplus!int ungetc ( int character, FILE * stream );
Unget character from stream
A character is virtually put back into an input stream, decreasing its internal file position as if a previous getc operation was undone.

This character may or may not be the one read from the stream in the preceding input operation. In any case, the next character retrieved from stream is the character passed to this function, independently of the original one.

Notice though, that this only affects further input operations on that stream, and not the content of the physical file associated with it, which is not modified by any calls to this function.

Some library implementations may support this function to be called multiple times, making the characters available in the reverse order in which they were put back. Although this behavior has no standard portability guarantees, and further calls may simply fail after any number of calls beyond the first.

If successful, the function clears the end-of-file indicator of stream (if it was currently set), and decrements its internal file position indicator if it operates in binary mode; In text mode, the position indicator has unspecified value until all characters put back with ungetc have been read or discarded.

A call to fseek, fsetpos or rewind on stream will discard any characters previously put back into it with this function.

If the argument passed for the character parameter is EOF, the operation fails and the input stream remains unchanged.
!ungetc!character
The int promotion of the character to be put back.
The value is internally converted to an unsigned char when put back.
stream
Pointer to a FILE object that identifies an input stream.!On success, the character put back is returned.
If the operation fails, EOF is returned.!getc Get character from stream (function )
fgetc Get character from stream (function )
putc Write character to stream (function )!X!
Cplusplus!int vfprintf ( FILE * stream, const char * format, va_list arg );
Write formatted data from variable argument list to stream
Writes the C string pointed by format to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vfprintf!stream
Pointer to a FILE object that identifies an output stream.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!vprintf Print formatted data from variable argument list to stdout (function )
vsprintf Write formatted data from variable argument list to string (function )
fprintf Write formatted data to stream (function )
printf Print formatted data to stdout (function )!X!
Cplusplus!int vfscanf ( FILE * stream, const char * format, va_list arg );
Read formatted data from stream into variable argument list
Reads data from the stream and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vfscanf!stream
Pointer to a FILE object that identifies an input stream.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!vscanf Read formatted data into variable argument list (function )
vsscanf Read formatted data from string into variable argument list (function )
fscanf Read formatted data from stream (function )
scanf Read formatted data from stdin (function )!X!
Cplusplus!int vprintf ( const char * format, va_list arg );
Print formatted data from variable argument list to stdout
Writes the C string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.
!vprintf!format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!vfprintf Write formatted data from variable argument list to stream (function )
vsprintf Write formatted data from variable argument list to string (function )
printf Print formatted data to stdout (function )!X!
Cplusplus!int vscanf ( const char * format, va_list arg );
Read formatted data into variable argument list
Reads data from the standard input (stdin) and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vscanf!format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.
!vfscanf Read formatted data from stream into variable argument list (function )
vsscanf Read formatted data from string into variable argument list (function )
fscanf Read formatted data from stream (function )
scanf Read formatted data from stdin (function )!X!
Cplusplus!int vsnprintf (char * s, size_t n, const char * format, va_list arg );
Write formatted data from variable argument list to sized buffer
Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by s (taking n as the maximum buffer capacity to fill).

If the resulting string would be longer than n-1 characters, the remaining characters are discarded and not stored, but counted for the value returned by the function.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsnprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should have a size of at least n characters.
n
Maximum number of bytes to be used in the buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null character.
size_t is an unsigned integral type.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!The number of characters that would have been written if n had been sufficiently large, not counting the terminating null character.
If an encoding error occurs, a negative number is returned.
Notice that only when this returned value is non-negative and less than n, the string has been completely written.!vfprintf Write formatted data from variable argument list to stream (function )
vprintf Print formatted data from variable argument list to stdout (function )
sprintf Write formatted data to string (function )
printf Print formatted data to stdout (function )!X!
Cplusplus!int vsprintf (char * s, const char * format, va_list arg );
Write formatted data from variable argument list to string
Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by s.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsprintf!s
Pointer to a buffer where the resulting C-string is stored.
The buffer should be large enough to contain the resulting string.
format
C string that contains a format string that follows the same specifications as format in printf (see printf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.
!On success, the total number of characters written is returned.
On failure, a negative number is returned.!vfprintf Write formatted data from variable argument list to stream (function )
vprintf Print formatted data from variable argument list to stdout (function )
sprintf Write formatted data to string (function )
printf Print formatted data to stdout (function )!X!
Cplusplus!int vsscanf ( const char * s, const char * format, va_list arg );
Read formatted data from string into variable argument list
Reads data from s and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.!vsscanf!s
C string that the function processes as its source to retrieve the data.
format
C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less -even zero- in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.!vscanf Read formatted data into variable argument list (function )
vfscanf Read formatted data from stream into variable argument list (function )
sscanf Read formatted data from string (function )
scanf Read formatted data from stdin (function )
vsprintf Write formatted data from variable argument list to string (function )!X!
Cplusplus!FILE * stderr;
Standard error stream
The standard error stream is the default destination for error messages and other diagnostic warnings. Like stdout, it is usually also directed by default to the text console (generally, on the screen).

stderr can be used as an argument for any function that takes an argument of type FILE* expecting an output stream, like fputs or fprintf.

Although in many cases both stdout and stderr are associated with the same output device (like the console), applications may differentiate between what is sent to stdout and what to stderr for the case that one of them is redirected. For example, it is frequent to redirect the regular output of a console program (stdout) to a file while expecting the error messages to keep appearing in the console.

It is also possible to redirect stderr to some other destination from within a program using the freopen function.

stderr is is never fully buffered on startup. It is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stderr!X!X!stdin Standard input stream (object )
stdout Standard output stream (object )!X!
Cplusplus!FILE * stdin;
Standard input stream
The standard input stream is the default source of data for applications. In most systems, it is usually directed by default to the keyboard.

stdin can be used as an argument for any function that expects an input stream (FILE*) as one of its parameters, like fgets or fscanf.

Although it is commonly assumed that the source of data for stdin is going to be a keyboard, this may not be the case even in regular console systems, since stdin can generally be redirected on most operating systems at the time of invoking the application. For example, many systems, among them DOS/Windows and most UNIX shells, support the following command syntax:

myapplication < example.txt 

to use the content of the file example.txt as the primary source of data for myapplication instead of the console keyboard.

It is also possible to redirect stdin to some other source of data from within a program by using the freopen function.

If stdin is known to not refer to an interactive device, the stream is fully buffered. Otherwise, it is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stdin!X!X!stdout Standard output stream (object )
stderr Standard error stream (object )!X!
Cplusplus!FILE * stdout;
Standard output stream
The standard output stream is the default destination of output for applications. In most systems, it is usually directed by default to the text console (generally, on the screen).

stdout can be used as an argument for any function that takes an argument of type FILE* expecting an output stream, like fputs or fprintf.

Although it is commonly assumed that the default destination for stdout is going to be the screen, this may not be the case even in regular console systems, since stdout can generally be redirected on most operating systems at the time of invoking the application. For example, many systems, among them DOS/Windows and most UNIX shells, support the following command syntax:

myapplication > example.txt 
to redirect the output of myapplication to the file example.txt instead of the console.

It is also possible to redirect stdout to some other source of data from within a program using the freopen function.

If stdout is known to not refer to an interactive device, the stream is fully buffered. Otherwise, it is library-dependent whether the stream is line buffered or not buffered by default (see setvbuf).!stdout!X!X!stdin Standard input stream (object )
stderr Standard error stream (object )!X!
Cplusplus!Object containing information to control a stream
Object type that identifies a stream and contains the information needed to control it, including a pointer to its buffer, its position indicator and all its state indicators.

FILE objects are usually created by a call to either fopen or tmpfile, which both return a pointer to one of these objects.

The content of a FILE object is not meant to be accessed from outside the functions of the <cstdio> and <cwchar> headers; In fact, portable programs shall only use them in the form of pointers to identify streams, since for some implementations, even the value of the pointer itself could be significant to identify the stream (i.e., the pointer to a copy of a FILE object could be interpreted differently than a pointer to the original).

Its memory allocation is automatically managed: it is allocated by either fopen or tmpfile, and it is the responsibility of the library to free the resources once either the stream has been closed using fclose or the program terminates normally.

On inclusion of the <cstdio> header file, three objects of this type are automatically created, and pointers to them are declared: stdin, stdout and stderr, associated with the standard input stream, standard output stream and standard error stream, respectively.!FILE!X!X!fopen Open file (function )
fclose Close file (function )!X!
Cplusplus!Object containing information to specify a position within a file
This type of object is used to specify a position within a file. An object of this type is capable of specifying uniquely any position within a file.

The information in fpos_t objects is usually filled by a call to fgetpos, which takes a pointer to an object of this type as argument.

The content of an fpos_t object is not meant to be read directly, but only to be used as an argument in a call to fsetpos.!fpos_t!X!X!X!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.

In <cstdio>, it is used as the type of some parameters in the functions fread, fwrite and setvbuf, and in the case of fread and fwrite also as its returning type.!size_t!X!X!X!X!
Cplusplus!Buffer size
This macro constant expands to an integral expression with the size of the buffer used by the setbuf function.!BUFSIZ!X!X!setbuf Set stream buffer (function )!X!
Cplusplus!End-of-File
It is a macro definition of type int that expands into a negative integral constant expression (generally, -1).

It is used as the value returned by several functions in header <cstdio> to indicate that the End-of-File has been reached or to signal some other failure conditions.

It is also used as the value to represent an invalid character.

In C++, this macro corresponds to the value of char_traits<char>::eof().
!EOF!X!X!feof Check end-of-file indicator (function )
ferror Check error indicator (function )!X!
Cplusplus!Maximum length of file names
This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string allowed by the library. Or, if the library imposes no such restriction, it is set to the recommended size for character arrays intended to hold a file name.
!FILENAME_MAX!X!X!L_tmpnam Minimum length for temporary file name (constant )
FOPEN_MAX Potential limit of simultaneous open streams (constant )
TMP_MAX Number of temporary files (constant )!X!
Cplusplus!Potential limit of simultaneous open streams
This macro constant expands to an integral expression representing the minimum number of files that can be open simultaneously.

Particular library implementations may count files opened by tmpfile towards this limit.

FOPEN_MAX is a value greater than 7.!FOPEN_MAX!X!X!TMP_MAX Number of temporary files (constant )!X!
Cplusplus!Minimum length for temporary file name
This macro constant expands to an integral expression corresponding to the size needed for an array of char elements to hold the longest file name string possibly generated by tmpnam.
!L_tmpnam!X!X!FILENAME_MAX Maximum length of file names (constant )
FOPEN_MAX Potential limit of simultaneous open streams (constant )
TMP_MAX Number of temporary files (constant )!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.!NULL!X!X!X!X!
Cplusplus!Number of temporary files
This macro expands to the minimum number of unique temporary file names that are guaranteed to be possible to generate using tmpnam.

This value cannot be lower than 25.

Particular library implementations may count file names used by files created with tmpfile towards this limit.!TMP_MAX!X!X!FOPEN_MAX Potential limit of simultaneous open streams (constant )!X!
Cplusplus!void assert (int expression);
Evaluate assertion
If the argument expression of this macro with functional form compares equal to zero (i.e., the expression is false), a message is written to the standard error device and abort is called, terminating the program execution.

The specifics of the message shown depend on the particular library implementation, but it shall at least include: the expression whose assertion failed, the name of the source file, and the line number where it happened. A usual expression format is:

Assertion failed: expression, file filename, line line number 

This macro is disabled if, at the moment of including <assert.h>, a macro with the name NDEBUG has already been defined. This allows for a coder to include as many assert calls as needed in a source code while debugging the program and then disable all of them for the production version by simply including a line like:
 
#define NDEBUG 

at the beginning of its code, before the inclusion of <assert.h>.

Therefore, this macro is designed to capture programming errors, not user or run-time errors, since it is generally disabled after a program exits its debugging phase.
!assert!expression
Expression to be evaluated. If this expression evaluates to 0, this causes an assertion failure that terminates the program.!none!X!X!
Cplusplus!int isalnum ( int c );
Check if character is alphanumeric
Checks whether c is either a decimal digit or an uppercase or lowercase letter.

The result is true if either isalpha or isdigit would also return true.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, what constitutes a letter is what returns true by either isupper or islower.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isalnum) exists in header <locale>.!isalnum!c
Character to be checked, casted as an int, or EOF.!A value different from zero (i.e., true) if indeed c is either a digit or a letter. Zero (i.e., false) otherwise.
!isalpha Check if character is alphabetic (function )
isdigit Check if character is decimal digit (function )!X!
Cplusplus!int isalpha ( int c );
Check if character is alphabetic
Checks whether c is an alphabetic letter.

Notice that what is considered a letter depends on the locale being used; In the default "C" locale, what constitutes a letter is only what returns true by either isupper or islower.

Using other locales, an alphabetic character is a character for which isupper or islower would return true, or another character explicitly considered alphabetic by the locale (in this case, the character cannot be iscntrl, isdigit, ispunct or isspace).

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isalpha) exists in header <locale>.!isalpha!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is an alphabetic letter. Zero (i.e., false) otherwise.!isalnum Check if character is alphanumeric (function )
isdigit Check if character is decimal digit (function )!X!
Cplusplus!int isblank ( int c );
Check if character is blank
Checks whether c is a blank character.

A blank character is a space character used to separate words within a line of text.

The standard "C" locale considers blank characters the tab character ('\t') and the space character (' ').

Other locales may consider blank a different selection of characters, but they must all also be space characters by isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isblank) exists in header <locale>.

Compatibility note: Standardized in C99 (C++11).!isblank!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a blank character. Zero (i.e., false) otherwise.!isspace Check if character is a white-space (function )
isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )
isalnum Check if character is alphanumeric (function )
isblank (locale) Check if character is blank using locale (function template )!X!
Cplusplus!int iscntrl ( int c );
Check if character is a control character
Checks whether c is a control character.

A control character is a character that does not occupy a printing position on a display (this is the opposite of a printable character, checked with isprint).

For the standard ASCII character set (used by the "C" locale), control characters are those between ASCII codes 0x00 (NUL) and 0x1f (US), plus 0x7f (DEL).

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (iscntrl) exists in header <locale>.!iscntrl!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a control character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )!X!
Cplusplus!int isdigit ( int c );
Check if character is decimal digit
Checks whether c is a decimal digit character.

Decimal digits are any of: 0 1 2 3 4 5 6 7 8 9 

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isdigit) exists in header <locale>.!isdigit!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a decimal digit. Zero (i.e., false) otherwise.!isalnum Check if character is alphanumeric (function )
isalpha Check if character is alphabetic (function )!X!
Cplusplus!int isgraph ( int c );
Check if character has graphical representation
Checks whether c is a character with graphical representation.

The characters with graphical representation are all those characters than can be printed (as determined by isprint) except the space character (' ').

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isgraph) exists in header <locale>.!isgraph!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c has a graphical representation as character. Zero (i.e., false) otherwise.!isprint Check if character is printable (function )
isspace Check if character is a white-space (function )
isalnum Check if character is alphanumeric (function )!X!
Cplusplus!int islower ( int c );
Check if character is lowercase letter
Checks whether c is a lowercase letter.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, a lowercase letter is any of: a b c d e f g h i j k l m n o p q r s t u v w x y z.

Other locales may consider a different selection of characters as lowercase characters, but never characters that returns true for iscntrl, isdigit, ispunct or isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (islower) exists in header <locale>.!islower!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a lowercase alphabetic letter. Zero (i.e., false) otherwise.!isupper Check if character is uppercase letter (function )
isalpha Check if character is alphabetic (function )
toupper Convert lowercase letter to uppercase (function )
tolower Convert uppercase letter to lowercase (function )!X!
Cplusplus!int isprint ( int c );
Check if character is printable
Checks whether c is a printable character.

A printable character is a character that occupies a printing position on a display (this is the opposite of a control character, checked with iscntrl).

For the standard ASCII character set (used by the "C" locale), printing characters are all with an ASCII code greater than 0x1f (US), except 0x7f (DEL).

isgraph returns true for the same cases as isprint except for the space character (' '), which returns true when checked with isprint but false when checked with isgraph.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isprint) exists in header <locale>.
!isprint!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a printable character. Zero (i.e., false) otherwise.!iscntrl Check if character is a control character (function )
isspace Check if character is a white-space (function )
isalnum Check if character is alphanumeric (function )!X!
Cplusplus!int ispunct ( int c );
Check if character is a punctuation character
Checks whether c is a punctuation character.

The standard "C" locale considers punctuation characters all graphic characters (as in isgraph) that are not alphanumeric (as in isalnum).

Other locales may consider a different selection of characters as punctuation characters, but in any case they are isgraph but not isalnum.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (ispunct) exists in header <locale>.
!ispunct!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a punctuation character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
iscntrl Check if character is a control character (function )!X!
Cplusplus!int isspace ( int c );
Check if character is a white-space
Checks whether c is a white-space character.

For the "C" locale, white-space characters are any of:
' ' (0x20) space (SPC)
'\t' (0x09) horizontal tab (TAB)
'\n' (0x0a) newline (LF)
'\v' (0x0b) vertical tab (VT)
'\f' (0x0c) feed (FF)
'\r' (0x0d) carriage return (CR)

Other locales may consider a different selection of characters as white-spaces, but never a character that returns true for isalnum.

For a detailed chart on what the different ctype functions return for each character of the standard ASCII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isspace) exists in header <locale>.!isspace!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a white-space character. Zero (i.e., false) otherwise.!isgraph Check if character has graphical representation (function )
ispunct Check if character is a punctuation character (function )
isalnum Check if character is alphanumeric (function )
isspace (locale) Check if character is a white-space using locale (function template )!X!
Cplusplus!int isupper ( int c );
Check if character is uppercase letter
Checks if parameter c is an uppercase alphabetic letter.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, an uppercase letter is any of: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

Other locales may consider a different selection of characters as uppercase characters, but never characters that returns true for iscntrl, isdigit, ispunct or isspace.

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isupper) exists in header <locale>.
!isupper!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is an uppercase alphabetic letter. Zero (i.e., false) otherwise.!islower Check if character is lowercase letter (function )
isalpha Check if character is alphabetic (function )
toupper Convert lowercase letter to uppercase (function )
tolower Convert uppercase letter to lowercase (function )!X!
Cplusplus!int isxdigit ( int c );
Check if character is hexadecimal digit
Checks whether c is a hexdecimal digit character.

Hexadecimal digits are any of: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 

For a detailed chart on what the different ctype functions return for each character of the standard ANSII character set, see the reference for the <cctype> header.

In C++, a locale-specific template version of this function (isxdigit) exists in header <locale>.!isxdigit!c
Character to be checked, casted to an int, or EOF.!A value different from zero (i.e., true) if indeed c is a hexadecimal digit. Zero (i.e., false) otherwise.!isdigit Check if character is decimal digit (function )
isalnum Check if character is alphanumeric (function )
isalpha Check if character is alphabetic (function )!X!
Cplusplus!int tolower ( int c );
Convert uppercase letter to lowercase
Converts c to its lowercase equivalent if c is an uppercase letter and has a lowercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, an uppercase letter is any of: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z, which translate respectively to: a b c d e f g h i j k l m n o p q r s t u v w x y z.

In other locales, if an uppercase character has more than one correspondent lowercase character, this function always returns the same character for the same value of c.

In C++, a locale-specific template version of this function (tolower) exists in header <locale>.!tolower!c
Character to be converted, casted to an int, or EOF.
!The lowercase equivalent to c, if such value exists, or c (unchanged) otherwise.
The value is returned as an int value that can be implicitly casted to char.!toupper Convert lowercase letter to uppercase (function )
isupper Check if character is uppercase letter (function )
islower Check if character is lowercase letter (function )
isalpha Check if character is alphabetic (function )!X!
Cplusplus!int toupper ( int c );
Convert lowercase letter to uppercase
Converts c to its uppercase equivalent if c is a lowercase letter and has an uppercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used; In the default "C" locale, a lowercase letter is any of: a b c d e f g h i j k l m n o p q r s t u v w x y z, which translate respectively to: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

In other locales, if a lowercase character has more than one correspondent uppercase character, this function always returns the same character for the same value of c.

In C++, a locale-specific template version of this function (toupper) exists in header <locale>.!toupper!c
Character to be converted, casted to an int, or EOF.!The uppercase equivalent to c, if such value exists, or c (unchanged) otherwise. The value is returned as an int value that can be implicitly casted to char.!tolower Convert uppercase letter to lowercase (function )
islower Check if character is lowercase letter (function )
isupper Check if character is uppercase letter (function )
isalpha Check if character is alphabetic (function )!X!
Cplusplus!int
Last error number
This macro expands to a modifiable lvalue of type int. Therefore, it can be both read and modified by a program.

errno is set to zero at program startup, and any function of the standard C library can modify its value to some value different from zero, generally to signal specific categories of error (no library function sets its value back to zero once changed).

A program can also modify its value. In fact, if this variable is intended to be used for error checking after a library function call, it should be reset by the program to zero before the call (since any previous call to a library function may have altered its value).

The same header that declares errno (<cerrno>) also declares at least the following macro constants with values different from zero:

macro meaning when errno is set to this
EDOM Domain error: Some mathematical functions are only defined for certain real values, which is called its domain, for example the square root function is only defined for non-negative numbers, therefore the sqrt function sets errno to EDOM if called with a negative argument.
ERANGE Range error: The range of values that can be represented with a variable is limited. For example, mathematical functions such as pow can easily outbound the range representable by a floating point variable, or functions such as strtod can encounter sequences of digits longer than the range representable by an int value. In these cases, errno is set to ERANGE.
EILSEQ Illegal sequence: Multibyte character sequence may have a restricted set of valid sequences. When a set of multibyte characters is translated by functions such as mbrtowc, errno is set to EILSEQ when an invalid sequence is encountered.

The functions of the standard library may set errno to any value (not only to the portable values listed above). Particular library implementations may define additional names in this header.

C++11 expands the basic set of values required to be defined in this header by including many names also available in POSIX environments, increasing the total number of portable errno values to 78. For a full list, see errc.

The particular error messages associated with values of errno can be obtained using strerror or directly printed using function perror.

In C++, errno is always declared as a macro, but in C it may also be implemented as an int object with external linkage.!errno!X!X!X!X!
Cplusplus!int feclearexcept (int excepts);
Clear floating-point exceptions
Attempts to clear the floating-point exceptions specified by excepts.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.
!feclearexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if all exceptions in excepts were successfully cleared (or if excepts was zero).
A non-zero value otherwise.!feraiseexcept Raise floating-point exception (function )
fetestexcept Test for floating-point exceptions (function )!X!
Cplusplus!int fegetenv (fenv_t* envp);
Get floating-point environment
Attempts to store the current state of the floating-point environment in the object pointed by envp.

The floating point environment is a set of status flags and control modes affecting floating-point calculations (including both floating-point exceptions and the rounding direction mode).

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fegetenv!envp
Pointer to a fenv_t object where the state of the floating-point environment is stored.!Zero, if the state was successfully stored.
A non-zero value otherwise.!feholdexcept Hold floating-point exceptions (function )
fesetenv Set floating-point environment (function )!X!
Cplusplus!int fegetexceptflag (fexcept_t* flagp, int excepts);
Get floating-point exception flags
Attempts to store a representation of the floating-point exceptions specified by excepts into the fexcept_t object pointed by flagp.!fegetexceptflag!flagp
Pointer to a fexcept_t object where the representation is stored.
excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if the representation was successfully stored.
A non-zero value otherwise.!fesetexceptflag Set floating-point exception flags (function )
feholdexcept Hold floating-point exceptions (function )!X!
Cplusplus!int fegetround (void);
Get rounding direction mode
Returns a value that indicates the rounding direction mode, as specified in the current floating point environment.

Whether the value returned by this function is the same as FLT_ROUNDS in <cfloat> is unspecified.!fegetround!none!If the current rounding mode was successfully determined by the function and is supported by the implementation, the function returns a value for which a corresponding macro is defined:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
Certain library implementations may support additional floating-point rounding directions values (with their corresponding macros also beginning with FE_).!fesetround Set rounding direction mode (function )
fegetenv Get floating-point environment (function )
rint Round to integral value (function )!X!
Cplusplus!int feholdexcept (fenv_t* envp);
Hold floating-point exceptions
Saves the current state of the floating-point environment in the object pointed by envp. It then resets the current state and -if supported- puts the environment in non-stop mode.

The non-stop mode prevents floating-point exceptions from stopping the normal flow of the program when raised (with traps or abortions).

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feholdexcept!envp
Pointer to a fenv_t object where the state of the floating-point environment is stored.!Zero, if the function completed successfully, including setting the floating point environment to non-stop mode.
A non-zero value otherwise.!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )
feclearexcept Clear floating-point exceptions (function )!X!
Cplusplus!int feraiseexcept (int excepts);
Raise floating-point exception
Attempts to raise the floating-point exceptions specified by excepts.

If more than one exception is specified, the order in which they are raised is unspecified.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feraiseexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if all exceptions in excepts were successfully raised (or if excepts was zero).
A non-zero value otherwise.!feclearexcept Clear floating-point exceptions (function )
fetestexcept Test for floating-point exceptions (function )!X!
Cplusplus!int fesetenv (const fenv_t* envp);
Set floating-point environment
Attempts to establish the state of the floating-point environment as represented by the object pointed by envp.

The floating point environment is a set of status flags and control modes affecting floating-point calculations (including both floating-point exceptions and the rounding direction mode).

If successful, the function changes the current state of the floating-point environment without actually raising the exceptions specified in such state.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetenv!envp
Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values:
value description
FE_DFL_ENV Default floating-point environment (the same as at program startup).
Certain library implementations may support additional floating-point environment state values (with their corresponding macros also beginning with FE_).!Zero, if the state was successfully established.
A non-zero value otherwise.!feupdateenv Update floating-point environment (function )
fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X!
Cplusplus!int fesetexceptflag (const fexcept_t* flagp, int excepts);
Set floating-point exception flags
Attempts to set the exceptions indicated by excepts with the states stored in the object pointed by flagp.

If successful, the function changes the current state of the floating-point environment, setting the requested exception flags, but without actually raising the exceptions.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetexceptflag!flagp
Pointer to a fexcept_t object with a representation of floating-point exceptions.
The value pointed by flagp shall have been previously set by a call to fegetexceptflag with at least the exceptions specified by excepts.
excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!Zero, if the function successfully set the flags in the (or if excepts was zero).
A non-zero value otherwise.!fegetexceptflag Get floating-point exception flags (function )
feraiseexcept Raise floating-point exception (function )!X!
Cplusplus!int fesetround (int rdir);
Set rounding direction mode
Sets rdir as the current rounding direction mode for the floating point environment.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fesetround!rdir
One of the values defined as rounding direction mode:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
Certain library implementations may support additional floating-point rounding directions values (with their corresponding macros also beginning with FE_).!Zero, if the requested rounding direction was successfully set.
Otherwise, a non-zero value.!fegetround Get rounding direction mode (function )
fesetenv Set floating-point environment (function )
rint Round to integral value (function )!X!
Cplusplus!int fetestexcept (int excepts);
Test for floating-point exceptions
Returns the exceptions currently set, among those specified by excepts.

The value returned is the bitwise OR representation of the subset of excepts that are currently set in the floating point environment. Or zero, if none of the exceptions in excepts are currently set.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!fetestexcept!excepts
Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).
C99C++11
Libraries may define in <fenv.h> only the macro values above they support (the others may not be defined).
!Zero, if none of the exceptions in excepts are set.
Otherwise, the exceptions (among those of excepts) currently set.!feraiseexcept Raise floating-point exception (function )
feclearexcept Clear floating-point exceptions (function )
feholdexcept Hold floating-point exceptions (function )!X!
Cplusplus!int feupdateenv (const fenv_t* envp);
Update floating-point environment
Attempts to establish the state of the floating-point environment as represented by the object pointed by envp. It then attempts to raise the exceptions that were set in the floating-point environment before the call.

Programs calling this function shall ensure that pragma FENV_ACCESS is enabled for the call.!feupdateenv!envp
Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values:
value description
FE_DFL_ENV Default floating-point environment (the same as at program startup).
Certain library implementations may support additional floating-point environment state values (with their corresponding macros also beginning with FE_).!Zero, if successful.
A non-zero value otherwise.!feupdateenv Update floating-point environment (function )
fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X!
Cplusplus!Floating-point environment type
Type that can represent the entire state of the floating-point environment, including its status flags (such as the active floating-point exceptions) and control modes (such as the rounding direction mode).

Specifics about this type depend on the library implementation: Its value shall be set by calling either fegetenv or feholdexcept, and can be applied by calling fesetenv or feupdateenv.!fenv_t!X!X!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )
fexcept_t Floating-point exceptions type (type )!X!
Cplusplus!Floating-point exceptions type
Type that can represent the state of all floating-point status flags collectively, including the active floating-point exceptions along with any additional information the implementation associates with their status.

Specifics about this type depend on the library implementation: Its value shall be set by calling fegetexceptflag, and can be applied by calling fesetexceptflag.!fexcept_t!X!X!fegetexceptflag Get floating-point exception flags (function )
fesetexceptflag Set floating-point exception flags (function )
fenv_t Floating-point environment type (type )!X!
Cplusplus!on (1)  #pragma STDC FENV_ACCESS on
off (2)  #pragma STDC FENV_ACCESS off
Access to Floating-point environment
If set to on, the program informs the compiler that it might access the floating-point environment to test its status flags (exceptions) or run under control modes other than the one by default.

If set to off, the compiler may perform certain optimizations that can subvert these tests and mode changes, and thus accessing the floating-point environment in the cases described above, causes undefined behavior.

Whether the state of this pragma by default is on or off depends on the compiler settings and library implementation.

The pragma declaration shall occur either:
outside any external declaration: Its effects last until another FENV_ACCESS pragma is encountered, or until the end of the translation unit.
inside a compound statement: In this case it shall precede all explicit declarations and statements. Its effects last until another FENV_ACCESS pragma is encountered (such as in a nested compound statement), or until the end of the compound statement. After the compound statement, the state of the pragma is restored to the condition it had before entering it.
If this pragma appears in other contexts, the behavior is undefined.

When the state is changed by this pragma directive, the floating-point control modes (such as rounding direction) have their default settings, but the state of the floating point status flags is unspecified.
!FENV_ACCESS!X!X!fegetenv Get floating-point environment (function )
fesetenv Set floating-point environment (function )!X!
Cplusplus!int
All exceptions
This macro expands to a value of type int that combines the value of all the possible floating-point exceptions defined in <cfenv> (with bitwise OR).

If no floating-point exceptions are supported by the implementation, this macro is defined as 0 (zero).

It can be used on functions that expect a bitmask of possible floating point exceptions as one of its arguments: feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, or fetestexcept.!FE_ALL_EXCEPT!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
feraiseexcept Raise floating-point exception (function )!X!
Cplusplus!fenv_t*
Default environment
This macro expands to a pointer to fenv_t that can be used to select the default environment for functions fesetenv and feupdateenv.

The default environment is the state of the floating-point environment on program startup.!FE_DFL_ENV!X!X!fesetenv Set floating-point environment (function )
feupdateenv Update floating-point environment (function )
fenv_t Floating-point environment type (type )!X!
Cplusplus!int
Pole error exception
This macro expands to a value of type int that identifies the floating-point exception raised on pole errors.

Pole errors occur when an operation has a result that is asymptotically infinite, such as divisions by zero, or log(0.0).

It is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).
!FE_DIVBYZERO!X!X!FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X!
Cplusplus!int
Downward rounding direction mode
This macro expands to a value of type int that identifies the downward rounding direction mode for functions fegetround and fesetround.

Rounding x downward selects the largest possible value that is not greater than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_DOWNWARD!X!X!FE_TONEAREST To-nearest rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X!
Cplusplus!int
Inexact result exception
This macro expands to a value of type int that identifies the floating-point exception raised on inexact results.

Inexact exceptions are raised to signal when the return type of an operation cannot represent the result with exact accuracy (such as 1.0/3.0 or sqrt(2.0) on most implementations), or when a function cannot produce an exact result for some other reason.

It is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_INEXACT!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X!
Cplusplus!int
Invalid argument exception
This macro expands to a value of type int that identifies the floating-point exception raised on invalid arguments.

Invalid argument exceptions are raised to signal that the argument passed to a function is out of its domain (i.e., the function is not defined for that value), such as sqrt(-1.0).

The value returned by a function that raises this exception is unspecified.

FE_INVALID is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_INVALID!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X!
Cplusplus!int
Overflow range error exception
This macro expands to a value of type int that identifies the floating-point exception raised on overflow range errors.

Overflow range errors occur when the result of an operation cannot be represented as a value of its return type because its magnitude is too large (with either positive or negative sign).

Operations that overflow while the default rounding mode is in effect, return a positive or a negative HUGE_VAL (or HUGE_VALF or HUGE_VALL).

FE_OVERFLOW is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_OVERFLOW!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_UNDERFLOW Underflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X!
Cplusplus!int
To-nearest rounding direction mode
This macro expands to a value of type int that identifies the to-nearest rounding direction mode for functions fegetround and fesetround.

Rounding x to-nearest selects the possible value that is nearest to x, with halfway cases rounded away from zero.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_TONEAREST!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X!
Cplusplus!int
Toward-zero rounding direction mode
This macro expands to a value of type int that identifies the toward-zero rounding direction mode for functions fegetround and fesetround.

Rounding x toward zero selects the nearest possible value that is not larger in magnitude than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_TOWARDZERO!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TONEAREST To-nearest rounding direction mode (macro )
FE_UPWARD Upward rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X!
Cplusplus!int
Underflow range error exception
This macro expands to a value of type int that identifies the floating-point exception raised on underflow range errors.

Underflow range errors occur when the result of an operation cannot be represented as a value of its return type because its magnitude is too small (with either positive or negative sign).

Operations that overflow return an unspecified value whose magnitude is no greater than the smallest normalized positive number.

Whether an operation raises this exception is implementation-defined: there are no operations required to raise this exception, but an implementation may choose to do so.

FE_UNDERFLOW is defined as a value that is an exact power of two, allowing several floating-point exceptions to be combined (using the bitwise OR operator: |) into a single value:
macro value description
FE_DIVBYZERO Pole error: division by zero, or some other asymptotically infinite result (from finite arguments).
FE_INEXACT Inexact: the result is not exact.
FE_INVALID Domain error: At least one of the arguments is a value for which the function is not defined.
FE_OVERFLOW Overflow range error: The result is too large in magnitude to be represented as a value of the return type.
FE_UNDERFLOW Underflow range error: The result is too small in magnitude to be represented as a value of the return type.
FE_ALL_EXCEPT All exceptions (selects all of the exceptions supported by the implementation).
Certain library implementations may support additional floating-point exception values (with their corresponding macros also beginning with FE_).!FE_UNDERFLOW!X!X!FE_DIVBYZERO Pole error exception (macro )
FE_INEXACT Inexact result exception (macro )
FE_INVALID Invalid argument exception (macro )
FE_OVERFLOW Overflow range error exception (macro )
FE_ALL_EXCEPT All exceptions (macro )!X!
Cplusplus!int
Upward rounding direction mode
This macro expands to a value of type int that identifies the upward rounding direction mode for functions fegetround and fesetround.

Rounding x upward selects the smallest possible value that is not less than x.

Possible rounding direction modes are:
macro value description
FE_DOWNWARD Round downward.
FE_TONEAREST Round to nearest.
FE_TOWARDZERO Round toward zero.
FE_UPWARD Round upward.
!FE_UPWARD!X!X!FE_DOWNWARD Downward rounding direction mode (macro )
FE_TONEAREST To-nearest rounding direction mode (macro )
FE_TOWARDZERO Toward-zero rounding direction mode (macro )
fegetround Get rounding direction mode (function )
fesetround Set rounding direction mode (function )!X!
Cplusplus!struct lconv* localeconv (void);
Get locale formatting parameters for quantities
Retrieves the values provided in the current locale object to format parameters for quantities. These are returned in an object of type struct lconv (see lconv for the description of its members).!localeconv!none!A pointer to a structure object of the structure type lconv with the corresponding values for the current locale filled in. The data pointed by this should not be modified by the program. Its data may be overriden by a further call to this same function or to setlocale with a category affecting these settings.!struct lconv Formatting info for numeric values (type )
setlocale Set or retrieve locale (function )!X!
Cplusplus!char* setlocale (int category, const char* locale);
Set or retrieve locale
Sets locale information to be used by the current program, either changing the entire locale or portions of it. The function can also be used to retrieve the current locale's name by passing NULL as the value for argument locale.

Locales contain information on how to interpret and perform certain input/output and transformation operations taking into consideration location and language specific settings.

Most running environments have certain locale information set according to the user preferences or localization. But, independently of this system locale, on start, all C programs have the "C" locale set, which is a rather neutral locale with minimal locale information that allows the result of programs to be predictable. In order to use the default locale set in the environment, this function can be called with "" as argument locale.

On program startup, the locale selected is the "C" locale, which is the same as would be set by calling setlocale(LC_ALL,"C").

The locale settings selected in the environment can be selected by calling setlocale(LC_ALL,"").

The portions of the current locale affected by a call to this function are specified by argument category.!setlocale!category
Portion of the locale affected. It is one of the following constant values defined as macros in <clocale>:
value Portion of the locale affected
LC_ALL The entire locale.
LC_COLLATE Affects the behavior of strcoll and strxfrm.
LC_CTYPE Affects character handling functions (all functions of <cctype>, except isdigit and isxdigit), and the multibyte and wide character functions.
LC_MONETARY Affects monetary formatting information returned by localeconv.
LC_NUMERIC Affects the decimal-point character in formatted input/output operations and string formatting functions, as well as non-monetary information returned by localeconv.
LC_TIME Affects the behavior of strftime.
locale
C string containing the name of a C locale. These are system specific, but at least the two following locales must exist:
locale name description
"C" Minimal "C" locale
"" Environment's default locale
If the value of this parameter is NULL, the function does not make any changes to the current locale, but the name of the current locale is still returned by the function.!On success, A pointer to a C string identifying the locale currently set for the category. If category is LC_ALL and different portions of the locale are set to different values, the string returned gives this information in a format which may vary between library implementations.

If the function failed to set a new locale, this is not modified and a null pointer is returned.!localeconv Get locale formatting parameters for quantities (function )!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.!NULL!X!X!X!X!
Cplusplus!struct lconv;
Formatting info for numeric values
This structure holds formatting information on how numeric values, both monetary and non-monetary, are to be written.

The function localeconv returns an object of this type.

It contains the following members (not necessarily in this in order):

Member constants
member type value in "C" locale description
decimal_point char* "." Decimal-point separator used for non-monetary quantities.
thousands_sep char* "" Separators used to delimit groups of digits to the left of the decimal point for non-monetary quantities.
grouping char* "" Specifies the amount of digits that form each of the groups to be separated by thousands_sep separator for non-monetary quantities. This is a zero-terminated sequence of char values that may contain different grouping sizes for each successive group starting from the right, each number indicating the amount of digits for the group; the last number before the ending zero in this string is used for the remaining groups. For example, assuming thousand_sep is set to "," and the number to represent is one million (1000000):
with grouping set to "\3", the number would be represented as: 1,000,000 
with grouping set to "\1\2\3", the number would be represented as: 1,000,00,0 
with grouping set to "\3\1", the number would be represented as: 1,0,0,0,000 
CHAR_MAX indicates that no further grouping is to be performed.
int_curr_symbol char* "" International currency symbol. This is formed by the three-letter ISO-4217 entry code for the currency, like "USD" for U.S.-Dollar or "GBP" for Pound Sterling, followed by the character used to separate this symbol from the monetary quantity
currency_symbol char* "" Local currency symbol, like "$".
mon_decimal_point char* "" Decimal-point separator used for monetary quantities.
mon_thousands_sep char* "" Separators used to delimit groups of digits to the left of the decimal point for monetary quantities.
mon_grouping char* "" Specifies the amount of digits that form each of the groups to be separated by mon_thousands_sep separator for monetary quantities. See grouping description above.
positive_sign char* "" Sign to be used for nonnegative (positive or zero) monetary quantities.
negative_sign char* "" Sign to be used for negative monetary quantities.
char frac_digits char CHAR_MAX Amount of fractional digits to the right of the decimal point for monetary quantities in the local format.
p_cs_precedes char CHAR_MAX Whether the currency symbol should precede nonnegative (positive or zero) monetary quantities. If this value is 1, the currency symbol should precede; if it is 0, it should follow.
n_cs_precedes char CHAR_MAX Whether the currency symbol should precede negative monetary quantities. If this value is 1, the currency symbol should precede; if it is 0 it should follow.
p_sep_by_space char CHAR_MAX Whether a space should appear between the currency symbol and nonnegative (positive or zero) monetary quantities. If this value is 1, a space should appear; if it is 0 it should not.
n_sep_by_space char CHAR_MAX Whether a space should appear between the currency symbol and negative monetary quantities. If this value is 1, a space should appear; if it is 0 it should not.
p_sign_posn char CHAR_MAX Position of the sign for nonnegative (positive or zero) monetary quantities:
0 : Currency symbol and quantity surrounded by parentheses.
1 : Sign before the quantity and currency symbol.
2 : Sign after the quantity and currency symbol.
3 : Sign right before currency symbol.
4 : Sign right after currency symbol.
CHAR_MAX : Unspecified.
n_sign_posn char CHAR_MAX Position of the sign for negative monetary quantities. See p_sign_posn above.
int_frac_digits char CHAR_MAX Same as frac_digits, but for the international format (instead of the local format).
int_p_cs_precedes char CHAR_MAX Same as p_cs_precedes, but for the international format.
int_n_cs_precedes char CHAR_MAX Same as n_cs_precedes, but for the international format.
int_p_sep_by_space char CHAR_MAX Same as p_sep_by_space, but for the international format.
int_n_sep_by_space char CHAR_MAX Same as n_sep_by_space, but for the international format.
int_p_sign_posn char CHAR_MAX Same as p_sign_posn, but for the international format.
int_n_sign_posn char CHAR_MAX Same as n_sign_posn, but for the international format.

A value of "" for a member of type char* or a value of CHAR_MAX for a member of type char indicates that the value is not available in the locale.!struct lconv!X!X!localeconv Get locale formatting parameters for quantities (function )!The members that begin with int_p and int_n (in yellow above) are defined for libraries complying with the C standard of 1999 or later (which is only required by the C++ standard since 2011: C++11).!
Cplusplus!double abs (double x);
float abs (float x);
long double abs (long double x);
Compute absolute value
Returns the absolute value of x: |x|.

These convenience abs overloads are exclusive of C++. In C, abs is only declared in <stdlib.h> (and operates on int values).

Since C++11, additional overloads are provided in this header (<cmath>) for the integral types: These overloads effectively cast x to a double before calculations (defined for T being any integral type).!abs!x
Value whose absolute value is returned.!The absolute value of x.!abs (cstdlib) Absolute value (function )
fabs Compute absolute value (function )
labs Absolute value (function )!X!
Cplusplus!double acos (double x);
float acos (float x);
long double acos (long double x);
Compute arc cosine
Returns the principal value of the arc cosine of x, expressed in radians.

In trigonometrics, arc cosine is the inverse operation of cosine.!acos!x
Value whose arc cosine is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.!Principal arc cosine of x, in the interval [0,pi] radians.
One radian is equivalent to 180/PI degrees.!cos Compute cosine (function )
asin Compute arc sine (function )!X!
Cplusplus!double acosh  (double x);
float acoshf (float x);
long double acoshl (long double x);
Compute arc hyperbolic cosine
Returns the nonnegative arc hyperbolic cosine of x, expressed in radians.

The arc hyperbolic cosine is the inverse operation of the hyperbolic cosine.!acosh!x
Value whose arc hyperbolic cosine is computed.
If the argument is less than 1, a domain error occurs.!Nonnegative arc hyperbolic cosine of x, in the interval [0,+INFINITY] radians.
Note that the negative of this value is also a valid arc hyperbolic cosine of x One radian is equivalent to 180/PI degrees.

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!cosh Compute hyperbolic cosine (function )
asinh Compute arc hyperbolic sine (function )!X!
Cplusplus!Compute arc sine
Returns the principal value of the arc sine of x, expressed in radians.

In trigonometrics, arc sine is the inverse operation of sine.!asin!x
Value whose arc sine is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.!Principal arc sine of x, in the interval [-pi/2,+pi/2] radians.
One radian is equivalent to 180/PI degrees.!sin Compute sine (function )
acos Compute arc cosine (function )!X!
Cplusplus!double asinh  (double x);
float asinhf (float x);
long double asinhl (long double x);
Compute arc hyperbolic sine
Returns the arc hyperbolic sine of x, expressed in radians.

The arc hyperbolic sine is the inverse operation of the hyperbolic sine.!asinh!x
Value whose arc hyperbolic sine is computed.!Arc hyperbolic sine of x, in radians.
One radian is equivalent to 180/PI degrees.!sinh Compute hyperbolic sine (function )
acosh Compute arc hyperbolic cosine (function )!X!
Cplusplus!double atan (double x);
float atan (float x);
long double atan (long double x);
Compute arc tangent
Returns the principal value of the arc tangent of x, expressed in radians.

In trigonometrics, arc tangent is the inverse operation of tangent.

Notice that because of the sign ambiguity, the function cannot determine with certainty in which quadrant the angle falls only by its tangent value. See atan2 for an alternative that takes a fractional argument instead.!atan!x
Value whose arc tangent is computed.!Principal arc tangent of x, in the interval [-pi/2,+pi/2] radians.
One radian is equivalent to 180/PI degrees.
!atan2 Compute arc tangent with two parameters (function )
tan Compute tangent (function )
sin Compute sine (function )
cos Compute cosine (function )!X!
Cplusplus!double atan2 (double y     , double x);
float atan2 (float y      , float x);
long double atan2 (long double y, long double x);
Compute arc tangent with two parameters
Returns the principal value of the arc tangent of y/x, expressed in radians.

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

In C++, this function is overloaded in <valarray> (see valarray atan2).!atan2!y
Value representing the proportion of the y-coordinate.
x
Value representing the proportion of the x-coordinate.
If both arguments passed are zero, a domain error occurs.!Principal arc tangent of y/x, in the interval [-pi,+pi] radians.
One radian is equivalent to 180/PI degrees.!atan Compute arc tangent (function )
tan Compute tangent (function )
sin Compute sine (function )
cos Compute cosine (function )!X!
Cplusplus!double atanh  (double x);
float atanhf (float x);
long double atanhl (long double x);
Compute arc hyperbolic tangent
Returns the arc hyperbolic tangent of x, expressed in radians.

The arc hyperbolic tangent is the inverse operation of the hyperbolic tangent.!atanh!x
Value whose arc hyperbolic tangent is computed, in the interval [-1,+1].
If the argument is out of this interval, a domain error occurs.
For values of -1 and +1, a pole error may occur.!Arc hyperbolic tangent of x, in radians.
One radian is equivalent to 180/PI degrees.

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!tanh Compute hyperbolic tangent (function )
asinh Compute arc hyperbolic sine (function )
acosh Compute arc hyperbolic cosine (function )!X!
Cplusplus!double cbrt  (double x);
float cbrtf (float x);
long double cbrtl (long double x);
Compute cubic root
Returns the cubic root of x.!cbrt!x
Value whose cubit root is computed.!Cubic root of x.!sqrt Compute square root (function )
pow Raise to power (function )!X!
Cplusplus!double ceil (double x);
Round up value
Rounds x upward, returning the smallest integral value that is not less than x.!ceil!x
Value to round up.!The smallest integral value that is not less than x (as a floating-point value).!floor Round down value (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X!
Cplusplus!double copysign  (double x     , double y);
float copysignf (float x      , float y);
long double copysignl (long double x, long double y);
Copy sign
Returns a value with the magnitude of x and the sign of y.!copysign!x
Value with the magnitude of the resulting value.
y
Value with the sign of the resulting value.!The value with a magnitude of x and the sign of y.!fabs Compute absolute value (function )!X!
Cplusplus!double cos (double x);
Compute cosine
Returns the cosine of an angle of x radians.!cos!x
Value representing an angle expressed in radians.
One radian is equivalent to 180/PI degrees.!Cosine of x radians.!sin Compute sine (function )
tan Compute tangent (function )!X!
Cplusplus!double cosh (double x);
Compute hyperbolic cosine
Returns the hyperbolic cosine of x radians.!cosh!x
Value representing an angle, expressed in radians.!Hyperbolic cosine of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!sinh Compute hyperbolic sine (function )
tanh Compute hyperbolic tangent (function )!X!
Cplusplus!double erf  (double x);
float erff (float x);
long double erfl (long double x);
Compute error function
error function Returns the error function value for x.!erf!x
Parameter for the error function.!Error function value for x.!erfc Compute complementary error function (function )
lgamma Compute log-gamma function (function )
tgamma Compute gamma function (function )!X!
Cplusplus!double erfc  (double x);
float erfcf (float x);
long double erfcl (long double x);
Compute complementary error function
complementary error function Returns the complementary error function value for x.

The complementary error function is equivalent to:
erfc(x) = 1-erf(x) !erfc!x
Parameter for the complementary error function.!Complementary error function value for x.
If x is too large, an underflow range error occurs.

If an underflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_UNDERFLOW is raised.!erf Compute error function (function )
lgamma Compute log-gamma function (function )
tgamma Compute gamma function (function )!X!
Cplusplus!double exp (double x);
Compute exponential function
Returns the base-e exponential function of x, which is e raised to the power x: ex.!exp!x
Value of the exponent.!Exponential value of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!log Compute natural logarithm (function )
pow Raise to power (function )!X!
Cplusplus!double exp2  (double x);
float exp2f (float x);
long double exp2l (long double x);
Compute binary exponential function
Returns the base-2 exponential function of x, which is 2 raised to the power x: 2x.!exp2!x
Value of the exponent.!2 raised to the power of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!log2 Compute binary logarithm (function )
pow Raise to power (function )
exp Compute exponential function (function )!X!
Cplusplus!double expm1  (double x);
float expm1f (float x);
long double expm1l (long double x);
Compute exponential minus one
Returns e raised to the power x minus one: ex-1.

For small magnitude values of x, expm1 may be more accurate than exp(x)-1.!expm1!x
Value of the exponent.!e raised to the power of x, minus one.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.
!exp Compute exponential function (function )
log1p Compute logarithm plus one (function )
pow Raise to power (function )!X!
Cplusplus!double fabs (double x);
Compute absolute value
Returns the absolute value of x: |x|.!fabs!x
Value whose absolute value is returned.!The absolute value of x.!abs Absolute value (function )
labs Absolute value (function )
floor Round down value (function )
ceil Round up value (function )
modf Break into fractional and integral parts (function )!X!
Cplusplus!double fdim  (double x     , double y);
float fdimf (float x      , float y);
long double fdiml (long double x, long double y);
Positive difference
Returns the positive difference between x and y.

The function returns x-y if x>y, and zero otherwise.!fdim!x, y
Values whose difference is calculated.!The positive difference between x and y.!fmax Maximum value (function )
fmin Minimum value (function )!X!
Cplusplus!double floor (double x);
Round down value
Rounds x downward, returning the largest integral value that is not greater than x.!floor!x
Value to round down.!The value of x rounded downward (as a floating-point value).!ceil Round up value (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X!
Cplusplus!double fma  (double x     , double y     , double z);
float fmaf (float x      , float y      , float z);
long double fmal (long double x, long double y, long double z);
Multiply-add
Returns x*y+z.

The function computes the result without losing precision in any intermediate result.

The following macro constants may be defined in an implementation to signal that this function generally provides an efficiency improvement over performing the arithmetic operations in x*y+z (such as when a hardware multiply-add instruction is used):

macro description
FP_FAST_FMA For arguments of type double, it generally executes about as fast as, or faster than, x*y+z.
FP_FAST_FMAF For arguments of type float, it generally executes about as fast as, or faster than, x*y+z.
FP_FAST_FMAL For arguments of type long double, it generally executes about as fast as, or faster than, x*y+z.
!fma!x, y
Values to be multiplied.
z
Value to be added.!The result of x*y+z!fmin Minimum value (function )
fdim Positive difference (function )!X!
Cplusplus!double fmax  (double x     , double y);
float fmaxf (float x      , float y);
long double fmaxl (long double x, long double y);
Maximum value
Returns the larger of its arguments: either x or y.

If one of the arguments in a NaN, the other is returned.!fmax!x, y
Values among which the function selects a maximum.!The maximum numeric value of its arguments.!fmin Minimum value (function )
fdim Positive difference (function )!X!
Cplusplus!double fmin  (double x     , double y);
      float fminf (float x      , float y);
long double fminl (long double x, long double y);
Minimum value
Returns the smaller of its arguments: either x or y.

If one of the arguments in a NaN, the other is returned.!fmin!x, y
Values among which the function selects a minimum.!The minimum numeric value of its arguments.!fmax Maximum value (function )
fdim Positive difference (function )!X!
Cplusplus!double fmod (double numer, double denom);
Compute remainder of division
Returns the floating-point remainder of numer/denom (rounded towards zero):

fmod = numer - tquot * denom 

Where tquot is the truncated (i.e., rounded towards zero) result of: numer/denom.

A similar function, remainder, returns the same but with the quotient rounded to the nearest integer (instead of truncated).!fmod!numer
Value of the quotient numerator.
denom
Value of the quotient denominator.!The remainder of dividing the arguments.
If denom is zero, the function may either return zero or cause a domain error (depending on the library implementation).
!remainder Compute remainder (IEC 60559) (function )
fabs Compute absolute value (function )
modf Break into fractional and integral parts (function )!X!
Cplusplus!macro 
fpclassify(x)
Classify floating-point value
Returns a value of type int that matches one of the classification macro constants, depending on the value of x:

value description
FP_INFINITE Positive or negative infinity (overflow)
FP_NAN Not-A-Number
FP_ZERO Value of zero
FP_SUBNORMAL Sub-normal value (underflow)
FP_NORMAL Normal value (none of the above)
Note that each value pertains to a single category: zero is not a normal value.

These macro constants of type int are defined in header <cmath> (<math.h>).!fpclassify!x
The value to classify.!One of the followoing int values: FP_INFINITE, FP_NAN, FP_ZERO, FP_SUBNORMAL or FP_NORMAL.!isfinite Is finite value (macro )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
signbit Sign bit (macro/function )!X!
Cplusplus!double frexp (double x, int* exp);
Get significand and exponent
Breaks the floating point number x into its binary significand (a floating point value between 0.5(included) and 1.0(excluded)) and an integral exponent for 2, such that:

x = significand * 2 exponent 
The exponent is stored in the location pointed by exp, and the significand is the value returned by the function.

If x is zero, both parts (significand and exponent) are zero.!frexp!x
Value to be decomposed.
exp
Pointer to an int where the value of the exponent is stored.!The binary significand of x.
This value is the floating point value in the interval [0.5,1) which, once multiplied by 2 raised to the power of exp, yields x.!ldexp Generate value from significand and exponent (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X!
Cplusplus!double hypot  (double x     , double y);
float hypotf (float x      , float y);
long double hypotl (long double x, long double y);
Compute hypotenuse
Returns the hypotenuse of a right-angled triangle whose legs are x and y.

The function returns what would be the square root of the sum of the squares of x and y (as per the Pythagorean theorem), but without incurring in undue overflow or underflow of intermediate values.
!hypot!x, y
Floating point values corresponding to the legs of a right-angled triangle for which the hypotenuse is computed.
!The square root of (x2+y2).
If the magnitude of the result is too large to be represented by a value of the return type, the function may return HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign (in which case, an overflow range error occurs):

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!sqrt Compute square root (function )
pow Raise to power (function )!X!
Cplusplus!int ilogb  (double x);
int ilogbf (float x);
int ilogbl (long double x);
Integer binary logarithm
Returns the integral part of the logarithm of |x|, using FLT_RADIX as base for the logarithm.

This is the exponent used internally by the machine to express the floating-point value x, when it uses a significand between 1.0 and FLT_RADIX, so that, for a positive x:

x = significand * FLT_RADIX exponent 

Generally, FLT_RADIX is 2, and the value returned by this function is one less than the exponent obtained with frexp (because of the different significand normalization as [1.0,2.0) instead of [0.5,1.0)).
!ilogb!x
Value whose ilogb is returned.!If x is normal, the base-FLT_RADIX logarithm of x.
If x is subnormal, the value returned is the one corresponding to the normalized representation (negative exponent).
If x is zero, it returns FP_LOGB0 (a special value, only returned by this function, defined in <cmath>).
If x is infinite, it returns INT_MAX.
If x is NaN, it returns FP_ILOGBNAN (a special value, only returned by this function, defined in <cmath>).
If the magnitude of the result is too large to be represented by a value of the return type, the function returns an unspecified value, and an overflow range error occurs.
A zero, infinite or NaN value of x may also cause either a domain error or an overflow range error.

If an domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!logb Compute floating-point base logarithm (function )
log2 Compute binary logarithm (function )
pow Raise to power (function )!X!
Cplusplus!macro 
isfinite(x)
Is finite value
Returns whether x is a finite value.

A finite value is any floating-point value that is neither infinite nor NaN (Not-A-Number).!isfinite!x
A floating-point value.!A non-zero value (true) if x is finite; and zero (false) otherwise.!isinf Is infinity (macro/function )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X!
Cplusplus!macro 
isgreater(x,y)
Is greater
Returns whether x is greater than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x>y may raise such an exception in this case).!isgreater!x, y
Values to be compared.!The same as (x)>(y):
true (1) if x is greater than y.
false (0) otherwise.!isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X!
Cplusplus!macro 
isgreaterequal(x,y)
Is greater or equal
Returns whether x is greater than or equal to y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x>=y may raise such an exception in this case).!isgreaterequal!x, y
Values to be compared.!The same as (x)>=(y):
true (1) if x is greater than or equal to y.
false (0) otherwise.!isgreater Is greater (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X!
Cplusplus!macro 
isinf(x)
Is infinity
Returns whether x is an infinity value (either positive infinity or negative infinity).!isinf!x
A floating-point value.!A non-zero value (true) if x is an infinity; and zero (false) otherwise.!isfinite Is finite value (macro )
isnan Is Not-A-Number (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X!
Cplusplus!macro 
isless(x,y)
Is less
Returns whether x is less than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<y may raise such an exception in this case).
!isless!x, y
Values to be compared.!The same as (x)<(y):
true (1) if x is less than y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
islessequal Is less or equal (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X!
Cplusplus!
macro 
islessequal(x,y)
Is less or equal
Returns whether x is less than or equal to y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<=y may raise such an exception in this case).!islessequal!x, y
Values to be compared.!The same as (x)<=(y):
true (1) if x is less than or equal to y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X!
Cplusplus!macro 
islessgreater(x,y)
Is less or greater
Returns whether x is less than or greater than y.

If one or both arguments are NaN, the function returns false, but no FE_INVALID exception is raised (note that the expression x<y||x>y may raise such an exception in this case).!islessgreater!x, y
Values to be compared.!The same as (x)<(y)||(x)>(y):
true (1) if x is less than or greater than y.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessequal Is less or equal (macro )
isunordered Is unordered (macro )!X!
Cplusplus!macro 
isnan(x)
Is Not-A-Number
Returns whether x is a NaN (Not-A-Number) value.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.!isnan!x
A floating-point value.!A non-zero value (true) if x is a NaN value; and zero (false) otherwise.!NAN Not-A-Number (constant )
isfinite Is finite value (macro )
isinf Is infinity (macro/function )
isnormal Is normal (macro/function )
fpclassify Classify floating-point value (macro/function )!X!
Cplusplus!macro 
isnormal(x)
Is normal
Returns whether x is a normal value: i.e., whether it is neither infinity, NaN, zero or subnormal.!isnormal!x
A floating-point value.!A non-zero value (true) if x is normal; and zero (false) otherwise.!isfinite Is finite value (macro )
isinf Is infinity (macro/function )
isnan Is Not-A-Number (macro/function )
fpclassify Classify floating-point value (macro/function )!X!
Cplusplus!macro 
isunordered(x,y)
Is unordered
Returns whether x or y are unordered values:

If one or both arguments are NaN, the arguments are unordered and the function returns true. In no case the function raises a FE_INVALID exception.!isunordered!x, y
Values to check whether they are unordered.!true (1) if either x or y is NaN.
false (0) otherwise.!isgreater Is greater (macro )
isgreaterequal Is greater or equal (macro )
isless Is less (macro )
islessgreater Is less or greater (macro )
isunordered Is unordered (macro )!X!
Cplusplus!double ldexp (double x, int exp);
Generate value from significand and exponent
Returns the result of multiplying x (the significand) by 2 raised to the power of exp (the exponent).

lexpr(x,exp) = x * 2 exp !ldexp!x
Floating point value representing the significand.
exp
Value of the exponent.!The function returns:

x * 2 exp 

If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs, the global variable errno is set to ERANGE.!frexp Get significand and exponent (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X!
Cplusplus!double lgamma  (double x);
float lgammaf (float x);
long double lgammal (long double x);
Compute log-gamma function
log-gamma function Returns the natural logarithm of the absolute value of the gamma function of x.!lgamma!x
Parameter for the log-gamma function.!Log-gamma function of x.
If x is too large, an overflow range error occurs.
If x is zero or a negative integer for which the function is asymptotic, it may cause a pole error (depending on implementation).

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!tgamma Compute gamma function (function )
erf Compute error function (function )
erfc Compute complementary error function (function )!X!
Cplusplus!long long int llrint  (double x);
long long int llrintf (float x);
long long int llrintl (long double x);
Round and cast to long long integer
Rounds x to an integral value, using the rounding direction specified by fegetround, and returns it as a value of type long long int.

See lrint for an equivalent function that returns a long int.!llrint!x
Value to round.!The value of x rounded to a nearby integral, casted to a value of type long long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nearbyint Round to nearby integral value (function )
rint Round to integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X!
Cplusplus!long long int llround  (double x);
long long int llroundf (float x);
long long int llroundl (long double x);
Round to nearest and cast to long long integer
Returns the integer value that is nearest in value to x, with halfway cases rounded away from zero.

The rounded value is returned as a value of type long long int. See lround for an equivalent function that returns a long int instead.!llround!x
Value to round.!The value of x rounded to the nearest integral, casted to a value of type long long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!llrint Round and cast to long long integer (function )
round Round to nearest (function )
lround Round to nearest and cast to long integer (function )
nearbyint Round to nearby integral value (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X!
Cplusplus!double log (double x);
Compute natural logarithm
Returns the natural logarithm of x.

The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp). For common (base-10) logarithms, see log10.!log!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!Natural logarithm of x.
If x is negative, it causes a domain error.
If x is zero, it may cause a pole error (depending on the library implementation).If a domain error occurs, the global variable errno is set to EDOM.
If a pole error occurs, the global variable errno is set ERANGE.!log10 Compute common logarithm (function )
exp Compute exponential function (function )
pow Raise to power (function )!X!
Cplusplus!double log10 (double x);
Compute common logarithm
Returns the common (base-10) logarithm of x.!log10!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!Common logarithm of x.
If x is negative, it causes a domain error.
If x is zero, it may cause a pole error (depending on the library implementation).!log Compute natural logarithm (function )
exp Compute exponential function (function )
pow Raise to power (function )!X!
Cplusplus!double log1p  (double x);
float log1pf (float x);
long double log1pl (long double x);
Compute logarithm plus one
Returns the natural logarithm of one plus x.

For small magnitude values of x, logp1 may be more accurate than log(1+x).!log1p!x
Value whose logarithm is calculated.
If the argument is less than -1, a domain error occurs.!The natural logarithm of (1+x).
If x is less than -1, it causes a domain error.
If x is -1, it may cause a pole error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!exp Compute exponential function (function )
log1p Compute logarithm plus one (function )
pow Raise to power (function )!X!
Cplusplus!double log2  (double x);
float log2f (float x);
long double log2l (long double x);
Compute binary logarithm
Returns the binary (base-2) logarithm of x.!log2!x
Value whose logarithm is calculated.
If the argument is negative, a domain error occurs.!The binary logarithm of x: log2x.
If x is negative, it causes a domain error:
If x is zero, it may cause a pole error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.
!exp2 Compute binary exponential function (function )
log Compute natural logarithm (function )
pow Raise to power (function )!X!
Cplusplus!double logb  (double x);
      float logbf (float x);
long double logbl (long double x);
Compute floating-point base logarithm
Returns the logarithm of |x|, using FLT_RADIX as base for the logarithm.

On most platforms, FLT_RADIX is 2, and thus this function is equivalent to log2 for positive values.!logb!x
Value whose logarithm is calculated.
!The base-FLT_RADIX logarithm of x.
If x is zero it may cause a domain error or a pole error (or no error, depending on the library implementation).

If an domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_DIVBYZERO is raised.!ilogb Integer binary logarithm (function )
log2 Compute binary logarithm (function )
pow Raise to power (function )!X!
Cplusplus!long int lrint  (double x);
long int lrintf (float x);
long int lrintl (long double x);
Round and cast to long integer
Rounds x to an integral value, using the rounding direction specified by fegetround, and returns it as a value of type long int.

See llrint for an equivalent function that returns a long long int.!lrint!x
Value to round.!The value of x rounded to a nearby integral, casted to a value of type long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!See also
nearbyint
Round to nearby integral value (function )
rint
Round to integral value (function )
llrint
Round and cast to long long integer (function )
round
Round to nearest (function )
floor
Round down value (function )
ceil
Round up value (function )
trunc
Truncate value (function )!X!
Cplusplus!long int lround  (double x);
long int lroundf (float x);
long int lroundl (long double x);
Round to nearest and cast to long integer
Returns the integer value that is nearest in value to x, with halfway cases rounded away from zero.

The rounded value is returned as a value of type long int. See llround for an equivalent function that returns a long long int instead.!lround!x
Value to round.!The value of x rounded to the nearest integral, casted to a value of type long int.
If the rounded value is outside the range of the return type, the value returned is unspecified, and a domain error or an overflow range error may occur (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!lrint Round and cast to long integer (function )
round Round to nearest (function )
llround Round to nearest and cast to long long integer (function )
nearbyint Round to nearby integral value (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X!
Cplusplus!double modf (double x, double* intpart);
Break into fractional and integral parts
Breaks x into an integral and a fractional part.

The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function.

Both parts have the same sign as x.!modf!x
Floating point value to break into parts.
intpart
Pointer to an object (of the same type as x) where the integral part is stored with the same sign as x.!The fractional part of x, with the same sign.!ldexp Generate value from significand and exponent (function )
frexp Get significand and exponent (function )!X!
Cplusplus!double nan (const char* tagp);
Generate quiet NaN
Returns a quiet NaN (Not-A-Number) value of type double.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nanf and nanl return NaN values of type float and long double, respectively.!nan!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtod).!A quiet NaN value.
!isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )
NAN Not-A-Number (constant )!X!
Cplusplus!float nanf (const char* tagp);
Generate quiet NaN (float)
Returns a quiet NaN (Not-A-Number) value of type float.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nan and nanl return NaN values of type double and long double, respectively.!nanf!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtof).!A quiet NaN value.!NAN Not-A-Number (constant )
nan Generate quiet NaN (function )
isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )!X!
Cplusplus!float nanl (const char* tagp);
Generate quier NaN (long double)
Returns a quiet NaN (Not-A-Number) value of type long double.

The NaN values are used to identify undefined or non-representable values for floating-point elements, such as the square root of negative numbers or the result of 0/0.

The argument can be used by library implementations to distinguish different NaN values in a implementation-specific manner.

Similarly, nan and nanf return NaN values of type double and float, respectively.!nanl!tagp
An implementation-specific C-string.
If this is an empty string (""), the function returns a generic NaN value (the same as returned by passing "NAN" to strtold).!A quiet NaN value.!NAN Not-A-Number (constant )
nan Generate quiet NaN (function )
isnan Is Not-A-Number (macro/function )
nextafter Next representable value (function )
nexttoward Next representable value toward precise value (function )!X!
Cplusplus!double nearbyint  (double x);
float nearbyintf (float x);
long double nearbyintl (long double x);
Round to nearby integral value
Rounds x to an integral value, using the rounding direction specified by fegetround.

This function does not raise FE_INEXACT exceptions. See rint for an equivalent function that may do.!nearbyint!x
Value to round.!The value of x rounded to a nearby integral (as a floating-point value).!rint Round to integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X!
Cplusplus!double nextafter  (double x     , double y);
float nextafterf (float x      , float y);
long double nextafterl (long double x, long double y);
Next representable value
Returns the next representable value after x in the direction of y.

The similar function, nexttoward has the same behavior, but it takes a long double as second argument.!nextafter!x
Base value.
y
Value toward which the return value is approximated.
If both parameters compare equal, the function returns y.
!The next representable value after x in the direction of y.

If x is the largest finite value representable in the type, and the result is infinite or not representable, an overflow range error occurs.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nexttoward Next representable value toward precise value (function )!X!
Cplusplus!double nexttoward  (double x     , long double y);
float nexttowardf (float x      , long double y);
long double nexttowardl (long double x, long double y);
Next representable value toward precise value
Returns the next representable value after x in the direction of y.

This function behaves as nextafter, but with a potentially more precise y.!nexttoward!x
Base value.
y
Value toward which the return value is approximated.
If both parameters compare equal, the function returns y (converted to the return type).
!The next representable value after x in the direction of y.

If x is the largest finite value representable in the type, and the result is infinite or not representable, an overflow range error occurs.

If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!nextafter Next representable value (function )!X!
Cplusplus!double pow (double base, double exponent);
Raise to power
Returns base raised to the power exponent:

baseexponent !pow!base
Base value.
exponent
Exponent value.!The result of raising base to the power exponent.

If the base is finite negative and the exponent is finite but not an integer value, it causes a domain error.
If both base and exponent are zero, it may also cause a domain error on certain implementations.
If base is zero and exponent is negative, it may cause a domain error or a pole error (or none, depending on the library implementation).
The function may also cause a range error if the result is too great or too small to be represented by a value of the return type.

C90 (C++98)C99 (C+11)
If a domain error occurs, the global variable errno is set to EDOM.
If a pole or range error occurs, the global variable errno is set ERANGE.!log Compute natural logarithm (function )
exp Compute exponential function (function )
sqrt Compute square root (function )!X!
Cplusplus!double remainder  (double numer     , double denom);
      float remainderf (float numer      , float denom);
long double remainderl (long double numer, long double denom);
Compute remainder (IEC 60559)
Returns the floating-point remainder of numer/denom (rounded to nearest):

remainder = numer - rquot * denom 

Where rquot is the result of: numer/denom, rounded toward the nearest integral value (with halfway cases rounded toward the even number).

A similar function, fmod, returns the same but with the quotient truncated (rounded towards zero) instead.
The function remquo has a behavior identical to this function, but it additionally provides access to the intermediate quotient value used.!remainder!numer
Value of the quotient numerator.
denom
Value of the quotient denominator.!The remainder of dividing the arguments.
If this remainder is zero, its sign shall be that of numer.
If denom is zero, the function may either return zero or cause a domain error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!fmod Compute remainder of division (function )
fabs Compute absolute value (function )
round Round to nearest (function )!X!
Cplusplus!double remquo  (double numer     , double denom     , int* quot);
 float remquof (float numer      , float denom      , int* quot);
long double remquol (long double numer, long double denom, int* quot);
Compute remainder and quotient
Returns the same as remainder, but it additionally stores the quotient internally used to determine its result in the object pointed by quot.

The value pointed by quot contains the congruent modulo with at least 3 bits of the integral quotient numer/denom.
!remquo!numer
Floating point value with the quotient numerator.
denom
Floating point value with the quotient denominator.
quot
Pointer to an object where the quotient internally used to determine the remainder is stored as a value of type int.!The remainder of dividing the arguments.
If this remainder is zero, its sign shall be that of x; In this case, the value stored in quot is unspecified.
If denominator is zero, the function may either return zero or cause a domain error (depending on the library implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.
!remainder Compute remainder (IEC 60559) (function )
fmod Compute remainder of division (function )
fabs Compute absolute value (function )
round Round to nearest (function )!X!
Cplusplus!double rint  (double x);
float rintf (float x);
long double rintl (long double x);
Round to integral value
Rounds x to an integral value, using the rounding direction specified by fegetround.

This function may raise an FE_INEXACT exception if the value returned differs in value from x. See nearbyint for an equivalent function that cannot raise such exception.!rint!x
Value to round.
!The value of x rounded to a nearby integral (as a floating-point value).
If this value differs from x, a FE_INEXACT exception may be raised (depending on the implementation).!nearbyint Round to nearby integral value (function )
lrint Round and cast to long integer (function )
round Round to nearest (function )
floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )!X!
Cplusplus!double round  (double x);
float roundf (float x);
long double roundl (long double x);
Round to nearest
Returns the integral value that is nearest to x, with halfway cases rounded away from zero.!round!x
Value to round.!The value of x rounded to the nearest integral (as a floating-point value).!floor Round down value (function )
ceil Round up value (function )
trunc Truncate value (function )
nearbyint Round to nearby integral value (function )
rint Round to integral value (function )!X!
Cplusplus!double scalbln  (double x     , long int n);
float scalblnf (float x      , long int n);
long double scalblnl (long double x, long int n);
Scale significand using floating-point base exponent (long)
Scales x by FLT_RADIX raised to the power of n, returning the result of computing:

scalbn(x,n) = x * FLT_RADIXn 

Presumably, x and n are the components of a floating-point number in the system; In such a case, this function may be optimized to be more efficient than the theoretical operations to compute the value explicitly.

There also exists another version of this function: scalbn, which is identical, except that it takes an int as second argument.!scalbln!Value representing the significand.</dd>
exp
Value of the exponent.!Returns x * FLT_RADIXn.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error may occur (if too small, the function returns zero, and an underflow range error may occur).

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.!scalbn Scale significand using floating-point base exponent (function )
ldexp Generate value from significand and exponent (function )
logb Compute floating-point base logarithm (function )!X!
Cplusplus!double scalbn  (double x     , int n);
float scalbnf (float x      , int n);
long double scalbnl (long double x, int n);
Scale significand using floating-point base exponent
Scales x by FLT_RADIX raised to the power of n, returning the same as:

scalbn(x,n) = x * FLT_RADIXn 

Presumably, x and n are the components of a floating-point number in the system; In such a case, this function may be optimized to be more efficient than the theoretical operations to compute the value explicitly.

On most platforms, FLT_RADIX is 2, making this function equivalent to ldexp.!scalbn!x
Value representing the significand.
exp
Value of the exponent.!Returns x * FLT_RADIXn.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error may occur (if too small, the function returns zero, and an underflow range error may occur).

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.!ldexp Generate value from significand and exponent (function )
logb Compute floating-point base logarithm (function )!X!
Cplusplus!macro 
signbit(x)
Sign bit
Returns whether the sign of x is negative.

This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive).!signbit!x
A floating-point value.!A non-zero value (true) if the sign of x is negative; and zero (false) otherwise.!isinf Is infinity (macro/function )
isnormal Is normal (macro/function )
isnan Is Not-A-Number (macro/function )
fpclassify Classify floating-point value (macro/function )!X!
Cplusplus!double sin  (double x);
float sinf (float x);
long double sinl (long double x);
Compute sine
Returns the sine of an angle of x radians.
!sin!x
Value representing an angle expressed in radians.
One radian is equivalent to 180/PI degrees.!Sine of x radians.!cos Compute cosine (function )
tan Compute tangent (function )!X!
Cplusplus!double sinh  (double x);
float sinhf (float x);
long double sinhl (long double x);
Compute hyperbolic sine
Returns the hyperbolic sine of x radians.!sinh!x
Value representing an angle, expressed in radians.!Hyperbolic sine of x.
If the magnitude of the result is too large to be represented by a value of the return type, the function returns HUGE_VAL (or HUGE_VALF or HUGE_VALL) with the proper sign, and an overflow range error occurs:If an overflow range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: FE_OVERFLOW is raised.!cosh Compute hyperbolic cosine (function )
tanh Compute hyperbolic tangent (function )!X!
Cplusplus!double sqrt  (double x);
float sqrtf (float x);
long double sqrtl (long double x);
Compute square root
Returns the square root of x.!sqrt!x
Value whose square root is computed.
If the argument is negative, a domain error occurs.!Square root of x.
If x is negative, a domain error occurs:If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.!pow Raise to power (function )
log Compute natural logarithm (function )!X!
Cplusplus!double tan  (double x);
float tanf (float x);
long double tanl (long double x);
Compute tangent
Returns the tangent of an angle of x radians.!tan!x
Value representing an angle, expressed in radians.
One radian is equivalent to 180/PI degrees.!Tangent of x radians.!sin Compute sine (function )
cos Compute cosine (function )
atan Compute arc tangent (function )!X!
Cplusplus!double tanh  (double x);
float tanhf (float x);
long double tanhl (long double x);
Compute hyperbolic tangent
Returns the hyperbolic tangent of x radians.!tanh!x
Value representing an angle, expressed in radians.!Hyperbolic tangent of x.!sinh Compute hyperbolic sine (function )
cosh Compute hyperbolic cosine (function )!X!
Cplusplus!double tgamma  (     double x);
float tgammaf (      float x);
long double tgammal (long double x);
Compute gamma function
gamma function Returns the gamma function of x.!tgamma!x
Parameter for the gamma function.!Gamma function of x.
If the magnitude of x is too large, an overflow range error occurs. If too small, an underflow range error may occur.
If x is zero or a negative integer for which the function is asymptotic, it may cause a domain error or a pole error (or none, depending on implementation).

If a domain error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to EDOM.
- And math_errhandling has MATH_ERREXCEPT set: FE_INVALID is raised.

If a range error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_OVERFLOW or FE_UNDERFLOW is raised.

If a pole error occurs:
- And math_errhandling has MATH_ERRNO set: the global variable errno is set to ERANGE.
- And math_errhandling has MATH_ERREXCEPT set: either FE_DIVBYZERO is raised.
!lgamma Compute log-gamma function (function )
erf Compute error function (function )
erfc Compute complementary error function (function )!X!
Cplusplus!double trunc  (     double x);
float truncf (      float x);
long double truncl (long double x);
Truncate value
Rounds x toward zero, returning the nearest integral value that is not larger in magnitude than x.
!trunc!x
Value to truncate.!The nearest integral value that is not larger in magnitude than x (as a floating-point value).
!floor Round down value (function )
ceil Round up value (function )
round Round to nearest (function )
rint Round to integral value (function )!X!
Cplusplus!Huge value
Macro constant that expands to a positive expression of type double.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VAL (HUGE_VAL or -HUGE_VAL) to indicate the sign of the result.!HUGE_VAL!X!X!X!X!
Cplusplus!Huge float value
Macro constant that expands to a positive expression of type float.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VALF (HUGE_VALF or -HUGE_VALF) to indicate the sign of the result.!HUGE_VALF!X!X!X!X!
Cplusplus!Huge long double value
Macro constant that expands to a positive expression of type long double.

A function returns this value when the result of a mathematical operation yields a value that is too large in magnitude to be representable with its return type. This is one of the possible range errors, and is signaled by setting errno to ERANGE.

Actually, functions may either return a positive or a negative HUGE_VALL (HUGE_VALL or -HUGE_VALL) to indicate the sign of the result.!HUGE_VALL!X!X!X!X!
Cplusplus!Infinity
Macro constant that expands to an expression of type float.

If the implementation supports infinity values, this is defined as the value that represents a positive or unsigned infinity. Otherwise, it is a positive constant that overflows at translation time.

This may be returned by a function that signals a range error by setting errno to ERANGE.!INFINITY!X!X!X!X!
Cplusplus!int
Error handling
Expands to an expression that identifies the error handling mechanism employed by the functions in the <cmath> header:

constant value description
MATH_ERRNO 1 errno is used to signal errors:
- On domain error: errno is set to EDOM.
- On range error (including pole error, overflow, and possibly underflow): errno is set to ERANGE.
MATH_ERREXCEPT 2 The proper C exception is raised:
- On domain error: FE_INVALID is raised.
- On pole error: FE_DIVBYZERO is raised.
- On overflow: FE_OVERFLOW is raised.
- On underflow: FE_UNDERFLOW may be raised.
MATH_ERRNO|MATH_ERREXCEPT 3 Both of the above

Both MATH_ERRNO and MATH_ERREXCEPT are macro constant expressions defined in <cmath> as 1 and 2 respectivelly.!math_errhandling!X!X!X!X!
Cplusplus!float
Not-A-Number
Macro constant that expands to an expression of type float that represents a NaN if the implementation supports quiet NaNs (otherwise, it is not defined).!NAN!X!X!nan Generate quiet NaN (function )
nanf Generate quiet NaN (float) (function )
isnan Is Not-A-Number (macro/function )!X!
Cplusplus!Floating-point type
Alias of one of the fundamental floating-point types at least as wide as double.

It is the type used by the implementation to evaluate values of type double, as determined by FLT_EVAL_METHOD:

FLT_EVAL_METHOD float_t double_t
0 float double
1 double double
2 long double long double
other implementation-defined implementation-defined
!double_t!X!X!X!X!
Cplusplus!Floating-point type
Alias of one of the fundamental floating-point types at least as wide as float.

It is the type used by the implementation to evaluate values of type float, as determined by FLT_EVAL_METHOD:

FLT_EVAL_METHOD float_t double_t
0 float double
1 double double
2 long double long double
other implementation-defined implementation-defined
!float_t!X!X!X!X!
Cplusplus!Type to hold information to restore calling environment
This is an array type capable of storing the information of a calling environment to be restored later.

This information is filled by calling macro setjmp and can be restored by calling function longjmp.!jmp_buf!X!X!setjmp Save calling environment for long jump (macro )
longjmp Long jump (function )!X!
Cplusplus!void longjmp (jmp_buf env, int val);
Long jump
Restores the environment to the state indicated by env, evaluating the setjmp expression that filled env as val.

The function never returns to the point where it has been invoked. Instead, the function transfers the control to the point where setjmp was last used to fill the env, and evaluates the whole expression as val (unless this is zero, in which case it evaluates as value of 1).

If env was not filled by a previous call to setjmp or if the function with such call has terminated execution, it causes undefined behavior.

In C++, the implementation may perform stack unwinding that destroys objects with automatic duration. If this invokes any non-trivial destructors, it causes undefined behavior.!longjmp!env
Object of type jmp_buf filled by a previous call to setjmp that contains information to restore the environment to that point.
val
Value to which the setjmp expression evaluates.
If this is zero, the expression evaluates as 1.!none (the function never returns).!setjmp Save calling environment for long jump (macro )
jmp_buf Type to hold information to restore calling environment (type )!X!
Cplusplus!int setjmp (jmp_buf env);
Save calling environment for long jump
This macro with functional form fills env with information about the current state of the calling environment in that point of code execution, so that it can be restored by a later call to longjmp.

Calling longjmp with the information stored in env restores this same state and returns the control to that same point (the call to setjmp), which is evaluated as a particular non-zero value.

The state of the calling environment includes the values of all accessible objects, except those of automatic duration local to the function which do not have volatile-qualified types and which change before the call to longjmp; these have indeterminate values.

The invocation of setjmp shall be an expression statement by itself, or be evaluated in a selection or iteration statement either as the (potentially negated) entire controlling expression or compared against an integer constant expression. Otherwise, it causes undefined behavior.!setjmp!env
Object of type jmp_buf where the environment information is stored.!This macro may return more than once: A first time, on its direct invocation; In this case it always returns zero.
When longjmp is called with the information set to env, the macro returns again; this time it returns the value passed to longjmp as second argument if this is different from zero, or 1 if it is zero.!longjmp Long jump (function )
jmp_buf Type to hold information to restore calling environment (type )!X!
Cplusplus!int raise (int sig);
Generates a signal
Sends signal sig to the current executing program.

The signal is handled as specified by function signal.
!raise!sig
The signal value to raise. The following macro constant expressions identify standard signal values:

macro signal
SIGABRT (Signal Abort) Abnormal termination, such as is initiated by the abort function.
SIGFPE (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
SIGILL (Signal Illegal Instruction) Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
SIGINT (Signal Interrupt) Interactive attention signal. Generally generated by the application user.
SIGSEGV (Signal Segmentation Violation) Invalid access to storage: When a program tries to read or write outside the memory it is allocated for it.
SIGTERM (Signal Terminate) Termination request sent to program.

Each library implentation may provide additional signal value macro constants to be used with this function.!Returns zero if successful, and a value different from zero otherwise.!signal Set function to handle signal (function )!X!
Cplusplus!void (*signal(int sig, void (*func)(int)))(int);
Set function to handle signal
Specifies a way to handle the signals with the signal number specified by sig.

Parameter func specifies one of the three ways in which a signal can be handled by a program:
Default handling (SIG_DFL): The signal is handled by the default action for that particular signal.
Ignore signal (SIG_IGN): The signal is ignored and the code execution will continue even if not meaningful.
Function handler: A specific function is defined to handle the signal.

Either SIG_DFL or SIG_IGN is set as the default signal handling behavior at program startup for each of the supported signals .
!signal!sig
The signal value to which a handling function is set. The following macro constant expressions identify standard signal values:

macro signal
SIGABRT (Signal Abort) Abnormal termination, such as is initiated by the abort function.
SIGFPE (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
SIGILL (Signal Illegal Instruction) Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
SIGINT (Signal Interrupt) Interactive attention signal. Generally generated by the application user.
SIGSEGV (Signal Segmentation Violation) Invalid access to storage: When a program tries to read or write outside the memory it has allocated.
SIGTERM (Signal Terminate) Termination request sent to program.

Each library implementation may provide additional signal value macro constants that can be used with this function.

Notice that not all running environments are required to generate automatic signals, not even in the specific cases described above, although all running environments must deliver signals generated by a explicit call to the raise function.
func
A pointer to a function. This may either be a function defined by the programmer or one of the following predefined functions:

SIG_DFL Default handling: The signal is handled by the default action for that particular signal.
SIG_IGN Ignore Signal: The signal is ignored.

If a function, it should follow the following prototype (with C linkage):
 
void handler_function (int parameter);
!The return type is the same as the type of parameter func.

If the request is successful, the function returns a pointer to the particular handler function which was in charge of handling this signal before the call, if any. Or either SIG_DFL or SIG_IGN if before the call the signal was being handled by the default handler or was being ignored, respectivelly.

If the function was not successful in registering the new signal handling procedure, it returns SIG_ERR and errno may be set to a positive value.
!raise Generates a signal (function )!X!
Cplusplus!Integral type
Integral type of an object that can be accessed as an atomic entity, even in the presence of asynchronous signals.!sig_atomic_t!X!X!X!X!
Cplusplus!type va_arg (va_list ap, type)
Retrieve next argument
This macro expands to an expression of type type with the value of the current argument in the variable arguments list identified by ap.

Each call to this macro modifies the state of ap so that the next call to this macro will expand to the argument that follows the one it evaluates to.

Notice that va_arg cannot determine the actual type of the argument passed to the function, but uses whatever type is passed as the type macro argument as its type.

Notice also that va_arg does not determine either whether the retrieved argument is the last argument passed to the function (or even if it is an element past the end of that list). The function should be designed in such a way that the number of parameters can be inferred in some way by the values of either the named parameters or the additional arguments already read.!va_arg!ap
Object of type va_list carrying information about the current retrieval state of a variable argument list. This object shall have been initialized by an initial call to va_start or va_copy and not have been released with va_end.
type
A type name. This type name is used as the type of the expression this macro expands to (i.e., its return type). 
For a type expression to be suitable for its use with va_arg, it must be such that type* produces a pointer to type.
The type shall be compatible with type of the extracted argument (as promoted according to the default argument promotions), or one be the unsigned version of the other, or one be a void pointer and the other some other pointer type.
!Returns the current additional argument as an expression of type type.!va_start Initialize a variable argument list (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )
vsprintf Write formatted data from variable argument list to string (function )!X!
Cplusplus!void va_copy (va_list dest, va_list src);
Copy variable argument list
Initializes dest as a copy of src (in its current state).

The next argument to be extracted from dest is the same as the one that would be extracted from src.

A function that invokes va_copy, shall also invoke va_end on dest before it returns.!va_copy!dest
Uninitialized object of type va_list.
After the call, it carries the information needed to retrieve the same additional arguments as src.
If src has already been passed as first argument to a previous call to va_start or va_copy, it shall be passed to va_end before calling this function.
src
Object of type va_list that already carries information to retrieve additional arguments with va_arg (i.e., it has already been passed as first argument to va_start or va_copy ans has not yet been released with va_end).!none!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )!X!
Cplusplus!void va_end (va_list ap);
End using variable argument list
Performs the appropriate actions to facilitate a normal return by a function that has used the va_list object ap to retrieve its additional arguments.

This macro should be invoked before the function returns whenever va_start has been invoked from that function.!va_end!ap
va_list object previously initialized by va_start or va_copy.!none!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_list Type to hold information about variable arguments (type )!X!
Cplusplus!void va_start (va_list ap, paramN);
Initialize a variable argument list
Initializes ap to retrieve the additional arguments after parameter paramN.

A function that invokes va_start, shall also invoke va_end before it returns.!va_start!ap
Uninitialized object of type va_list.
After the call, it carries the information needed to retrieve the additional arguments using va_arg.
If ap has already been passed as first argument to a previous call to va_start or va_copy, it shall be passed to va_end before calling this function.
paramN
Name of the last named parameter in the function definition. The arguments extracted by subsequent calls to va_arg are those after paramN.
CC++
The parameter shall not be a parameter declared with register storage class, with function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions.
!none!va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )
va_list Type to hold information about variable arguments (type )
vsprintf Write formatted data from variable argument list to string (function )!X!
Cplusplus!Type to hold information about variable arguments
This type is used as a parameter for the macros defined in <cstdarg> to retrieve the additional arguments of a function.

va_start initializes an object of this type in such a way that subsequent calls to va_arg sequentially retrieve the additional arguments passed to the function.

Before a function that has initialized a va_list object with va_start returns, the va_end macro shall be invoked.

The specifics of this type depend on the particular library implementation. Objects of this type shall only be used as argument for the va_start, va_arg, va_end and va_copy macros, or functions that use them, like the variable argument functions in <cstdio> (vprintf, vscanf, vsnprintf, vsprintf and vsscanf).!va_list!X!X!va_start Initialize a variable argument list (macro )
va_arg Retrieve next argument (macro )
va_end End using variable argument list (macro )!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X!
Cplusplus!offsetof (type,member)
Return member offset
This macro with functional form returns the offset value in bytes of member member in the data structure or union type type.

The value returned is an unsigned integral value of type size_t with the number of bytes between the specified member and the beginning of its structure.!offsetof!type
A type in which member is a valid member designator.
CC++98C++11
type shall be a structure or union type.
member
A member of type.!A value of type size_t with the offset value of member in type.!X!X!
Cplusplus!Type with widest scalar alignment
Alias of a POD type whose alignment requirement is at least as great as that of any possible scalar type, and whose alignment requirement is supported in every context.!max_align_t!X!X!X!X!
Cplusplus!typedef decltype(nullptr) nullptr_t;
Null pointer type (C++)
Type of the null pointer constant nullptr.

This type can only take one value: nullptr, which when converted to a pointer type takes the proper null pointer value.

Even though nullptr_t it is not a keyword, it identifies a distinct fundamental type: the type of nullptr. As such, it participates in overload resolution as a different type.

This type is only defined for C++ (since C++11).!nullptr_t!X!X!X!X!
Cplusplus!Result of pointer subtraction
Alias of one of the fundamental signed integer types.

It is a type able to represent the result of any valid pointer subtraction operation.

A pointer subtraction is only guaranteed to have a valid defined value for pointers to elements of the same array (or for the element just past the last in the array).!ptrdiff_t!X!X!X!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.!size_t!X!X!X!X!
Cplusplus!void abort (void);
Abort current process
Aborts the current process, producing an abnormal program termination.

The function raises the SIGABRT signal (as if raise(SIGABRT) was called). This, if uncaught, causes the program to terminate returning a platform-dependent unsuccessful termination error code to the host environment.

The program is terminated without destroying any object and without calling any of the functions passed to atexit or at_quick_exit.!abort!none!none (the function never returns).!exit Terminate calling process (function )
atexit Set function to be executed on exit (function )!X!
Cplusplus!int abs (int n);
Absolute value
Returns the absolute value of parameter n ( /n/ ).

In C++, this function is also overloaded in header <cmath> for floating-point types (see cmath abs), in header <complex> for complex numbers (see complex abs), and in header <valarray> for valarrays (see valarray abs).!abs!n
Integral value.!The absolute value of n.!labs Absolute value (function )
fabs Compute absolute value (function )
div Integral division (function )!X!
Cplusplus!int atexit (void (*func)(void));
Set function to be executed on exit
The function pointed by func is automatically called without arguments when the program terminates normally.

If more than one atexit function has been specified by different calls to this function, they are all executed in reverse order as a stack (i.e. the last function specified is the first to be executed at exit).

A single function can be registered to be executed at exit more than once.

If atexit is called after exit, the call may or may not succeed depending on the particular system and library implementation (unspecified behavior).

If a function registered with atexit throws an exception for which it does not provide a handler when called on termination, terminate is automatically called (C++).

Particular library implementations may impose a limit on the number of functions call that can be registered with atexit, but this cannot be less than 32 function calls.
!atexit!function
Function to be called. The function shall return no value and take no arguments.!A zero value is returned if the function was successfully registered.
If it failed, a non-zero value is returned.!exit Terminate calling process (function )
abort Abort current process (function )!X!
Cplusplus!Convert string to double
Parses the C string str, interpreting its content as a floating point number and returns its value as a double.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax resembling that of floating point literals (see below), and interprets them as a numerical value. The rest of the string after the last valid character is ignored and has no effect on the behavior of this function.
A valid floating point number for atof using the "C" locale is formed by an optional sign character (+ or -), followed by one of:
- A sequence of digits, optionally containing a decimal-point character (.), optionally followed by an exponent part (an e or E character followed by an optional sign and a sequence of digits).
- A 0x or 0X prefix, then a sequence of hexadecimal digits (as in isxdigit) optionally containing a period which separates the whole and fractional number parts. Optionally followed by a power of 2 exponent (a p or P character followed by an optional sign and a sequence of hexadecimal digits).
- INF or INFINITY (ignoring case).
- NAN or NANsequence (ignoring case), where sequence is a sequence of characters, where each character is either an alphanumeric character (as in isalnum) or the underscore character (_).

If the first sequence of non-whitespace characters in str does not form a valid floating-point number as just defined, or if no such sequence exists because either str is empty or contains only whitespace characters, no conversion is performed and the function returns 0.0.!atof!str
C-string beginning with the representation of a floating-point number.!On success, the function returns the converted floating point number as a double value.
If no valid conversion could be performed, the function returns zero (0.0).
If the converted value would be out of the range of representable values by a double, it causes undefined behavior. See strtod for a more robust cross-platform alternative when this is a possibility.!strtod Convert string to double (function )
atoi Convert string to integer (function )
atol Convert string to long integer (function )!X!
Cplusplus!int atoi (const char * str);
Convert string to integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type int.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed and zero is returned.!atoi!X!X!X!X!
Cplusplus!long int atol ( const char * str );
Convert string to long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long int.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed and zero is returned.
!atol!str
C-string containing the representation of an integral number.!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned.
If the converted value would be out of the range of representable values by a long int, it causes undefined behavior. See strtol for a more robust cross-platform alternative when this is a possibility.!atoi Convert string to integer (function )
atof Convert string to double (function )
strtol Convert string to long integer (function )!X!
Cplusplus!long long int atoll ( const char * str );
Convert string to long long integer
Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long long int.

This function operates like atol to interpret the string, but produces numbers of type long long int (see atol for details on the interpretation process).!atoll!str
C-string containing the representation of an integral number.!On success, the function returns the converted integral number as a long long int value.
If no valid conversion could be performed, a zero value is returned.
If the converted value would be out of the range of representable values by a long long int, it causes undefined behavior. See strtoll for a more robust cross-platform alternative when this is a possibility.!atoi
Convert string to integer (function )
atol
Convert string to long integer (function )
strtoll
Convert string to long long integer (function )!X!
Cplusplus!int at_quick_exit (void (*func)(void));
Set function to be executed on quick exit
The function pointed by func is automatically called (without arguments) when quick_exit is called.

If more than one at_quick_exit function has been specified by different calls to this function, they are all executed in reverse order.

If a function registered with at_quick_exit throws an exception for which it does not provide a handler while called by quick_exit, terminate is automatically called (C++).

Notice that the at_quick_exit stack of functions is separate from the atexit stack (and each is triggered by different circumstances), but the same function may be passed to both functions so that it is called in both cases.

Particular library implementations may impose a limit on the number of functions that can be registered with at_quick_exit, but this cannot be less than 32 functions.
!at_quick_exit!function
Function to be called. The function shall return no value and take no arguments.!A zero value is returned if the function was successfully registered.
If it failed, a non-zero value is returned.
!atexit
Set function to be executed on exit (function )
quick_exit
Terminate calling process quick (function )
abort
Abort current process (function )!X!
Cplusplus!void* bsearch (const void* key, const void* base,
               size_t num, size_t size,
               int (*compar)(const void*,const void*));
Binary search in array
Searches the given key in the array pointed by base (which is formed by num elements, each of size bytes), and returns a void* pointer to a matching element, if found.

To perform the search, the function performs a series of calls to compar with key as first argument and elements of the array pointed by base as second argument.

Because this function may be optimized to use a non-linear search algorithm (presumably a binary search), the elements that compare less than key using compar should precede those that compare equal, and these should precede those that compare greater. This requirement is fulfilled by any array ordered with the same criteria used by compar (as if sorted with qsort).!bsearch!key
Pointer to the object that serves as key for the search, type-casted to a void*.
base
Pointer to the first object of the array where the search is performed, type-casted to a void*.
num
Number of elements in the array pointed by base.
size_t is an unsigned integral type.
size
Size in bytes of each element in the array.
size_t is an unsigned integral type.
compar
Pointer to a function that compares two elements.
This function is called repeatedly by bsearch to compare key against individual elements in base. It shall follow the following prototype:
 
int compar (const void* pkey, const void* pelem);

Taking two pointers as arguments: the first is always key, and the second points to an element of the array (both type-casted to const void*). The function shall return (in a stable and transitive manner):
return value meaning
<0 The element pointed by pkey goes before the element pointed by pelem
0 The element pointed by pkey is equivalent to the element pointed by pelem
>0 The element pointed by pkey goes after the element pointed by pelem

For types that can be compared using regular relational operators, a general compar function may look like:

1
2
3
4
5
6
int compareMyType (const void * a, const void * b)
{
  if ( *(MyType*)a <  *(MyType*)b ) return -1;
  if ( *(MyType*)a == *(MyType*)b ) return 0;
  if ( *(MyType*)a >  *(MyType*)b ) return 1;
}
!A pointer to an entry in the array that matches the search key. If there are more than one matching elements (i.e., elements for which compar would return 0), this may point to any of them (not necessarily the first one).
If key is not found, a null pointer is returned. !qsort
Sort elements of array (function )!Unspecified, but binary searches are generally logarithmic in num, on average, calling compar approximately log2(num)+2 times.!
Cplusplus!void* calloc (size_t num, size_t size);
Allocate and zero-initialize array
Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits to zero.

The effective result is the allocation of a zero-initialized memory block of (num*size) bytes.

If size is zero, the return value depends on the particular library implementation (it may or may not be a null pointer), but the returned pointer shall not be dereferenced.!calloc!num
Number of elements to allocate.
size
Size of each element.

size_t is an unsigned integral type.!On success, a pointer to the memory block allocated by the function.
The type of this pointer is always void*, which can be cast to the desired type of data pointer in order to be dereferenceable.
If the function failed to allocate the requested block of memory, a null pointer is returned.!free
Deallocate memory block (function )
malloc
Allocate memory block (function )
realloc
Reallocate memory block (function )!X!
Cplusplus!div_t div (int numer, int denom);
Integral division
Returns the integral quotient and remainder of the division of numer by denom ( numer/denom ) as a structure of type div_t, ldiv_t or lldiv_t, which has two members: quot and rem.!div!numer
Numerator.
denom
Denominator.!The result is returned by value in a structure defined in <cstdlib>, which has two members. For div_t, these are, in either order:
1
1
int quot;   // quotient
int rem;    // remainder 
!ldiv
Integral division (function )!X!
Cplusplus!void exit (int status);
Terminate calling process
Terminates the process normally, performing the regular cleanup for terminating programs.

Normal program termination performs the following (in the same order):
Objects associated with the current thread with thread storage duration are destroyed (C++11 only).
Objects with static storage duration are destroyed (C++) and functions registered with atexit are called.
All C streams (open with functions in <cstdio>) are closed (and flushed, if buffered), and all files created with tmpfile are removed.
Control is returned to the host environment.

Note that objects with automatic storage are not destroyed by calling exit (C++).

If status is zero or EXIT_SUCCESS, a successful termination status is returned to the host environment.
If status is EXIT_FAILURE, an unsuccessful termination status is returned to the host environment.
Otherwise, the status returned depends on the system and library implementation.

For a similar function that does not perform the cleanup described above, see quick_exit.!exit!status
Status code.
If this is 0 or EXIT_SUCCESS, it indicates success.
If it is EXIT_FAILURE, it indicates failure.!none (the function never returns).!abort
Abort current process (function )
atexit
Set function to be executed on exit (function )!X!
Cplusplus!void free (void* ptr);
Deallocate memory block
A block of memory previously allocated by a call to malloc, calloc or realloc is deallocated, making it available again for further allocations.

If ptr does not point to a block of memory allocated with the above functions, it causes undefined behavior.

If ptr is a null pointer, the function does nothing.

Notice that this function does not change the value of ptr itself, hence it still points to the same (now invalid) location.!free!ptr
Pointer to a memory block previously allocated with malloc, calloc or realloc.!none!malloc
Allocate memory block (function )
calloc
Allocate and zero-initialize array (function )
realloc
Reallocate memory block (function )!X!
Cplusplus!char* getenv (const char* name);
Get environment string
Retrieves a C-string containing the value of the environment variable whose name is specified as argument. If the requested variable is not part of the environment list, the function returns a null pointer.

The pointer returned points to an internal memory block, whose content or validity may be altered by further calls to getenv (but not by other library functions).

The string pointed by the pointer returned by this function shall not be modified by the program. Some systems and library implementations may allow to change environmental variables with specific functions (putenv, setenv...), but such functionality is non-portable.
!getenv!name
C-string containing the name of the requested variable.
Depending on the platform, this may either be case sensitive or not.!A C-string with the value of the requested environment variable, or a null pointer if such environment variable does not exist.!system
Execute system command (function )!X!
Cplusplus!long int labs (long int n);
Absolute value
Returns the absolute value of parameter n ( /n/ ).

This is the long int version of abs.!labs!n
Integral value.!The absolute value of n.!abs
Absolute value (function )
fabs
Compute absolute value (function )
ldiv
Integral division (function )!X!
Cplusplus!ldiv_t ldiv (long int numer, long int denom);
Integral division
Returns the integral quotient and remainder of the division of numer by denom ( numer/denom ) as a structure of type ldiv_t, which has two members: quot and rem.!ldiv!numer
Numerator.
denom
Denominator.!The result is returned by value in a ldiv_t structure, which has two members (in either order):
1
2
long int quot;   // quotient
long int rem;    // remainder 
!div
Integral division (function )
lldiv
Integral division (function )
ldiv_t
Structure returned by ldiv (type )!X!
Cplusplus!long long int llabs (long long int n);
Absolute value
Returns the absolute value of parameter n ( /n/ ).

This is the long long int version of abs.!llabs!n
Integral value.!The absolute value of n.!abs
Absolute value (function )
labs
Absolute value (function )
fabs
Compute absolute value (function )
ldiv
Integral division (function )!X!
Cplusplus!lldiv_t lldiv (long long int numer, long long int denom);
Integral division
Returns the integral quotient and remainder of the division of numer by denom ( numer/denom ) as a structure of type lldiv_t, which has two members: quot and rem.!lldiv!numer
Numerator.
denom
Denominator.!The result is returned by value in a lldiv_t structure, which has two members (in either order):
1
2
long long int quot;   // quotient
long long int rem;    // remainder 
!div
Integral division (function )
ldiv
Integral division (function )
lldiv_t
Structure returned by lldiv (type )!X!
Cplusplus!void* malloc (size_t size);
Allocate memory block
Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.

The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.

If size is zero, the return value depends on the particular library implementation (it may or may not be a null pointer), but the returned pointer shall not be dereferenced.
!malloc!size
Size of the memory block, in bytes.
size_t is an unsigned integral type.!On success, a pointer to the memory block allocated by the function.
The type of this pointer is always void*, which can be cast to the desired type of data pointer in order to be dereferenceable.
If the function failed to allocate the requested block of memory, a null pointer is returned.!free
Deallocate memory block (function )
calloc
Allocate and zero-initialize array (function )
realloc
Reallocate memory block (function )!X!
Cplusplus!int mblen (const char* pmb, size_t max);
Get length of multibyte character
Returns the size of the multibyte character pointed by pmb, examining at most max bytes.

mblen has its own internal shift state, which is altered as necessary only by calls to this function. A call to the function with a null pointer as pmb resets the state (and returns whether multibyte characters are state-dependent).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.!mblen!pmb
Pointer to the first byte of a multibyte character.
Alternativelly, the function may be called with a null pointer, in which case the function resets its internal shift state to the initial value and returns whether multibyte characters use a state-dependent encoding.
max
Maximum number of bytes of pmb to consider for the multibyte character.
No more than MB_CUR_MAX characters are examined in any case.
size_t is an unsigned integral type.!If the argument passed as pmb is not a null pointer, the size in bytes of the character pointed by pmb is returned when it forms a valid multibyte character and is not the terminating null character. If it is the terminating null character, the function returns zero, and in the case they do not form a valid multibyte character, -1 is returned.

If the argument passed as pmb is a null pointer, the function returns a nonzero value if multibyte character encodings are state-dependent, and zero otherwise.
!mbtowc
Convert multibyte sequence to wide character (function )
wctomb
Convert wide character to multibyte sequence (function )
mbstowcs
Convert multibyte string to wide-character string (function )
wcstombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!size_t mbstowcs (wchar_t* dest, const char* src, size_t max);
Convert multibyte string to wide-character string
Translates the multibyte sequence pointed by src to the equivalent sequence of wide-characters (which is stored in the array pointed by dest), up until either max wide characters have been translated or until a null character is encountered in the multibyte sequence src (which is also translated and stored, but not counted in the length returned by the function).

If max characters are successfully translated, the resulting string stored in dest is not null-terminated.

The behavior of this function depends on the LC_CTYPE category of the selected C locale.
!mbstowcs!dest
Pointer to an array of wchar_t elements long enough to contain the resulting sequence (at most, max wide characters).
src
C-string with the multibyte characters to be interpreted.
The multibyte sequence shall begin in the initial shift state.
max
Maximum number of wchar_t characters to write to dest.
size_t is an unsigned integral type.!The number of wide characters written to dest, not including the eventual terminating null character.
If an invalid multibyte character is encountered, a value of (size_t)-1 is returned.
Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!mblen
Get length of multibyte character (function )
mbtowc
Convert multibyte sequence to wide character (function )
wcstombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!int mbtowc (wchar_t* pwc, const char* pmb, size_t max);
Convert multibyte sequence to wide character
The multibyte character pointed by pmb is converted to a value of type wchar_t and stored at the location pointed by pwc. The function returns the length in bytes of the multibyte character.

mbtowc has its own internal shift state, which is altered as necessary only by calls to this function. A call to the function with a null pointer as pmb resets the state (and returns whether multibyte characters are state-dependent).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.
!mbtowc!pwc
Pointer to an object of type wchar_t.
Alternativelly, this argument can be a null pointer, in which case the function does not store the wchar_t translation, but still returns the length in bytes of the multibyte character.
pmb
Pointer to the first byte of a multibyte character.
Alternativelly, this argument can be a null pointer, in which case the function resets its internal shift state to the initial value and returns whether multibyte characters have a state-dependent encoding.
max
Maximum number of bytes of pmb to consider for the multibyte character.
No more than MB_CUR_MAX characters are examined in any case.
size_t is an unsigned integral type.
!If the argument passed as pmb is not a null pointer, the size in bytes of the multibyte character pointed by pmb is returned when it forms a valid multibyte character and is not the terminating null character. If it is the terminating null character, the function returns zero, and in the case they do not form a valid multibyte character, -1 is returned.

If the argument passed as pmb is a null pointer, the function returns a nonzero value if multibyte character encodings are state-dependent, and zero otherwise.!mblen
Get length of multibyte character (function )
wctomb
Convert wide character to multibyte sequence (function )
mbstowcs
Convert multibyte string to wide-character string (function )
wcstombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!void qsort (void* base, size_t num, size_t size,
            int (*compar)(const void*,const void*));
Sort elements of array
Sorts the num elements of the array pointed by base, each element size bytes long, using the compar function to determine the order.

The sorting algorithm used by this function compares pairs of elements by calling the specified compar function with pointers to them as argument.

The function does not return any value, but modifies the content of the array pointed by base reordering its elements as defined by compar.

The order of equivalent elements is undefined.!qsort!base
Pointer to the first object of the array to be sorted, converted to a void*.
num
Number of elements in the array pointed by base.
size_t is an unsigned integral type.
size
Size in bytes of each element in the array.
size_t is an unsigned integral type.
compar
Pointer to a function that compares two elements.
This function is called repeatedly by qsort to compare two elements. It shall follow the following prototype:
 
int compar (const void* p1, const void* p2);

Taking two pointers as arguments (both converted to const void*). The function defines the order of the elements by returning (in a stable and transitive manner):
return value meaning
<0 The element pointed by p1 goes before the element pointed by p2
0 The element pointed by p1 is equivalent to the element pointed by p2
>0 The element pointed by p1 goes after the element pointed by p2

For types that can be compared using regular relational operators, a general compar function may look like:

1
2
3
4
5
6
int compareMyType (const void * a, const void * b)
{
  if ( *(MyType*)a <  *(MyType*)b ) return -1;
  if ( *(MyType*)a == *(MyType*)b ) return 0;
  if ( *(MyType*)a >  *(MyType*)b ) return 1;
}
!none!bsearch
Binary search in array (function )!Unspecified, but quicksorts are generally linearithmic in num, on average, calling compar approximately num*log2(num) times.!
Cplusplus!Noreturn void quick_exit (int status);
Terminate calling process quick
Terminates the process normally by returning control to the host environment after calling all functions registered using at_quick_exit.

No additional cleanup tasks are performed: No object destructors are called. Although whether C streams are closed and/or flushed, and files open with tmpfile are removed depends on the particular system or library implementation.

If status is zero or EXIT_SUCCESS, a successful termination status is returned to the host environment.
If status is EXIT_FAILURE, an unsuccessful termination status is returned to the host environment.
Otherwise, the status returned depends on the system and library implementation.

If a program calls both exit and quick_exit, or quick_exit more than once, it causes undefined behavior.!quick_exit!status
Status code.
If this is 0 or EXIT_SUCCESS, it indicates success.
If it is EXIT_FAILURE, it indicates failure.
!none (the function never returns).!at_quick_exit
Set function to be executed on quick exit (function )
exit
Terminate calling process (function )
abort
Abort current process (function )!X!
Cplusplus!int rand (void);
Generate random number
Returns a pseudo-random integral number in the range between 0 and RAND_MAX.

This number is generated by an algorithm that returns a sequence of apparently non-related numbers each time it is called. This algorithm uses a seed to generate the series, which should be initialized to some distinctive value using function srand.

RAND_MAX is a constant defined in <cstdlib>.

A typical way to generate trivial pseudo-random numbers in a determined range using rand is to use the modulo of the returned value by the range span and add the initial value of the range:

1
2
3
v1 = rand() % 100;         // v1 in the range 0 to 99
v2 = rand() % 100 + 1;     // v2 in the range 1 to 100
v3 = rand() % 30 + 1985;   // v3 in the range 1985-2014 


Notice though that this modulo operation does not generate uniformly distributed random numbers in the span (since in most cases this operation makes lower numbers slightly more likely).

C++ supports a wide range of powerful tools to generate random and pseudo-random numbers (see <random> for more info).!rand!(none) !An integer value between 0 and RAND_MAX.!srand
Initialize random number generator (function )!In C, the generation algorithm used by rand is guaranteed to only be advanced by calls to this function. In C++, this constraint is relaxed, and a library implementation is allowed to advance the generator on other circumstances (such as calls to elements of <random>).
!
Cplusplus!void* realloc (void* ptr, size_t size);
Reallocate memory block
Changes the size of the memory block pointed to by ptr.

The function may move the memory block to a new location (whose address is returned by the function).

The content of the memory block is preserved up to the lesser of the new and old sizes, even if the block is moved to a new location. If the new size is larger, the value of the newly allocated portion is indeterminate.

In case that ptr is a null pointer, the function behaves like malloc, assigning a new block of size bytes and returning a pointer to its beginning.

C90 (C++98)C99/C11 (C++11)
Otherwise, if size is zero, the memory previously allocated at ptr is deallocated as if a call to free was made, and a null pointer is returned.

If the function fails to allocate the requested block of memory, a null pointer is returned, and the memory block pointed to by argument ptr is not deallocated (it is still valid, and with its contents unchanged).!realloc!ptr
Pointer to a memory block previously allocated with malloc, calloc or realloc.
Alternatively, this can be a null pointer, in which case a new block is allocated (as if malloc was called).
size
New size for the memory block, in bytes.
size_t is an unsigned integral type.!A pointer to the reallocated memory block, which may be either the same as ptr or a new location.
The type of this pointer is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.

A null-pointer indicates that the function failed to allocate storage, and thus the block pointed by ptr was not modified.!free
Deallocate memory block (function )
calloc
Allocate and zero-initialize array (function )
malloc
Allocate memory block (function )!X!
Cplusplus!void srand (unsigned int seed);
Initialize random number generator
The pseudo-random number generator is initialized using the argument passed as seed.

For every different seed value used in a call to srand, the pseudo-random number generator can be expected to generate a different succession of results in the subsequent calls to rand.

Two different initializations with the same seed will generate the same succession of results in subsequent calls to rand.

If seed is set to 1, the generator is reinitialized to its initial value and produces the same values as before any call to rand or srand.

In order to generate random-like numbers, srand is usually initialized to some distinctive runtime value, like the value returned by function time (declared in header <ctime>). This is distinctive enough for most trivial randomization needs.!srand!seed
An integer value to be used as seed by the pseudo-random number generator algorithm.!none !rand
Generate random number (function )!X!
Cplusplus!double strtod (const char* str, char** endptr);
Convert string to double
Parses the C-string str interpreting its content as a floating point number and returns its value as a double. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax resembling that of floating point literals (see below), and interprets them as a numerical value. A pointer to the rest of the string after the last valid character is stored in the object pointed by endptr.

A valid floating point number for strtod using the "C" locale is formed by an optional sign character (+ or -), followed by one of:
- A sequence of digits, optionally containing a decimal-point character (.), optionally followed by an exponent part (an e or E character followed by an optional sign and a sequence of digits).
- A 0x or 0X prefix, then a sequence of hexadecimal digits (as in isxdigit) optionally containing a period which separates the whole and fractional number parts. Optionally followed by a power of 2 exponent (a p or P character followed by an optional sign and a sequence of hexadecimal digits).
- INF or INFINITY (ignoring case).
- NAN or NANsequence (ignoring case), where sequence is a sequence of characters, where each character is either an alphanumeric character (as in isalnum) or the underscore character (_).

If the first sequence of non-whitespace characters in str does not form a valid floating-point number as just described, or if no such sequence exists because either str is empty or contains only whitespace characters, no conversion is performed and the function returns a zero value.!strtod!str
C-string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted floating point number as a value of type double.
If no valid conversion could be performed, the function returns zero (0.0).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VAL is returned, and errno is set to ERANGE.

If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).!atof
Convert string to double (function )
strtol
Convert string to long integer (function )
strtoul
Convert string to unsigned long integer (function )!X!
Cplusplus!float strtof (const char* str, char** endptr);
Convert string to float
Parses the C-string str interpreting its content as a floating point number and returns its value as a float. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

The function first discards as many whitespace characters (as in isspace) as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax resembling that of floating point literals (see below), and interprets them as a numerical value. A pointer to the rest of the string after the last valid character is stored in the object pointed by endptr.

A valid floating point number for strtof using the "C" locale is formed by an optional sign character (+ or -), followed by one of:
A sequence of digits, optionally containing a decimal-point character (.), optionally followed by an exponent part (an e or E character followed by an optional sign and a sequence of digits).
A 0x or 0X prefix, then a sequence of hexadecimal digits (as in isxdigit) optionally containing a period which separates the whole and fractional number parts. Optionally followed by a power of 2 exponent (a p or P character followed by an optional sign and a sequence of hexadecimal digits).
INF or INFINITY (ignoring case).
NAN or NANsequence (ignoring case), where sequence is a sequence of characters, where each character is either an alphanumeric character (as in isalnum) or the underscore character (_).

If the first sequence of non-whitespace characters in str does not form a valid floating-point number as just described, or if no such sequence exists because either str is empty or contains only whitespace characters, no conversion is performed and the function returns 0.0F.
!strtof!str
C-string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted floating point number as a value of type float.
If no valid conversion could be performed, the function returns zero (0.0F).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VALF is returned, and errno is set to ERANGE.
If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).!atof
Convert string to double (function )
strtod
Convert string to double (function )
strtol
Convert string to long integer (function )!X!
Cplusplus!long int strtol (const char* str, char** endptr, int base);
Convert string to long integer
Parses the C-string str interpreting its content as an integral number of the specified base, which is returned as a long int value. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes as many characters as possible that are valid following a syntax that depends on the base parameter, and interprets them as a numerical value. Finally, a pointer to the first character following the integer representation in str is stored in the object pointed by endptr.

If the value of base is zero, the syntax expected is similar to that of integer constants, which is formed by a succession of:
An optional sign character (+ or -)
An optional prefix indicating octal or hexadecimal base ("0" or "0x"/"0X" respectively)
A sequence of decimal digits (if no base prefix was specified) or either octal or hexadecimal digits if a specific prefix is present

If the base value is between 2 and 36, the format expected for the integral number is a succession of any of the valid digits and/or letters needed to represent integers of the specified radix (starting from '0' and up to 'z'/'Z' for radix 36). The sequence may optionally be preceded by a sign (either + or -) and, if base is 16, an optional "0x" or "0X" prefix.

If the first sequence of non-whitespace characters in str is not a valid integral number as defined above, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

For locales other than the "C" locale, additional subject sequence forms may be accepted.
!strtol!str
C-string beginning with the representation of an integral number.
endptr
Reference to an object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
base
Numerical base (radix) that determines the valid characters and their interpretation.
If this is 0, the base used is determined by the format in the sequence (see above).!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned (0L).
If the value read is out of the range of representable values by a long int, the function returns LONG_MAX or LONG_MIN (defined in <climits>), and errno is set to ERANGE.!atol
Convert string to long integer (function )
strtoul
Convert string to unsigned long integer (function )
strtod
Convert string to double (function )!X!
Cplusplus!long double strtold (const char* str, char** endptr);
Convert string to long double
Parses the C string str interpreting its content as a floating point number and returns its value as a long double. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This function operates like strtod to interpret the string, but produces numbers of type long double (see strtod for details on the interpretation process).!strtold!str
C string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted floating point number as a value of type long double.
If no valid conversion could be performed, the function returns zero (0.0L).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VALL is returned, and errno is set to ERANGE.
If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).!atof
Convert string to double (function )
strtod
Convert string to double (function )
strtol
Convert string to long integer (function )!X!
Cplusplus!long long int strtoll (const char* str, char** endptr, int base);
Convert string to long long integer
Parses the C-string str interpreting its content as an integral number of the specified base, which is returned as a value of type long long int. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This function operates like strtol to interpret the string, but produces numbers of type long long int (see strtol for details on the interpretation process).!strtoll!str
C-string beginning with the representation of an integral number.
endptr
Reference to an object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
base
Numerical base (radix) that determines the valid characters and their interpretation.
If this is 0, the base used is determined by the format in the sequence (see strtol for details).!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned (0LL).
If the value read is out of the range of representable values by a long long int, the function returns LLONG_MAX or LLONG_MIN (defined in <climits>), and errno is set to ERANGE.!strtol
Convert string to long integer (function )
atol
Convert string to long integer (function )
strtoull
Convert string to unsigned long long integer (function )
strtod
Convert string to double (function )!X!
Cplusplus!unsigned long int strtoul (const char* str, char** endptr, int base);
Convert string to unsigned long integer
Parses the C-string str, interpreting its content as an integral number of the specified base, which is returned as an value of type unsigned long int.

This function operates like strtol to interpret the string, but produces numbers of type unsigned long int (see strtol for details on the interpretation process).!strtoul!str
C-string containing the representation of an integral number.
endptr
Reference to an object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
base
Numerical base (radix) that determines the valid characters and their interpretation.
If this is 0, the base used is determined by the format in the sequence (see strtol for details).!On success, the function returns the converted integral number as an unsigned long int value.
If no valid conversion could be performed, a zero value is returned.
If the value read is out of the range of representable values by an unsigned long int, the function returns ULONG_MAX (defined in <climits>), and errno is set to ERANGE.!atol
Convert string to long integer (function )
strtol
Convert string to long integer (function )
strtod
Convert string to double (function )!X!
Cplusplus!unsigned long long int strtoull (const char* str, char** endptr, int base);
Convert string to unsigned long long integer
Parses the C-string str interpreting its content as an integral number of the specified base, which is returned as a value of type unsigned long long int. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This function operates like strtol to interpret the string, but produces numbers of type unsigned long long int (see strtol for details on the interpretation process).!strtoull!str
C-string beginning with the representation of an integral number.
endptr
Reference to an object of type char*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
base
Numerical base (radix) that determines the valid characters and their interpretation.
If this is 0, the base used is determined by the format in the sequence (see strtol for details).!On success, the function returns the converted integral number as an unsigned long long int value.
If no valid conversion could be performed, a zero value is returned (0ULL).
If the value read is out of the range of representable values by an unsigned long long int, the function returns ULLONG_MAX (defined in <climits>), and errno is set to ERANGE.!strtoul
Convert string to unsigned long integer (function )
atol
Convert string to long integer (function )
strtoll
Convert string to long long integer (function )
strtod
Convert string to double (function )!X!
Cplusplus!int system (const char* command);
Execute system command
Invokes the command processor to execute a command.

If command is a null pointer, the function only checks whether a command processor is available through this function, without invoking any command.

The effects of invoking a command depend on the system and library implementation, and may cause a program to behave in a non-standard manner or to terminate.!system!command
C-string containing the system command to be executed.
Or, alternatively, a null pointer, to check for a command processor.!If command is a null pointer, the function returns a non-zero value in case a command processor is available and a zero value if it is not.

If command is not a null pointer, the value returned depends on the system and library implementations, but it is generally expected to be the status code returned by the called command, if supported.!exit
Terminate calling process (function )
getenv
Get environment string (function )!X!
Cplusplus!size_t wcstombs (char* dest, const wchar_t* src, size_t max);
Convert wide-character string to multibyte string
Translates wide characters from the sequence pointed by src to the multibyte equivalent sequence (which is stored at the array pointed by dest), up until either max bytes have been translated or until a wide characters translates into a null character.

If max bytes are successfully translated, the resulting string stored in dest is not null-terminated.

The resulting multibyte sequence begins in the initial shift state (if any).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.!wcstombs!dest
Pointer to an array of char elements long enough to contain the resulting sequence (at most, max bytes).
src
C wide string to be translated.
max
Maximum number of bytes to be written to dest.
size_t is an unsigned integral type.!The number of bytes written to dest, not including the eventual ending null-character.
If a wide character that does not correspond to a valid multibyte character is encountered, a (size_t)-1 value is returned.
Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!mblen
Get length of multibyte character (function )
wctomb
Convert wide character to multibyte sequence (function )
mbstowcs
Convert multibyte string to wide-character string (function )!X!
Cplusplus!int wctomb (char* pmb, wchar_t wc);
Convert wide character to multibyte sequence
The wide character wc is translated to its multibyte equivalent and stored in the array pointed by pmb. The function returns the length in bytes of the equivalent multibyte sequence pointed by pmb after the call.

wctomb has its own internal shift state, which is altered as necessary only by calls to this function. A call to the function with a null pointer as pmb resets the state (and returns whether multibyte sequences are state-dependent).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.
!wctomb!pmb
Pointer to an array large enough to hold a multibyte sequence.
The maximum length of a multibyte sequence for a character in the current locale is MB_CUR_MAX bytes.
Alternativelly, the function may be called with a null pointer, in which case the function resets its internal shift state to the initial value and returns whether multibyte sequences use a state-dependent encoding.
wc
Wide character of type wchar_t.!If the argument passed as pmb is not a null pointer, the size in bytes of the character written to pmb is returned. If there is no character correspondence, -1 is returned.

If the argument passed as pmb is a null pointer, the function returns a nonzero value if multibyte character encodings are state-dependent, and zero otherwise.!mblen
Get length of multibyte character (function )
mbtowc
Convert multibyte sequence to wide character (function )
mbstowcs
Convert multibyte string to wide-character string (function )
wcstombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!void _Exit (int status);
Terminate calling process
Terminates the process normally by returning control to the host environment, but without performing any of the regular cleanup tasks for terminating processes (as function exit does).

No object destructors, nor functions registered by atexit or at_quick_exit are called.

Whether C streams are closed and/or flushed, and files open with tmpfile are removed depends on the particular system or library implementation.

If status is zero or EXIT_SUCCESS, a successful termination status is returned to the host environment.
If status is EXIT_FAILURE, an unsuccessful termination status is returned to the host environment.
Otherwise, the status returned depends on the system and library implementation.!_Exit!status
Status code.
If this is 0 or EXIT_SUCCESS, it indicates success.
If it is EXIT_FAILURE, it indicates failure.!none (the function never returns).!exit
Terminate calling process (function )
quick_exit
Terminate calling process quick (function )
abort
Abort current process (function )!X!
Cplusplus!char *  itoa ( int value, char * str, int base );
Convert integer to string (non-standard function)
Converts an integer value to a null-terminated string using the specified base and stores the result in the array given by str parameter.

If base is 10 and value is negative, the resulting string is preceded with a minus sign (-). With any other base, value is always considered unsigned.

str should be an array long enough to contain any possible value: (sizeof(int)*8+1) for radix=2, i.e. 17 bytes in 16-bits platforms and 33 in 32-bits platforms.!itoa!value
Value to be converted to a string.
str
Array in memory where to store the resulting null-terminated string.
base
Numerical base used to represent the value as a string, between 2 and 36, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.!A pointer to the resulting null-terminated string, same as parameter str.
!sprintf
Write formatted data to string (function )
atoi
Convert string to integer (function )
atol
Convert string to long integer (function )!X!
Cplusplus!Structure returned by div
Structure to represent the result value of an integral division performed by function div.

It has two int members: quot and rem, defined in either order. A possible definition could be:
1
2
3
4
typedef struct {
  int quot;
  int rem;
} div_t;
!div_t!X!X!ldiv_t
Structure returned by ldiv (type )
div
Integral division (function )!X!
Cplusplus!Structure returned by ldiv
Structure to represent the result value of an integral division performed by function ldiv (and, in C++, possibly also by div).

It has two data members of type long int: quot and rem, defined in either order. A possible definition could be:
1
2
3
4
typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

!ldiv_t!X!X!div_t
Structure returned by div (type )
div
Integral division (function )
ldiv
Integral division (function )!X!
Cplusplus!Structure returned by lldiv
Structure to represent the result value of an integral division performed by function lldiv (and, in C++, possibly also by div).

It has two data members of type long long int: quot and rem, defined in either order. A possible definition could be:
1
2
3
4
typedef struct {
  long long quot;
  long long rem;
} lldiv_t;
!lldiv_t!X!X!div_t
Structure returned by div (type )
div
Integral division (function )
lldiv
Integral division (function )!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.

In <cstdlib>, it is used as the type of some parameters in the functions bsearch, qsort, calloc, malloc, realloc, mblen, mbtowc, mbstowcs and wcstombs, and in the case of mbstowcs and wcstombs also as its returning type.
In all cases it is used as a type to represent the length or count in bytes of a specific buffer or string.!size_t!X!X!X!X!
Cplusplus!Failure termination code
This macro expands to a system-dependent integral expression that, when used as the argument for function exit, signifies that the application failed.

The opposite meaning can be specified with EXIT_SUCCESS.!EXIT_FAILURE!X!X!X!X!
Cplusplus!Success termination code
This macro expands to a system-dependent integral expression that, when used as the argument for function exit, signifies that the application was successful.

The opposite meaning can be specified with EXIT_FAILURE.!EXIT_SUCCESS!X!X!X!X!
Cplusplus!Maximum size of multibyte characters
This macro expands to a positive integer expression of type size_t, the value of which is the maximum number of bytes in a multibyte character with the current locale (category LC_CTYPE).

Its value is never greater than MB_LEN_MAX (see <climits>).!MB_CUR_MAX!X!X!X!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.


A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X!
Cplusplus!Maximum value returned by rand
This macro expands to an integral constant expression whose value is the maximum value returned by the rand function.

This value is library-dependent, but is guaranteed to be at least 32767 on any standard library implementation.!RAND_MAX!X!X!X!X!
Cplusplus!const void * memchr ( const void * ptr, int value, size_t num );
      void * memchr (       void * ptr, int value, size_t num );
Locate character in block of memory
Searches within the first num bytes of the block of memory pointed by ptr for the first occurrence of value (interpreted as an unsigned char), and returns a pointer to it.

Both value and each of the bytes checked on the the ptr array are interpreted as unsigned char for the comparison.!memchr!ptr
Pointer to the block of memory where the search is performed.
value
Value to be located. The value is passed as an int, but the function performs a byte per byte search using the unsigned char conversion of this value.
num
Number of bytes to be analyzed.
size_t is an unsigned integral type.!A pointer to the first occurrence of value in the block of memory pointed by ptr.
If the value is not found, the function returns a null pointer.!memcmp
Compare two blocks of memory (function )
strchr
Locate first occurrence of character in string (function )
strrchr
Locate last occurrence of character in string (function )!X!
Cplusplus!int memcmp ( const void * ptr1, const void * ptr2, size_t num );
Compare two blocks of memory
Compares the first num bytes of the block of memory pointed by ptr1 to the first num bytes pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not.

Notice that, unlike strcmp, the function does not stop comparing after finding a null character.!memcmp!ptr1
Pointer to block of memory.
ptr2
Pointer to block of memory.
num
Number of bytes to compare.!Returns an integral value indicating the relationship between the content of the memory blocks:
A zero value indicates that the contents of both memory blocks are equal.
A value greater than zero indicates that the first byte that does not match in both memory blocks has a greater value in ptr1 than in ptr2 as if evaluated as unsigned char values; And a value less than zero indicates the opposite.!strcmp
Compare two strings (function )
memchr
Locate character in block of memory (function )
memcpy
Copy block of memory (function )
memset
Fill block of memory (function )
strncmp
Compare characters of two strings (function )!X!
Cplusplus!void * memcpy ( void * destination, const void * source, size_t num );
Copy block of memory
Copies the values of num bytes from the location pointed by source directly to the memory block pointed by destination.

The underlying type of the objects pointed by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.

The function does not check for any terminating null character in source - it always copies exactly num bytes.

To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).!memcpy!destination
Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.
source
Pointer to the source of data to be copied, type-casted to a pointer of type const void*.
num
Number of bytes to copy.
size_t is an unsigned integral type.!destination is returned.!memmove
Move block of memory (function )
memchr
Locate character in block of memory (function )
memcmp
Compare two blocks of memory (function )
memset
Fill block of memory (function )
strncpy
Copy characters from string (function )!X!
Cplusplus!void * memmove ( void * destination, const void * source, size_t num );
Move block of memory
Copies the values of num bytes from the location pointed by source to the memory block pointed by destination. Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap.

The underlying type of the objects pointed by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.

The function does not check for any terminating null character in source - it always copies exactly num bytes.

To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num bytes.!memmove!destination
Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.
source
Pointer to the source of data to be copied, type-casted to a pointer of type const void*.
num
Number of bytes to copy.
size_t is an unsigned integral type.
!destination is returned.!memcpy
Copy block of memory (function )
memchr
Locate character in block of memory (function )
memcmp
Compare two blocks of memory (function )
memset
Fill block of memory (function )
strncpy
Copy characters from string (function )!X!
Cplusplus!void * memset ( void * ptr, int value, size_t num );
Fill block of memory
Sets the first num bytes of the block of memory pointed by ptr to the specified value (interpreted as an unsigned char).!memset!ptr
Pointer to the block of memory to fill.
value
Value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value.
num
Number of bytes to be set to the value.
size_t is an unsigned integral type.!ptr is returned.!memcpy
Copy block of memory (function )
strncpy
Copy characters from string (function )
memcmp
Compare two blocks of memory (function )!X!
Cplusplus!char * strcat ( char * destination, const char * source );
Concatenate strings
Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination.

destination and source shall not overlap.!strcat!destination
Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.
source
C string to be appended. This should not overlap destination.!destination is returned.!strncat
Append characters from string (function )
strcpy
Copy string (function )
memcpy
Copy block of memory (function )!X!
Cplusplus!const char * strchr ( const char * str, int character );
      char * strchr (       char * str, int character );
Locate first occurrence of character in string
Returns a pointer to the first occurrence of character in the C string str.

The terminating null-character is considered part of the C string. Therefore, it can also be located in order to retrieve a pointer to the end of a string.!strchr!str
C string.
character
Character to be located. It is passed as its int promotion, but it is internally converted back to char for the comparison.!A pointer to the first occurrence of character in str.
If the character is not found, the function returns a null pointer.!strrchr
Locate last occurrence of character in string (function )
memchr
Locate character in block of memory (function )
strpbrk
Locate characters in string (function )!X!
Cplusplus!int strcmp ( const char * str1, const char * str2 );
Compare two strings
Compares the C string str1 to the C string str2.

This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.

This function performs a binary comparison of the characters. For a function that takes into account locale-specific rules, see strcoll.!strcmp!str1
C string to be compared.
str2
C string to be compared.!Returns an integral value indicating the relationship between the strings:
A zero value indicates that both strings are equal.
A value greater than zero indicates that the first character that does not match has a greater value in str1 than in str2; And a value less than zero indicates the opposite.!strncmp
Compare characters of two strings (function )
memcmp
Compare two blocks of memory (function )
strrchr
Locate last occurrence of character in string (function )
strspn
Get span of character set in string (function )!X!
Cplusplus!int strcoll ( const char * str1, const char * str2 );
Compare two strings using locale
Compares the C string str1 to the C string str2, both interpreted appropriately according to the LC_COLLATE category of the C locale currently selected.

This function starts comparing the first character of each string. If they are equal to each other continues with the following pair until the characters differ or until a null-character signaling the end of a string is reached.

The behavior of this function depends on the LC_COLLATE category of the selected C locale.!strcoll!str1
C string to be compared.
str2
C string to be compared.!Returns an integral value indicating the relationship between the strings:
A zero value indicates that both strings are equal.
A value greater than zero indicates that the first character that does not match has a greater value in str1 than in str2; And a value less than zero indicates the opposite.!strcmp
Compare two strings (function )
strncmp
Compare characters of two strings (function )
memcmp
Compare two blocks of memory (function )!X!
Cplusplus!char * strcpy ( char * destination, const char * source );
Copy string
Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point).

To avoid overflows, the size of the array pointed by destination shall be long enough to contain the same C string as source (including the terminating null character), and should not overlap in memory with source.!strcpy!destination
Pointer to the destination array where the content is to be copied.
source
C string to be copied.!destination is returned.!strncpy
Copy characters from string (function )
memcpy
Copy block of memory (function )
memmove
Move block of memory (function )
memchr
Locate character in block of memory (function )
memcmp
Compare two blocks of memory (function )
memset
Fill block of memory (function )!X!
Cplusplus!size_t strcspn ( const char * str1, const char * str2 );
Get span until character in string
Scans str1 for the first occurrence of any of the characters that are part of str2, returning the number of characters of str1 read before this first occurrence.

The search includes the terminating null-characters. Therefore, the function will return the length of str1 if none of the characters of str2 are found in str1.!strcspn!str1
C string to be scanned.
str2
C string containing the characters to match.
!The length of the initial part of str1 not containing any of the characters that are part of str2.
This is the length of str1 if none of the characters in str2 are found in str1.
size_t is an unsigned integral type.!strpbrk
Locate characters in string (function )
strspn
Get span of character set in string (function )
strstr
Locate substring (function )
strncmp
Compare characters of two strings (function )!X!
Cplusplus!char * strerror ( int errnum );
Get pointer to error message string
Interprets the value of errnum, generating a string with a message that describes the error condition as if set to errno by a function of the library.

The returned pointer points to a statically allocated string, which shall not be modified by the program. Further calls to this function may overwrite its content (particular library implementations are not required to avoid data races).

The error strings produced by strerror may be specific to each system and library implementation.!strerror!errnum
Error number.!A pointer to the error string describing error errnum.!errno
Last error number (macro )
perror
Print error message (function )!X!
Cplusplus!size_t strlen ( const char * str );
Get string length
Returns the length of the C string str.

The length of a C string is determined by the terminating null-character: A C string is as long as the number of characters between the beginning of the string and the terminating null character (without including the terminating null character itself).

This should not be confused with the size of the array that holds the string. For example:

char mystr[100]="test string"; 

defines an array of characters with a size of 100 chars, but the C string with which mystr has been initialized has a length of only 11 characters. Therefore, while sizeof(mystr) evaluates to 100, strlen(mystr) returns 11.

In C++, char_traits::length implements the same behavior.!strlen!str
C string.!The length of string. !strcmp
Compare two strings (function )
strchr
Locate first occurrence of character in string (function )
strrchr
Locate last occurrence of character in string (function )!X!
Cplusplus!char * strncat ( char * destination, const char * source, size_t num );
Append characters from string
Appends the first num characters of source to destination, plus a terminating null-character.

If the length of the C string in source is less than num, only the content up to the terminating null-character is copied.!strncat!destination
Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string, including the additional null-character.
source
C string to be appended.
num
Maximum number of characters to be appended.
size_t is an unsigned integral type.!destination is returned.!strcat
Concatenate strings (function )
strncpy
Copy characters from string (function )
memcpy
Copy block of memory (function )!X!
Cplusplus!int strncmp ( const char * str1, const char * str2, size_t num );
Compare characters of two strings
Compares up to num characters of the C string str1 to those of the C string str2.
This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ, until a terminating null-character is reached, or until num characters match in both strings, whichever happens first.
!strncmp!str1
C string to be compared.
str2
C string to be compared.
num
Maximum number of characters to compare.
size_t is an unsigned integral type.!Returns an integral value indicating the relationship between the strings:
A zero value indicates that the characters compared in both strings form the same string.
A value greater than zero indicates that the first character that does not match has a greater value in str1 than in str2; And a value less than zero indicates the opposite.!strcmp
Compare two strings (function )
memcmp
Compare two blocks of memory (function )
strrchr
Locate last occurrence of character in string (function )
strspn
Get span of character set in string (function )!X!
Cplusplus!char * strncpy ( char * destination, const char * source, size_t num );
Copy characters from string
Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a null-character) is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it.

No null-character is implicitly appended at the end of destination if source is longer than num. Thus, in this case, destination shall not be considered a null terminated C string (reading it as such would overflow).

destination and source shall not overlap (see memmove for a safer alternative when overlapping).!strncpy!destination
Pointer to the destination array where the content is to be copied.
source
C string to be copied.
num
Maximum number of characters to be copied from source.
size_t is an unsigned integral type.!destination is returned.!strcpy
Copy string (function )
memcpy
Copy block of memory (function )
memmove
Move block of memory (function )
memchr
Locate character in block of memory (function )
memcmp
Compare two blocks of memory (function )
memset
Fill block of memory (function )!X!
Cplusplus!const char * strpbrk ( const char * str1, const char * str2 );
      char * strpbrk (       char * str1, const char * str2 );
Locate characters in string
Returns a pointer to the first occurrence in str1 of any of the characters that are part of str2, or a null pointer if there are no matches.

The search does not include the terminating null-characters of either strings, but ends there.!strpbrk!str1
C string to be scanned.
str2
C string containing the characters to match.!A pointer to the first occurrence in str1 of any of the characters that are part of str2, or a null pointer if none of the characters of str2 is found in str1 before the terminating null-character.
If none of the characters of str2 is present in str1, a null pointer is returned.!strcspn
Get span until character in string (function )
strchr
Locate first occurrence of character in string (function )
strrchr
Locate last occurrence of character in string (function )
memchr
Locate character in block of memory (function )!X!
Cplusplus!const char * strrchr ( const char * str, int character );
      char * strrchr (       char * str, int character );
Locate last occurrence of character in string
Returns a pointer to the last occurrence of character in the C string str.

The terminating null-character is considered part of the C string. Therefore, it can also be located to retrieve a pointer to the end of a string.!strrchr!str
C string.
character
Character to be located. It is passed as its int promotion, but it is internally converted back to char.
!A pointer to the last occurrence of character in str.
If the character is not found, the function returns a null pointer.!strchr
Locate first occurrence of character in string (function )
memchr
Locate character in block of memory (function )
strpbrk
Locate characters in string (function )!X!
Cplusplus!size_t strspn ( const char * str1, const char * str2 );
Get span of character set in string
Returns the length of the initial portion of str1 which consists only of characters that are part of str2.

The search does not include the terminating null-characters of either strings, but ends there.
!strspn!str1
C string to be scanned.
str2
C string containing the characters to match.
!The length of the initial portion of str1 containing only characters that appear in str2.
Therefore, if all of the characters in str1 are in str2, the function returns the length of the entire str1 string, and if the first character in str1 is not in str2, the function returns zero.
size_t is an unsigned integral type.!strcspn
Get span until character in string (function )
strstr
Locate substring (function )
strncmp
Compare characters of two strings (function )!X!
Cplusplus!const char * strstr ( const char * str1, const char * str2 );
      char * strstr (       char * str1, const char * str2 );
Locate substring
Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.

The matching process does not include the terminating null-characters, but it stops there.!strstr!str1
C string to be scanned.
str2
C string containing the sequence of characters to match.!A pointer to the first occurrence in str1 of the entire sequence of characters specified in str2, or a null pointer if the sequence is not present in str1.!strspn
Get span of character set in string (function )
strpbrk
Locate characters in string (function )
strchr
Locate first occurrence of character in string (function )!X!
Cplusplus!char * strtok ( char * str, const char * delimiters );
Split string into tokens
A sequence of calls to this function split str into tokens, which are sequences of contiguous characters separated by any of the characters that are part of delimiters.

On a first call, the function expects a C string as argument for str, whose first character is used as the starting location to scan for tokens. In subsequent calls, the function expects a null pointer and uses the position right after the end of last token as the new starting location for scanning.

To determine the beginning and the end of a token, the function first scans from the starting location for the first character not contained in delimiters (which becomes the beginning of the token). And then scans starting from this beginning of the token for the first character contained in delimiters, which becomes the end of the token. The scan also stops if the terminating null character is found.

This end of the token is automatically replaced by a null-character, and the beginning of the token is returned by the function.

Once the terminating null character of str is found in a call to strtok, all subsequent calls to this function (with a null pointer as the first argument) return a null pointer.

The point where the last token was found is kept internally by the function to be used on the next call (particular library implementations are not required to avoid data races).
!strtok!str
C string to truncate.
Notice that this string is modified by being broken into smaller strings (tokens).
Alternativelly, a null pointer may be specified, in which case the function continues scanning where a previous successful call to the function ended.
delimiters
C string containing the delimiter characters.
These may vary from one call to another.!A pointer to the last token found in string.
A null pointer is returned if there are no tokens left to retrieve.!strcspn
Get span until character in string (function )
strpbrk
Locate characters in string (function )!X!
Cplusplus!size_t strxfrm ( char * destination, const char * source, size_t num );
Transform string using locale
Transforms the C string pointed by source according to the current locale and copies the first num characters of the transformed string to destination, returning its length.
Alternativelly, the function can be used to only retrieve the length, by specifying a null pointer for destination and zero for num.

destination and source shall not overlap.

The behavior of this function depends on the LC_COLLATE category of the selected C locale.!strxfrm!destination
Pointer to the destination array where the content is to be copied.
It can be a null pointer if the argument for num is zero.
source
C string to be transformed.
num
Maximum number of characters to be copied to destination.
size_t is an unsigned integral type.!The length of the transformed string, not including the terminating null-character.
size_t is an unsigned integral type.!strncpy
Copy characters from string (function )
strncmp
Compare characters of two strings (function )
strcoll
Compare two strings using locale (function )!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.

In <cstring>, it is used as the type of the parameter num in the functions memchr, memcmp, memcpy, memmove, memset, strncat, strncmp, strncpy and strxfrm, which in all cases it is used to specify the maximum number of bytes or characters the function has to affect.

It is also used as the return type for strcspn, strlen, strspn and strxfrm to return sizes and lengths.!size_t!X!X!X!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.

A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X!
Cplusplus!char* asctime (const struct tm * timeptr);
Convert tm structure to string
Interprets the contents of the tm structure pointed by timeptr as a calendar time and converts it to a C-string containing a human-readable version of the corresponding date and time.

The returned string has the following format:

Www Mmm dd hh:mm:ss yyyy

Where Www is the weekday, Mmm the month (in letters), dd the day of the month, hh:mm:ss the time, and yyyy the year.

The string is followed by a new-line character ('\n') and terminated with a null-character.

It is defined with a behavior equivalent to:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
char* asctime(const struct tm *timeptr)
{
  static const char wday_name[][4] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
  };
  static const char mon_name[][4] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  };
  static char result[26];
  sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
    wday_name[timeptr->tm_wday],
    mon_name[timeptr->tm_mon],
    timeptr->tm_mday, timeptr->tm_hour,
    timeptr->tm_min, timeptr->tm_sec,
    1900 + timeptr->tm_year);
  return result;
}


For an alternative with custom date formatting, see strftime.
!asctime!timeptr
Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).
!A C-string containing the date and time information in a human-readable format.

The returned value points to an internal array whose validity or value may be altered by any subsequent call to asctime or ctime.!ctime
Convert time_t value to string (function )
gmtime
Convert time_t to tm as UTC time (function )
localtime
Convert time_t to tm as local time (function )
time
Get current time (function )!X!
Cplusplus!clock_t clock (void);
Clock program
Returns the processor time consumed by the program.

The value returned is expressed in clock ticks, which are units of time of a constant but system-specific length (with a relation of CLOCKS_PER_SEC clock ticks per second).

The epoch used as reference by clock varies between systems, but it is related to the program execution (generally its launch). To calculate the actual processing time of a program, the value returned by clock shall be compared to a value returned by a previous call to the same function.!clock!none!The number of clock ticks elapsed since an epoch related to the particular program execution.

On failure, the function returns a value of -1.

clock_t is a type defined in <ctime> as an alias of a fundamental arithmetic type.!time
Get current time (function )
difftime
Return difference between two times (function )!X!
Cplusplus!char* ctime (const time_t * timer);
Convert time_t value to string
Interprets the value pointed by timer as a calendar time and converts it to a C-string containing a human-readable version of the corresponding time and date, in terms of local time.

The returned string has the following format:

Www Mmm dd hh:mm:ss yyyy

Where Www is the weekday, Mmm the month (in letters), dd the day of the month, hh:mm:ss the time, and yyyy the year.

The string is followed by a new-line character ('\n') and terminated with a null-character.

This function is equivalent to: 
 
asctime(localtime(timer))


For an alternative with custom date formatting, see strftime.!ctime!timer
Pointer to an object of type time_t that contains a time value.
time_t is an alias of a fundamental arithmetic type capable of representing times as returned by function time.!A C-string containing the date and time information in a human-readable format.

The returned value points to an internal array whose validity or value may be altered by any subsequent call to asctime or ctime.
!asctime
Convert tm structure to string (function )
gmtime
Convert time_t to tm as UTC time (function )
localtime
Convert time_t to tm as local time (function )
time
Get current time (function )!X!
Cplusplus!double difftime (time_t end, time_t beginning);
Return difference between two times
Calculates the difference in seconds between beginning and end.
!difftime!end
Higher bound of the time interval whose length is calculated.
beginning
Lower bound of the time interval whose length is calculated.
If this describes a time point later than end, the result is negative.
time_t is an alias of a fundamental arithmetic type capable of representing times as returned by function time.!The result of (end-beginning) in seconds as a floating-point value of type double.
!asctime
Convert tm structure to string (function )
gmtime
Convert time_t to tm as UTC time (function )
localtime
Convert time_t to tm as local time (function )
time
Get current time (function )!X!
Cplusplus!struct tm * gmtime (const time_t * timer);
Convert time_t to tm as UTC time
Uses the value pointed by timer to fill a tm structure with the values that represent the corresponding time, expressed as a UTC time (i.e., the time at the GMT timezone).

For a local time alternative, see localtime.
!gmtime!timer
Pointer to an object of type time_t that contains a time value.
time_t is an alias of a fundamental arithmetic type capable of representing times as returned by function time.!A pointer to a tm structure with its members filled with the values that correspond to the UTC time representation of timer.

The returned value points to an internal object whose validity or value may be altered by any subsequent call to gmtime or localtime.!asctime
Convert tm structure to string (function )
ctime
Convert time_t value to string (function )
localtime
Convert time_t to tm as local time (function )
mktime
Convert tm structure to time_t (function )
time
Get current time (function )!X!
Cplusplus!struct tm * localtime (const time_t * timer);
Convert time_t to tm as local time
Uses the value pointed by timer to fill a tm structure with the values that represent the corresponding time, expressed for the local timezone.!locatime!timer
Pointer to an object of type time_t that contains a time value.
time_t is an alias of a fundamental arithmetic type capable of representing times as returned by function time.!A pointer to a tm structure with its members filled with the values that correspond to the local time representation of timer.

The returned value points to an internal object whose validity or value may be altered by any subsequent call to gmtime or localtime.!asctime
Convert tm structure to string (function )
ctime
Convert time_t value to string (function )
gmtime
Convert time_t to tm as UTC time (function )
mktime
Convert tm structure to time_t (function )
time
Get current time (function )!X!
Cplusplus!time_t mktime (struct tm * timeptr);
Convert tm structure to time_t
Returns the value of type time_t that represents the local time described by the tm structure pointed by timeptr (which may be modified).

This function performs the reverse translation that localtime does.

The values of the members tm_wday and tm_yday of timeptr are ignored, and the values of the other members are interpreted even if out of their valid ranges (see struct tm). For example, tm_mday may contain values above 31, which are interpreted accordingly as the days that follow the last day of the selected month.

A call to this function automatically adjusts the values of the members of timeptr if they are off-range or -in the case of tm_wday and tm_yday- if they have values that do not match the date described by the other members.!mktime!timeptr
Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).
!A time_t value corresponding to the calendar time passed as argument.
If the calendar time cannot be represented, a value of -1 is returned.!asctime
Convert tm structure to string (function )
gmtime
Convert time_t to tm as UTC time (function )
localtime
Convert time_t to tm as local time (function )
time
Get current time (function )!X!
Cplusplus!size_t strftime (char* ptr, size_t maxsize, const char* format,
                 const struct tm* timeptr );
Format time as string
Copies into ptr the content of format, expanding its format specifiers into the corresponding values that represent the time described in timeptr, with a limit of maxsize characters.
!strftime!ptr
Pointer to the destination array where the resulting C string is copied.
maxsize
Maximum number of characters to be copied to ptr, including the terminating null-character.
format
C string containing any combination of regular characters and special format specifiers. These format specifiers are replaced by the function to the corresponding values to represent the time specified in timeptr. They all begin with a percentage (%) sign, and are:
specifier Replaced by Example
%a Abbreviated weekday name * Thu
%A Full weekday name * Thursday
%b Abbreviated month name * Aug
%B Full month name * August
%c Date and time representation * Thu Aug 23 14:55:02 2001
%C Year divided by 100 and truncated to integer (00-99) 20
%d Day of the month, zero-padded (01-31) 23
%D Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01
%e Day of the month, space-padded ( 1-31) 23
%F Short YYYY-MM-DD date, equivalent to %Y-%m-%d 2001-08-23
%g Week-based year, last two digits (00-99) 01
%G Week-based year 2001
%h Abbreviated month name * (same as %b) Aug
%H Hour in 24h format (00-23) 14
%I Hour in 12h format (01-12) 02
%j Day of the year (001-366) 235
%m Month as a decimal number (01-12) 08
%M Minute (00-59) 55
%n New-line character ('\n') 
%p AM or PM designation PM
%r 12-hour clock time * 02:55:02 pm
%R 24-hour HH:MM time, equivalent to %H:%M 14:55
%S Second (00-61) 02
%t Horizontal-tab character ('\t') 
%T ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S 14:55:02
%u ISO 8601 weekday as number with Monday as 1 (1-7) 4
%U Week number with the first Sunday as the first day of week one (00-53) 33
%V ISO 8601 week number (00-53) 34
%w Weekday as a decimal number with Sunday as 0 (0-6) 4
%W Week number with the first Monday as the first day of week one (00-53) 34
%x Date representation * 08/23/01
%X Time representation * 14:55:02
%y Year, last two digits (00-99) 01
%Y Year 2001
%z ISO 8601 offset from UTC in timezone (1 minute=1, 1 hour=100)
If timezone cannot be termined, no characters +100
%Z Timezone name or abbreviation *
If timezone cannot be termined, no characters CDT
%% A % sign %
* The specifiers marked with an asterisk (*) are locale-dependent.
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. Since C99, two locale-specific modifiers can also be inserted between the percentage sign (%) and the specifier proper to request an alternative format, where applicable:
Modifier Meaning Applies to
E Uses the locale's alternative representation %Ec %EC %Ex %EX %Ey %EY
O Uses the locale's alternative numeric symbols %Od %Oe %OH %OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy
timeptr
Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).
!If the length of the resulting C string, including the terminating null-character, doesn't exceed maxsize, the function returns the total number of characters copied to ptr (not including the terminating null-character).
Otherwise, it returns zero, and the contents of the array pointed by ptr are indeterminate.
!ctime
Convert time_t value to string (function )
asctime
Convert tm structure to string (function )!Particular library implementations may support additional specifiers or combinations.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.!
Cplusplus!time_t time (time_t* timer);
Get current time
Get the current calendar time as a value of type time_t.

The function returns this value, and if the argument is not a null pointer, it also sets this value to the object pointed by timer.

The value returned generally represents the number of seconds since 00:00 hours, Jan 1, 1970 UTC (i.e., the current unix timestamp). Although libraries may use a different representation of time: Portable programs should not use the value returned by this function directly, but always rely on calls to other elements of the standard library to translate them to portable types (such as localtime, gmtime or difftime).
!time!timer
Pointer to an object of type time_t, where the time value is stored.
Alternatively, this parameter can be a null pointer, in which case the parameter is not used (the function still returns a value of type time_t with the result).!The current calendar time as a time_t object.

If the argument is not a null pointer, the return value is the same as the one stored in the location pointed by time.

If the function could not retrieve the calendar time, it returns a value of -1.

time_t is an alias of a fundamental arithmetic type capable of representing times.
!asctime
Convert tm structure to string (function )
gmtime
Convert time_t to tm as UTC time (function )
localtime
Convert time_t to tm as local time (function )!X!
Cplusplus!Clock ticks per second
This macro expands to an expression representing the number of clock ticks per second.

Clock ticks are units of time of a constant but system-specific length, as those returned by function clock.

Dividing a count of clock ticks by this expression yields the number of seconds.

This macro evaluates to an expression of type clock_t.

CLK_TCK is an obsolete alias of this macro.!CLOCKS_PER_SEC!X!X!clock
Clock program (function )
clock_t
Clock type (type )!X!
Cplusplus!Null pointer
This macro expands to a null pointer constant.

A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X!
Cplusplus!Clock type
Alias of a fundamental arithmetic type capable of representing clock tick counts.

Clock ticks are units of time of a constant but system-specific length, as those returned by function clock.

This is the type returned by clock.!clocl_t!X!X!clock
Clock program (function )
CLOCKS_PER_SEC
Clock ticks per second (macro )!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.

In <ctime>, it is used in the function strftime as the type of its parameter maxsize and as its return value. In both cases it is used to express counts of characters.!size_t!X!X!X!X!
Cplusplus!Time type
Alias of a fundamental arithmetic type capable of representing times, as those returned by function time.

For historical reasons, it is generally implemented as an integral value representing the number of seconds elapsed since 00:00 hours, Jan 1, 1970 UTC (i.e., a unix timestamp). Although libraries may implement this type using alternative time representations.

Portable programs should not use values of this type directly, but always rely on calls to elements of the standard library to translate them to portable types.!time_t!X!X!time
Get current time (function )!X!
Cplusplus!Time structure
Structure containing a calendar date and time broken down into its components.

The structure contains nine members of type int (in any order), which are:

Member Type Meaning Range
tm_sec int seconds after the minute 0-60*
tm_min int minutes after the hour 0-59
tm_hour int hours since midnight 0-23
tm_mday int day of the month 1-31
tm_mon int months since January 0-11
tm_year int years since 1900 
tm_wday int days since Sunday 0-6
tm_yday int days since January 1 0-365
tm_isdst int Daylight Saving Time flag 
The Daylight Saving Time flag (tm_isdst) is greater than zero if Daylight Saving Time is in effect, zero if Daylight Saving Time is not in effect, and less than zero if the information is not available.

* tm_sec is generally 0-59. The extra range is to accommodate for leap seconds in certain systems.
!struct tm!X!X!mktime
Convert tm structure to time_t (function )
localtime
Convert time_t to tm as local time (function )
gmtime
Convert time_t to tm as UTC time (function )!X!
Cplusplus!size_t c16rtomb ( char * pmb, char16_t c16, mbstate_t * ps );
Convert 16-bit character to multibyte sequence
The 16-bit character c16 is translated to its multibyte equivalent and stored in the array pointed by pmb. The function returns the length in bytes of the equivalent multibyte sequence pointed by pmb.

If the __STD_UTF_16__ is defined, c16 shall follow UTF-16 encoding.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If c16 is a null 16-bit character, the function resets the shift state and stores a null byte, preceded by any shift sequence needed to restore the initial shift state.

A call to the function with a null pointer as pmb also resets the shift state (and ignores parameter c16).

This is the char16_t version of wcrtomb (<cwchar>).!c16rtomb!pmb
Pointer to an array large enough to hold a multibyte sequence.
The maximum length of a multibyte sequence for a character in the current locale is MB_CUR_MAX bytes.

Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
c16
16-bit character of type char16_t.
ps
Pointer to a mbstate_t object that defines a conversion state.
!The size of the multibyte sequence written at pmb (in bytes), including any shift characters. This may be zero.

If there is no character correspondence, the function returns (size_t)-1 and sets errno to EILSEQ.

If pmb is a null pointer, the function stores no bytes at pmb, and thus returns zero.!mbrtoc16
Convert multibyte sequence to 16-bit character (function )
c32rtomb
Convert 32-bit character to multibyte sequence (function )
wcrtomb
Convert wide character to multibyte sequence (function )!X!
Cplusplus!size_t c32rtomb ( char * pmb, char32_t c32, mbstate_t * ps );
Convert 32-bit character to multibyte sequence
The 32-bit character c32 is translated to its multibyte equivalent and stored in the array pointed by pmb. The function returns the length in bytes of the equivalent multibyte sequence pointed by pmb.

If the __STD_UTF_32__ is defined, c32 shall follow UTF-32 encoding.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If c32 is a null 32-bit character, the function resets the shift state and stores a null byte, preceded by any shift sequence needed to restore the initial shift state.

A call to the function with a null pointer as pmb also resets the shift state (and ignores parameter c32).

This is the char32_t version of wcrtomb (<cwchar>).
!c32rtomb!pmb
Pointer to an array large enough to hold a multibyte sequence.
The maximum length of a multibyte sequence for a character in the current locale is MB_CUR_MAX bytes.

Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
c32
32-bit character of type char32_t.
ps
Pointer to a mbstate_t object that defines a conversion state.!The size of the multibyte sequence written at pmb (in bytes), including any shift characters. This may be zero.

If there is no character correspondence, the function returns (size_t)-1 and sets errno to EILSEQ.

If pmb is a null pointer, the function stores no bytes at pmb, and thus returns zero.
!mbrtoc32
Convert multibyte sequence to 32-bit character (function )
c16rtomb
Convert 16-bit character to multibyte sequence (function )
wcrtomb
Convert wide character to multibyte sequence (function )!X!
Cplusplus!size_t mbrtoc16 ( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps);
Convert multibyte sequence to 16-bit character
The multibyte character pointed by pmb is converted to a 16-bit character and stored at the location pointed by pc16. The function returns the length in bytes of the multibyte character (up to max).

If the __STD_UTF_16__ macro is defined, the resulting character stored at pc16 follows UTF-16 encoding.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If the character obtained is equivalent to the null 16-bit character, the function resets the shift state and returns zero (after storing the null 16-bit character at pc16).

A call to the function with a null pointer as pmb also resets the shift state, ignoring parameters pc16 and max (no character is stored at pc16).

This is the char16_t version of mbrtowc (<cwchar>).!mbrtoc16!pc16
Pointer to an object of type char16_t.
Alternativelly, this argument can be a null pointer, in which case the function does not store the char16_t translation, but still returns the length in bytes of the character.
pmb
Pointer to the first byte of a multibyte character.
Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
max
Maximum number of bytes to read from pmb.
The macro constant MB_CUR_MAX defines the maximum number of bytes that can form a multibyte character under the current locale settings.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.!The number of bytes from pmb used to produce the 16-bit character.

If this was the null 16-bit character, or if pmb is a null pointer, the function returns zero (in the first case, the null 16-bit character is stored at pc16).

If the multibyte sequence needs more than one char16_t to be represented and not all have yet been stored, the function returns (size_t)-3 after storing the appropriate shift character at pc16. The next call to this function with the same ps argument pointing to the same address as pmb shall produce the next character in the sequence of char16_t characters needed to represent the multibyte sequence.

If the max first characters of pmb form an incomplete (but potentially valid) multibyte character, the function returns (size_t)-2 (no value is stored at pc16).

Otherwise, if the characters pointed by pmb do not form a valid multibyte character (or the beginning of one), the function returns (size_t)-1 and sets errno to EILSEQ (no value is stored at pc16).

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!c16rtomb
Convert 16-bit character to multibyte sequence (function )
mbrtoc32
Convert multibyte sequence to 32-bit character (function )
mbrtowc
Convert multibyte sequence to wide character (function )!X!
Cplusplus!size_t mbrtoc32 ( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps);
Convert multibyte sequence to 32-bit character
The multibyte character pointed by pmb is converted to a 32-bit character and stored at the location pointed by pc32. The function returns the length in bytes of the multibyte character (up to max).

If the __STD_UTF_32__ macro is defined, the resulting character stored at pc32 follows UTF-32 encoding.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If the character obtained is equivalent to the null 32-bit character, the function resets the shift state and returns zero (after storing the null 32-bit character at pc32).

A call to the function with a null pointer as pmb also resets the shift state, ignoring parameters pc32 and max (no character is stored at pc32).

This is the char32_t version of mbrtowc (<cwchar>).!mbrtoc32!pc32
Pointer to an object of type char32_t.
Alternativelly, this argument can be a null pointer, in which case the function does not store the char32_t translation, but still returns the length in bytes of the character.
pmb
Pointer to the first byte of a multibyte character.
Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
max
Maximum number of bytes to read from pmb.
The macro constant MB_CUR_MAX defines the maximum number of bytes that can form a multibyte character under the current locale settings.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.!The number of bytes from pmb used to produce the 32-bit character.

If this was the null 32-bit character, or if pmb is a null pointer, the function returns zero (in the first case, the null 32-bit character is stored at pc32).

If the multibyte sequence needs more than one char32_t to be represented (which not possible on UTF-32) and not all have yet been stored, the function returns (size_t)-3 after storing the appropriate shift character at pc32. The next call to this function with the same ps argument pointing to the same address as pmb shall produce the next character in the sequence of char32_t characters needed to represent the multibyte sequence.

If the max first characters of pmb form an incomplete (but potentially valid) multibyte character, the function returns (size_t)-2 (no value is stored at pc32).

Otherwise, if the characters pointed by pmb do not form a valid multibyte character (or the beginning of one), the function returns (size_t)-1 and sets errno to EILSEQ (no value is stored at pc32).

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!c32rtomb
Convert 32-bit character to multibyte sequence (function )
mbrtoc16
Convert multibyte sequence to 16-bit character (function )
mbrtowc
Convert multibyte sequence to wide character (function )!X!
Cplusplus!wint_t btowc (int c);
Convert single byte character to wide character
Returns the wide character representation of the byte value c if (and only if) c is a valid multibyte character with a length of a single byte in the initial state of a multibyte sequence.

Otherwise, it returns WEOF.
!btowc!c
The int promotion of a byte (as in a multibyte sequence).
The value is internally converted to an unsigned char to be interpreted.!If c is a valid single-byte character in the initial shift state of a multibyte sequence, the function returns its representation as a wchar_t (type-casted to a value of type wint_t).

If c is EOF, or if c is not a valid single-byte representation, the function returns WEOF.!wctob
Convert wide character to single byte (function )
mbrtowc
Convert multibyte sequence to wide character (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )!X!
Cplusplus!wint_t fgetwc (FILE * stream);
Get wide character from stream
Returns the wide character currently pointed by the internal position indicator of the specified stream. The internal position indicator is then advanced to the next wide character.

Because wide characters are represented by multibyte characters in external files, the function may involve reading several bytes from the file, which are interpreted as a single character as if mbrtowc was called with the stream's internal mbstate_t object.

If the sequence of bytes read cannot be interpreted as a valid multibyte character (or there were too few bytes available to compose a wide character), the function returns WEOF and sets EILSEQ as the value of errno.

If the stream is at the end-of-file when called, the function returns WEOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns WEOF and sets the error indicator for the stream (ferror).

fgetwc and getwc are equivalent, except that getwc may be implemented as a macro in some libraries.

This is the wide character equivalent of fgetc (<cstdio>).
Get wide character from stream
Returns the wide character currently pointed by the internal position indicator of the specified stream. The internal position indicator is then advanced to the next wide character.

Because wide characters are represented by multibyte characters in external files, the function may involve reading several bytes from the file, which are interpreted as a single character as if mbrtowc was called with the stream's internal mbstate_t object.

If the sequence of bytes read cannot be interpreted as a valid multibyte character (or there were too few bytes available to compose a wide character), the function returns WEOF and sets EILSEQ as the value of errno.

If the stream is at the end-of-file when called, the function returns WEOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns WEOF and sets the error indicator for the stream (ferror).

fgetwc and getwc are equivalent, except that getwc may be implemented as a macro in some libraries.

This is the wide character equivalent of fgetc (<cstdio>).!fgetwc!stream
Pointer to a FILE object that identifies an input stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
Pointer to a FILE object that identifies an input stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, the character read is returned (promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the sequence of bytes read cannot be interpreted as a valid wide character, the function returns WEOF and sets errno to EILSEQ.
If the position indicator was at the end-of-file, the function returns WEOF and sets the eof indicator (feof) of stream.
If a reading error happens, the function also returns WEOF, but sets its error indicator (ferror) instead.
!fgetc
Get character from stream (function )
fputwc
Write wide character to stream (function )
fwscanf
Read formatted data from stream (function )!X!
Cplusplus!wchar_t* fgetws (wchar_t* ws, int num, FILE* stream);
Get wide string from stream
Reads wide characters from stream and stores them as a C wide string into ws until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first.

A newline wide character makes fgetws stop reading, but it is considered a valid character by the function and included in the string copied to ws.

A terminating null character is automatically appended after the characters copied to ws.

The external representation of wide characters in files are multibyte characters: These are translated as if mbrtowc was called (using the stream's internal mbstate_t object).

The function behaves as if fgetwc was used to read the characters from the stream.

This is the wide character equivalent of fgets (<cstdio>).!fgetws!ws
Pointer to an array of wchar_t where the wide string read is copied.
num
Maximum number of characters to be copied into str (including the terminating null-character).
stream
Pointer to a FILE object that identifies an input stream.
stdin can be used as argument to read from the standard input.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).!fgets
Get string from stream (function )
fputws
Write wide string to stream (function )
fgetwc
Get wide character from stream (function )!X!
Cplusplus!wint_t fputwc (wchar_t wc, FILE * stream);
Write wide character to stream
Writes the wide character wc to the stream and advances the position indicator.

Because wide characters are represented by multibyte characters in external files, the function may involve writing several bytes to the file, as if wcrtomb was called to translate wc with the stream's internal mbstate_t object.

If the wide character cannot be represented using the multibyte encoding, the function returns WEOF and sets EILSEQ as the value of errno.

If a writing error occurs, the function returns WEOF and sets the error indicator for the stream (ferror).

fputwc and putwc are equivalent, except that putwc may be implemented as a macro in some libraries.

This is the wide character equivalent of fputc (<cstdio>).!fputwc!wc
The wide character to write.
stream
Pointer to a FILE object that identifies an output stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
!On success, the character written is returned (wc promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the wide character could not be interpreted as a valid multibyte character, the function returns WEOF and sets errno to EILSEQ.
If a writing error occurs, the function also returns WEOF and the error indicator (ferror) is set.!fputc
Write character to stream (function )
putwc
Write wide character to stream (function )
fgetwc
Get wide character from stream (function )!X!
Cplusplus!int fputws (const wchar_t* ws, FILE* stream);
Write wide string to stream
Writes the wide C string pointed by ws to the stream.

The function begins copying from the address specified (ws) until it reaches the terminating null wide character. This terminating null wide character is not copied to the stream.

The external representation of wide characters in files are multibyte characters: These are obtained as if wcrtomb was called to convert each wide character (using the stream's internal mbstate_t object).

This is the wide character equivalent of fputs (<cstdio>).
!fputws!ws
C wide string with the content to write to the stream.
stream
Pointer to a FILE object that identifies an output stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, a non-negative value is returned.
If a multibyte character encoding error occurs, errno is set to EILSEQ and EOF is returned.
If a writing error occurs, the function sets the error indicator (ferror) and also returns EOF.!fputs
Write string to stream (function )
fgetws
Get wide string from stream (function )
fputwc
Write wide character to stream (function )
fwprintf
Write formatted data to stream (function )!X!
Cplusplus!int fwide (FILE* stream, int mode);
Stream orientation
Determines the orientation of stream, and if it has not yet an established orientation, it may be set, depending on the value of mode.

When open, streams have no orientation (including stdin, stdout and stderr). But the first i/o operation performed on one automatically sets its orientation: if it is a byte-oriented function (defined in <cstdio>), the stream becomes byte-oriented; if it is a wide-oriented function (defined in <cwchar>), the stream becomes wide-oriented.

By calling this function, the orientation can be explicitly established before any i/o operation. Calling this function on a stream that already has an orientation cannot change it (only after a call to freopen can a stream with an established orientation change it).

The function can be used to obtain the current orientation of a stream by using zero as mode.
!fwide!stream
Pointer to a FILE object that identifies a stream.
mode
May specify an orientation:
A mode of zero does not change the orientation of the stream.
A mode greater than zero makes the stream wide-oriented.
A mode less than zero makes the stream byte-oriented.!The function returns a value depending on the stream orientation after the call:
A value of zero, indicates that the stream has no orientation yet.
A value greater than zero indicates that the stream is wide-oriented.
A value less than indicates that the stream is byte-oriented.!fopen
Open file (function )
freopen
Reopen stream with different file or mode (function )!X!
Cplusplus!int fwprintf (FILE* stream, const wchar_t* format, ...);
Write formatted data to stream
Writes the C wide string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.

After the format parameter, the function expects at least as many additional arguments as specified by format.

The external representation of wide characters in files are multibyte characters: These are obtained as if wcrtomb was called to convert each wide character (using the stream's internal mbstate_t object).

This is the wide character equivalent of fprintf (<cstdio>).!fwprintf!stream
Pointer to a FILE object that identifies an output stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
format
C wide string that contains a format string that follow the same specifications as format in printf but with wide characters (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.
!fprintf
Write formatted data to stream (function )
wprintf
Print formatted data to stdout (function )
fwscanf
Read formatted data from stream (function )
fwrite
Write block of data to stream (function )
fputws
Write wide string to stream (function )!X!
Cplusplus!int fwscanf (FILE* stream, const wchar_t* format, ...);
Read formatted data from stream
Reads data from the stream and stores them according to the C wide string format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.

The external representation of wide characters in files are multibyte characters: These are translated as if mbrtowc was called (using the stream's internal mbstate_t object).

This is the wide character equivalent of fscanf (<cstdio>).!fwscanf!stream
Pointer to a FILE object that identifies the input stream to read data from.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!wscanf
Read formatted data from stdin (function )
fwprintf
Write formatted data to stream (function )
fread
Read block of data from stream (function )
fgetws
Get wide string from stream (function )!X!
Cplusplus!wint_t getwc (FILE* stream);
Get wide character from stream
Returns the wide character currently pointed by the internal position indicator of the specified stream. The internal position indicator is then advanced to the next wide character.

Because wide characters are represented by multibyte characters in external files, the function may involve reading several bytes from the file, which are interpreted as a single character as if mbrtowc was called with the stream's internal mbstate_t object.

If the sequence of bytes read cannot be interpreted as a valid multibyte character (or there were too few bytes available to compose a wide character), the function returns WEOF and sets EILSEQ as the value of errno.

If the stream is at the end-of-file when called, the function returns WEOF and sets the end-of-file indicator for the stream (feof).

If a read error occurs, the function returns WEOF and sets the error indicator for the stream (ferror).

getwc and fgetwc are equivalent, except that getwc may be implemented as a macro in some libraries. See getwchar for a similar function that reads directly from stdin.

This is the wide character equivalent of getc (<cstdio>).
!getwc!stream
Pointer to a FILE object that identifies an input stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, the character read is returned (promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the sequence of bytes read cannot be interpreted as a valid wide character, the function returns WEOF and sets errno to EILSEQ.
If the position indicator was at the end-of-file, the function returns WEOF and sets the eof indicator (feof) of stream.
If a reading error happens, the function also returns WEOF, but sets its error indicator (ferror) instead.
!getc
Get character from stream (function )
fputwc
Write wide character to stream (function )
fwscanf
Read formatted data from stream (function )!X!
Cplusplus!wint_t getwchar (void);
Get wide character from stdin
Returns the next wide character from the standard input (stdin).

It is equivalent to calling getwc with stdin as argument.

This is the wide character equivalent of getchar (<cstdio>).!getwchar!(none) !On success, the character read is returned (promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the sequence of bytes read cannot be interpreted as a valid wide character, the function returns WEOF and sets errno to EILSEQ.
If the position indicator was at the end-of-file, the function returns WEOF and sets the eof indicator (feof) of stream.
If a reading error happens, the function also returns WEOF, but sets its error indicator (ferror) instead.!getwc
Get wide character from stream (function )
putwchar
Write wide character to stdout (function )
wscanf
Read formatted data from stdin (function )!X!
Cplusplus!size_t mbrlen (const char* pmb, size_t max, mbstate_t* ps);
Get length of multibyte character
Returns the size of the multibyte character pointed by pmb, examining at most max bytes.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

A call to the function with a null pointer as pmb resets the shift state (and ignores parameter max).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.

This is the restartable version of mblen (<cstdlib>).!mbrlen!pmb
Pointer to the first byte of a multibyte character.
Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
max
Maximum number of bytes to check.
The macro constant MB_CUR_MAX defines the maximum number of bytes that can form a multibyte character under the current locale settings.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.!If pmb points to a null character, or if pmb is a null pointer, the function returns zero.

Otherwise, if at most max characters pointed by pmb form a valid multibyte character, the function returns the size in bytes of that multibyte character.

Otherwise, if at most max characters do not contribute to form a valid multibyte character, the function returns (size_t)-1 and sets errno to EILSEQ.

Otherwise, if the max characters contribute to an incomplete (but potentially valid) multibyte character, the function returns (size_t)-2.

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.
!mbrtowc
Convert multibyte sequence to wide character (function )
wcrtomb
Convert wide character to multibyte sequence (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )
wcsrtombs
Convert wide-character string to multibyte string (function )m!X!
Cplusplus!size_t mbrtowc (wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps);
Convert multibyte sequence to wide character
The multibyte character pointed by pmb is converted to a value of type wchar_t and stored at the location pointed by pwc. The function returns the length in bytes of the multibyte character.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If pmb points to a null character, the function resets the shift state and returns zero after storing the wide null character at pwc.

A call to the function with a null pointer as pmb also resets the shift state, ignoring parameters pwc and max (no character is stored ad pwc).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.

This is the restartable version of mbtowc (<cstdlib>).!mbrtowc!pwc
Pointer to an object of type wchar_t.
Alternativelly, this argument can be a null pointer, in which case the function does not store the wchar_t translation, but still returns the length in bytes of the multibyte character.
pmb
Pointer to the first byte of a multibyte character.
Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
max
Maximum number of bytes to read from pmb.
The macro constant MB_CUR_MAX defines the maximum number of bytes that can form a multibyte character under the current locale settings.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.!The number of bytes from pmb used to produce the wide character.

If this was the null wide character, or if pmb is a null pointer, the function returns zero (in the first case, the null wide character is stored at pwc).

If the max first characters of pmb form an incomplete (but potentially valid) multibyte character, the function returns (size_t)-2 (no value is stored at pwc).

Otherwise, if the characters pointed by pmb do not form a valid multibyte character (or the beginning of one), the function returns (size_t)-1 and sets errno to EILSEQ (no value is stored at pwc).

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!mbrlen
Get length of multibyte character (function )
wcrtomb
Convert wide character to multibyte sequence (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )
wcsrtombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!int mbsinit (const mbstate_t* ps);
Check if initial conversion state
Checks whether ps points to a mbstate_t object that describes an initial conversion state.

A zero-valued mbstate_t object always describes an initial conversion state, although other values may also represent such state (depending on the particular library implementation). This function returns non-zero for any mbstate_t object representing an initial state, or if ps is a null pointer.

This function does not change the state identified by ps. Typical ways to make the state pointed by ps an initial state are:
 
memset (ps,0,sizeof(*ps));  // ps points to zero-valued object 

or:
 
mbrlen (NULL,0,ps);         // *ps set to an initial state 
!mbsinit!ps
Pointer to an mbstate_t object.!A non-zero value if ps points to a mbstate_t object that describes an initial conversion state, or if ps is a null pointer.
Otherwise, a zero value is returned.
!wcrtomb
Convert wide character to multibyte sequence (function )
mbrtowc
Convert multibyte sequence to wide character (function )
wcsrtombs
Convert wide-character string to multibyte string (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )!X!
Cplusplus!size_t mbsrtowcs (wchar_t* dest, const char** src, size_t max, mbstate_t* ps);
Convert multibyte string to wide-character string
Translates the multibyte sequence pointed by src to the equivalent sequence of wide-characters (which is stored in the array pointed by dest), up until either max wide characters have been translated or until a null character is encountered in the multibyte sequence src (which is also translated and stored, but not counted in the length returned by the function).

If max characters are successfully translated, the resulting string stored in dest is not null-terminated.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If the function translates an entire multibyte string (until it finds a null-character), and dest is not a null pointer, the function sets src to a null pointer value and the resulting state is guaranteed to be the initial conversion state.

The behavior of this function depends on the LC_CTYPE category of the selected C locale.

This is the restartable version of mbstowcs (<cstdlib>).
!mbsrtowcs!dest
Pointer to an array of wchar_t elements long enough to store a string of max wide characters.
If this is a null pointer, the function does not store the resulting string, but still counts how many bytes from src form a valid string (parameter max is ignored in this case).
src
Pointer to a C multibyte character string to be interpreted (an indirect pointer).
This value is modified by the function to point to past the last multibyte character converted if conversion stops prematurely, or to a null pointer if the function reached the terminating null character.
max
Maximum number of wide characters to write to dest.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.!The number of wide characters written to dest (not including the eventual terminating null character).

If, during the translation, the function encountered a sequence of bytes that does not form a valid multibyte character, the function sets errno to EILSEQ and returns (size_t)-1 (src will point to the first byte that could not be translated.

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!mbstowcs
Convert multibyte string to wide-character string (function )
wcsrtombs
Convert wide-character string to multibyte string (function )
mbrlen
Get length of multibyte character (function )
mbrtowc
Convert multibyte sequence to wide character (function )!X!
Cplusplus!wint_t putwc (wchar_t wc, FILE* stream);
Write wide character to stream
Writes the wide character wc to the stream and advances the position indicator.

Because wide characters are represented by multibyte characters in external files, the function may involve writing several bytes to the file, as if wcrtomb was called to translate wc with the stream's internal mbstate_t object.

If the wide character cannot be represented using the multibyte encoding, the function returns WEOF and sets EILSEQ as the value of errno.

If a writing error occurs, the function returns WEOF and sets the error indicator for the stream (ferror).

putwc and fputwc are equivalent, except that putwc may be implemented as a macro in some libraries. See putwchar for a similar function that writes directly to stdout.

This is the wide character equivalent of putc (<cstdio>).
!putwc!wc
The wide character to write.
stream
Pointer to a FILE object that identifies an output stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, the character written is returned (wc promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the wide character could not be interpreted as a valid multibyte character, the function returns WEOF and sets errno to EILSEQ.
If a writing error occurs, the function also returns WEOF and the error indicator (ferror) is set.
!putc
Write character to stream (function )
fputwc
Write wide character to stream (function )
getwc
Get wide character from stream (function )!X!
Cplusplus!wint_t putwchar (wchar_t wc);
Write wide character to stdout
Writes the wide character wc to the standard output (stdout).

It is equivalent to calling putwc with stdout as second argument.

This is the wide character equivalent of putchar (<cstdio>).!putwchar!wc
The wide character to be written.
!On success, the character written is returned (wc promoted to a value of type wint_t).
The return type is wint_t to accommodate for the special value WEOF, which indicates failure:
If the wide character could not be interpreted as a valid multibyte character, the function returns WEOF and sets errno to EILSEQ.
If a writing error occurs, the function also returns WEOF and the error indicator (ferror) is set.
!Write character to stdout (function )
putwc
Write wide character to stream (function )
fputwc
Write wide character to stream (function )
getwchar
Get wide character from stdin (function )!X!
Cplusplus!int swprintf (wchar_t* ws, size_t len, const wchar_t* format, ...);
Write formatted data to wide string
Composes a wide string with the same text that would be printed if format was used on wprintf, but instead of being printed, the content is stored as a C wide string in the buffer pointed by ws.

If the resulting wide string would be longer than len-1 characters, the remaining characters are discarded and not stored.

A terminating null character is automatically appended after the content.

After the format parameter, the function expects at least as many additional arguments as needed for format.

This is the wide character equivalent of snprintf (<cstdio>).!swprintf!ws
Pointer to a buffer where the resulting C wide string is stored.
The buffer should have a size of at least n wide characters.
len
Maximum number of wide characters to fill in the ws buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null wide character.
size_t is an unsigned integral type.
format
C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned. This count does not include the additional null-character automatically appended at the end of the string.
A negative number is returned on failure, including when the resulting string to be written to ws would be longer than n characters.
!snprintf
Write formatted output to sized buffer (function )
wprintf
Print formatted data to stdout (function )
swscanf
Read formatted data from string (function )!X!
Cplusplus!int swscanf (const wchar_t* ws, const wchar_t* format, ...);
Read formatted data from string
Reads data from the wide string ws and stores them according to parameter format into the locations given by the additional arguments, as if wscanf was used, but reading from ws instead of the standard input (stdin).

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.

This is the wide character equivalent of sscanf (<cstdio>).
!swscanf!ws
C wide string that the function processes as its source to retrieve the data.
format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less -even zero- in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.
!wscanf
Read formatted data from stdin (function )
swprintf
Write formatted data to wide string (function )
sscanf
Read formatted data from string (function )!X!
Cplusplus!wint_t ungetwc (wint_t wc, FILE* stream);
Unget wide character from stream
The wide character wc is virtually put back into an input stream, decreasing its internal file position as if a previous getwc operation was undone.

This wide character may or may not be the one read from the stream in the preceding input operation. In any case, the next wide character retrieved from stream is wc, independently of the original one.

Notice though, that this only affects further input operations on that stream, and not the content of the physical file associated with it, which is not modified by any calls to this function.

Some library implementations may support this function to be called multiple times, making the characters available in the reverse order in which they were put back. Although this behavior has no standard portability guarantees, and further calls may simply fail after any number of calls beyond the first.

If successful, the function clears the end-of-file indicator of stream (if it was currently set). The position indicator has unspecified value until all characters put back with ungetwc have been read again or discarded.

A call to fseek, fsetpos or rewind on stream will discard any characters previously put back into it with this function.

If the argument passed as wc is WEOF, the operation fails and the input stream remains unchanged.

This is the wide character equivalent of ungetc (<cstdio>).!ungetwc!wc
The wint_t promotion of the wide character to be put back.
The value is internally converted to a wchar_t when put back.
stream
Pointer to a FILE object that identifies an input stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).!On success, the wide character put back is returned.
If the operation fails, WEOF is returned.!ungetc
Unget character from stream (function )
getwc
Get wide character from stream (function )
fgetwc
Get wide character from stream (function )
putwc
Write wide character to stream (function )!X!
Cplusplus!int vfwprintf (FILE* stream, const wchar_t* format, va_list arg);
Write formatted data from variable argument list to stream
Writes the C wide string pointed by format to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

The external representation of wide characters in files are multibyte characters: These are obtained as if wcrtomb was called to convert each wide character (using the stream's internal mbstate_t object).

This is the wide character equivalent of vfprintf (<cstdio>).
!vfwprintf!stream
Pointer to a FILE object that identifies an output stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
format
C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.!vfprintf
Write formatted data from variable argument list to stream (function )
vwprintf
Print formatted data from variable argument list to stdout (function )
vswprintf
Write formatted data from variable argument list to sized buffer (function )
fwprintf
Write formatted data to stream (function )
wprintf
Print formatted data to stdout (function )!X!
Cplusplus!int vfwscanf (FILE* stream, const wchar_t* format, va_list arg);
Read formatted data from stream into variable argument list
Reads data from the stream and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

The external representation of wide characters in files are multibyte characters: These are translated as if mbrtowc was called (using the stream's internal mbstate_t object).

This is the wide character equivalent of vfscanf (<cstdio>).!vfwscanf!stream
Pointer to a FILE object that identifies an input stream.
The stream shall not have an orientation yet, or be wide-oriented (the first i/o operation on a stream determines whether it is byte- or wide- oriented, see fwide).
format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.
!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.
!vfscanf
Read formatted data from stream into variable argument list (function )
vwscanf
Read formatted data into variable argument list (function )
fwscanf
Read formatted data from stream (function )
wscanf
Read formatted data from stdin (function )!X!
Cplusplus!int vswprintf (wchar_t * ws, size_t len, const wchar_t * format, va_list arg );
Write formatted data from variable argument list to sized buffer
Composes a string with the same text that would be printed if format was used on wprintf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C wide string in the buffer pointed by ws (taking len as the maximum buffer capacity to fill, expressed in wide characters).

If the resulting string would be longer than n-1 wide characters, the remaining characters are discarded and not stored.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

This is the wide character equivalent of vsnprintf (<cstdio>).
!vswprintf!ws
Pointer to a buffer where the resulting C wide string is stored.
The buffer should have a size of at least len wide characters.
len
Maximum number of wide characters to be written to the buffer.
The generated string has a length of at most n-1, leaving space for the additional terminating null wide character.
size_t is an unsigned integral type.
format
C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.
!On success, the total number of characters written is returned. This count does not include the additional null-character automatically appended at the end of the string.
A negative number is returned on failure, including when the resulting string to be written to ws would be longer than n characters.!printf
Print formatted data to stdout (function )
vsnprintf
Write formatted data from variable argument list to sized buffer (function )
vfwprintf
Write formatted data from variable argument list to stream (function )
vwprintf
Print formatted data from variable argument list to stdout (function )
swprintf
Write formatted data to wide string (function )
wprintf
Print formatted data to stdout (function )!X!
Cplusplus!int vswscanf (const wchar_t* ws, const wchar_t* format, va_list arg);
Read formatted data from wide string into variable argument list
Reads data from ws and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

This is the wide character equivalent of vsscanf (<cstdio>).
!vswscanf!ws
C wide string that the function processes as its source to retrieve the data.
format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less -even zero- in the case of a matching failure.
In the case of an input failure before any data could be successfully interpreted, EOF is returned.!vcscanf
wscanf
Read formatted data from stdin (function )
vfwscanf
Read formatted data from stream into variable argument list (function )
swscanf
Read formatted data from string (function )
scanf
Read formatted data from stdin (function )
vswprintf
Write formatted data from variable argument list to sized buffer (function )!X!
Cplusplus!int vwprintf (const wchar_t* format, va_list arg);
Print formatted data from variable argument list to stdout
Writes the C wide string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by arg instead of additional function arguments.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

The external representation of wide characters in stdout are multibyte characters: These are obtained as if wcrtomb was called to convert each wide character (using the stream's internal mbstate_t object).

This is the wide character equivalent of vprintf (<cstdio>).
!vwprintf!format
C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.
!vprintf
Print formatted data from variable argument list to stdout (function )
wprintf
Print formatted data to stdout (function )
printf
Print formatted data to stdout (function )!X!
Cplusplus!int vwscanf ( const wchar_t * format, va_list arg );
Read formatted data into variable argument list
Reads data from the standard input (stdin) and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list identified by arg.

Internally, the function retrieves arguments from the list identified by arg as if va_arg was used on it, and thus the state of arg is likely to be altered by the call.

In any case, arg should have been initialized by va_start at some point before the call, and it is expected to be released by va_end at some point after the call.

The external representation of wide characters in stdin are multibyte characters: These are translated as if mbrtowc was called (using the stream's internal mbstate_t object).

This is the wide character equivalent of vscanf (<cstdio>).!vwscanf!format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
arg
A value identifying a variable arguments list initialized with va_start.
va_list is a special type defined in <cstdarg>.
!On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.!vscanf
Read formatted data into variable argument list (function )
wscanf
Read formatted data from stdin (function )
fscanf
Read formatted data from stream (function )
scanf
Read formatted data from stdin (function )!X!
Cplusplus!size_t wcrtomb (char* pmb, wchar_t wc, mbstate_t* ps);
Convert wide character to multibyte sequence
The wide character wc is translated to its multibyte equivalent and stored in the array pointed by pmb. The function returns the length in bytes of the equivalent multibyte sequence pointed by pmb.

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If wc is a null wide character, the function resets the shift state and stores a null byte, preceded by any shift sequence needed to restore the initial shift state.

A call to the function with a null pointer as pmb also resets the shift state (and ignores parameter wc).

The behavior of this function depends on the LC_CTYPE category of the selected C locale.

This is the restartable version of wctomb (<cstdlib>).!wcrtomb!pmb
Pointer to an array large enough to hold a multibyte sequence.
The maximum length of a multibyte sequence for a character in the current locale is MB_CUR_MAX bytes.

Alternativelly, the function may be called with a null pointer, in which case the function resets the shift state (either ps or its own internal state) to the initial state and returns zero.
wc
Wide character of type wchar_t.
ps
Pointer to a mbstate_t object that defines a conversion state.!The size of the multibyte sequence written at pmb (in bytes), including any shift characters.

If there is no character correspondence, the function returns (size_t)-1 and sets errno to EILSEQ.

If pmb is a null pointer, the function stores no bytes at pmb, and thus returns zero.!wctomb
Convert wide character to multibyte sequence (function )
wcsrtombs
Convert wide-character string to multibyte string (function )
mbrlen
Get length of multibyte character (function )
mbrtowc
Convert multibyte sequence to wide character (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )!X!
Cplusplus!wchar_t* wcscat (wchar_t* destination, const wchar_t* source);
Concatenate wide strings
Appends a copy of the source wide string to the destination wide string. The terminating null wide character in destination is overwritten by the first character of source, and a null wide character is included at the end of the new string formed by the concatenation of both in destination.

destination and source shall not overlap.

This is the wide character equivalent of strcat (<cstring>).
!wcscat!destination
Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string.
source
C wide string to be appended. This should not overlap destination.!destination is returned.!strcat
Concatenate strings (function )
wcsncat
Append characters from wide string (function )
wcscpy
Copy wide string (function )
wmemcpy
Copy block of wide characters (function )!X!
Cplusplus!const wchar_t* wcschr (const wchar_t* ws, wchar_t wc);
      wchar_t* wcschr (      wchar_t* ws, wchar_t wc);
Locate first occurrence of character in wide string
Returns a pointer to the first occurrence of the wide character wc in the C wide string ws.

The terminating null wide character is considered part of the string. Therefore, it can also be located in order to retrieve a pointer to the end of a wide string.

This is the wide character equivalent of strchr (<cstring>).!wcschr!ws
C wide string.
wc
Wide character to be located.!A pointer to the first occurrence of wc in ws.
If wc is not found, the function returns a null pointer.!strchr
Locate first occurrence of character in string (function )
wcsrchr
Locate last occurrence of character in wide string (function )
wmemchr
Locate character in block of wide characters (function )
wcspbrk
Locate characters in wide string (function )!X!
Cplusplus!int wcscmp (const wchar_t* wcs1, const wchar_t* wcs2);
Compare two strings
Compares the C wide string wcs1 to the C wide string wcs2.

This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null wide character is reached.

This function performs a simple comparison of the wchar_t values, without taking into account locale-specific rules (see wcscoll for a similar function that does).

This is the wide character equivalent of strcmp (<cstring>).!wcscmp!wcs1
C wide string to be compared.
wcs2
C wide string to be compared.!Returns an integral value indicating the relationship between the wide strings:
A zero value indicates that both are considered equal.
A value greater than zero indicates that the first wide character that does not match has a greater value in wcs1 than in wcs2; And a value less than zero indicates the opposite.
!strcmp
Compare two strings (function )
wcsncmp
Compare characters of two wide strings (function )
wmemcmp
Compare two blocks of wide characters (function )
wcsrchr
Locate last occurrence of character in wide string (function )
wcsspn
Get span of character set in wide string (function )!X!
Cplusplus!int wcscoll (const wchar_t* wcs1, const wchar_t* wcs2);
Compare two wide strings using locale
Compares the C wide string wcs1 to the C wide string wcs2, both interpreted appropriately according to the LC_COLLATE category of the C locale currently selected.

This function starts comparing the first character of each string. If they are considered equal to each other continues with the following pair until the characters differ or until a null wide character signaling the end of a string is reached.

The behavior of this function depends on the LC_COLLATE category of the selected C locale.

This is the wide character equivalent of strcoll (<cstring>).!wcscoll!wcs1
C wide string to be compared.
wcs2
C wide string to be compared.!Returns an integral value indicating the relationship between the strings:
A zero value indicates that both strings are equal.
A value greater than zero indicates that the first character that does not match has a greater value in wcs1 than in wcs2; And a value less than zero indicates the opposite.!strcoll
Compare two strings using locale (function )
wcscmp
Compare two strings (function )
wcsncmp
Compare characters of two wide strings (function )
wmemcmp
Compare two blocks of wide characters (function )!X!
Cplusplus!wchar_t* wcscpy (wchar_t* destination, const wchar_t* source);
Copy wide string
Copies the C wide string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point).

To avoid overflows, the size of the array pointed by destination shall be long enough to contain the same C wide string as source (including the terminating null character), and should not overlap in memory with source.

This is the wide character equivalent of strcpy (<cstring>).!wcscpy!destination
Pointer to the destination array where the content is to be copied.
source
C wide string to be copied.!destination is returned.!strcpy
Copy string (function )
wcsncpy
Copy characters from wide string (function )
wmemcpy
Copy block of wide characters (function )
wmemmove
Move block of wide characters (function )
wmemset
Fill array of wide characters (function )!X!
Cplusplus!size_t wcscspn (const wchar_t* wcs1, const wchar_t* wcs2);
Get span until character in wide string
Scans wcs1 for the first occurrence of any of the wide characters that are part of wcs2, returning the number of wide characters of wcs1 read before this first occurrence.

The search includes the terminating null wide characters. Therefore, the function will return the length of wcs1 if none of the characters of wcs2 are found in wcs1.

This is the wide character equivalent of strcspn (<cstring>).!wcscspn!wcs1
C wide string to be scanned.
wcs2
C wide string containing the characters to match.!The number of wide characters in the initial part of wcs1 that does not contain any of the characters that are part of wcs2.
This is the length of wcs1 if none of the wide characters in wcs2 are found in wcs1.
size_t is an unsigned integral type.
!strcspn
Get span until character in string (function )
wcspbrk
Locate characters in wide string (function )
wcsspn
Get span of character set in wide string (function )
wcsstr
Locate substring of wide string (function )!X!
Cplusplus!size_t wcsftime (wchar_t* ptr, size_t maxsize, const wchar_t* format,
                 const struct tm* timeptr);
Format time as wide string
Copies into ptr the content of format, expanding its format tags into the corresponding values as specified by timeptr, with a limit of maxsize characters.

This is the wide character equivalent of strftime (<ctime>).!wcsftime!ptr
Pointer to the destination array where the resulting C wide string is copied.
maxsize
Maximum number of wide characters to be copied to ptr.
format
C wide string that contains a format string that follows the same specifications as format in strftime (see strftime for details).
timeptr
Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).!If the resulting C wide string fits in less than maxsize wide characters including the terminating null wide character, the total number of characters copied to ptr (not including the terminating null wide character) is returned.
Otherwise, zero is returned and the contents of the array are indeterminate.!strftime
Format time as string (function )
ctime
Convert time_t value to string (function )
asctime
Convert tm structure to string (function )!X!
Cplusplus!size_t wcslen (const wchar_t* wcs);
Get wide string length
Returns the length of the C wide string wcs.

This is the number of wide characters between wcs and the first null wide character (without including it).

This is the wide character equivalent of strlen (<cstring>).
!wcslen!wcs
C wide string.
!The length of C wide string.
!strlen
Get string length (function )
wcschr
Locate first occurrence of character in wide string (function )
wcsrchr
Locate last occurrence of character in wide string (function )!X!
Cplusplus!wchar_t* wcsncat (wchar_t* destination, const wchar_t* source, size_t num);
Append characters from wide string
Appends the first num wide characters of source to destination, plus a terminating null wide character.

If the length of the C wide string in source is less than num, only the content up to the terminating null wide character is copied.

This is the wide character equivalent of strncat (<cstring>).!wcsncat!destination
Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string, including the additional null wide character.
source
C wide string to be appended.
num
Maximum number of characters to be appended.
size_t is an unsigned integral type.!destination is returned.!strncat
Append characters from string (function )
wcscat
Concatenate wide strings (function )
wcsncpy
Copy characters from wide string (function )
wmemcpy
Copy block of wide characters (function )!X!
Cplusplus!int wcsncmp (const wchar_t* wcs1, const wchar_t* wcs2, size_t num);
Compare characters of two wide strings
Compares up to num characters of the C wide string wcs1 to those of the C wide string wcs2.

This function starts comparing the first character of each wide string. If they are equal to each other, it continues with the following pairs until the characters differ, until a terminating null wide character is reached, or until num characters match in both strings, whichever happens first.

This is the wide character equivalent of strncmp (<cstring>).!wcsncmp!wcs1
C wide string to be compared.
wcs2
C wide string to be compared.
num
Maximum number of characters to compare.
size_t is an unsigned integral type.!Returns an integral value indicating the relationship between the wide strings:
A zero value indicates that the characters compared in both strings form the same string.
A value greater than zero indicates that the first character that does not match has a greater value in wcs1 than in wcs2; And a value less than zero indicates the opposite.!strncmp
Compare characters of two strings (function )
wcscmp
Compare two strings (function )
wmemcmp
Compare two blocks of wide characters (function )
wcsrchr
Locate last occurrence of character in wide string (function )
wcsspn
Get span of character set in wide string (function )!X!
Cplusplus!wchar_t* wcsncpy (wchar_t* destination, const wchar_t* source, size_t num);
Copy characters from wide string
Copies the first num characters of source to destination. If the end of the source C wide string (which is signaled by a null wide character) is found before num characters have been copied, destination is padded with additional null wide characters until a total of num characters have been written to it.

No null wide character is implicitly appended at the end of destination if source is longer than num (thus, in this case, destination may not be a null terminated C wide string).

destination and source shall not overlap (see wmemmove for a safer alternative when overlapping).

This is the wide character equivalent of strncpy (<cstring>).!wcsncpy!destination
Pointer to the destination array where the content is to be copied.
source
C wide string to be copied.
num
Maximum number of wide characters to be copied from source.
size_t is an unsigned integral type.!destination is returned.
!strncpy
Copy characters from string (function )
wcscpy
Copy wide string (function )
wmemcpy
Copy block of wide characters (function )
wmemmove
Move block of wide characters (function )
wmemset
Fill array of wide characters (function )!X!
Cplusplus!const wchar_t* wcspbrk (const wchar_t* wcs1, const wchar_t* wcs2);
      wchar_t* wcspbrk (      wchar_t* wcs1, const wchar_t* wcs2);
Locate characters in wide string
Returns a pointer to the first occurrence in wcs1 of any of the wide characters that are part of wcs2, or a null pointer if there are no matches.

The search does not include the terminating null wide characters of either wide strings, but ends there.

This is the wide character equivalent of strpbrk (<cstring>).!wcspbrk!wcs1
C wide string to be scanned.
wcs2
C wide string containing the characters to match.
!A pointer to the first occurrence in wcs1 of any of the wide characters that are part of wcs2, or a null pointer if none of the characters of wcs2 is found in wcs1 before the terminating null wide character.
If none of the characters of wcs2 is present in wcs1, a null pointer is returned.
!strpbrk
Locate characters in string (function )
wcscspn
Get span until character in wide string (function )
wcschr
Locate first occurrence of character in wide string (function )
wcsrchr
Locate last occurrence of character in wide string (function )
wmemchr
Locate character in block of wide characters (function )!X!
Cplusplus!const wchar_t* wcsrchr (const wchar_t* ws, wchar_t wc);
      wchar_t* wcsrchr (      wchar_t* ws, wchar_t wc);
Locate last occurrence of character in wide string
Returns a pointer to the last occurrence of wc in the C wide string ws.

The terminating null wide character is considered part of the string. Therefore, it can also be located to retrieve a pointer to the end of a wide string.

This is the wide character equivalent of strrchr (<cstring>).!wcsrchr!ws
C wide string.
wc
Wide character to be located.!A pointer to the last occurrence of wc in ws.
If wc is not found, the function returns a null pointer.
!strrchr
Locate last occurrence of character in string (function )
wcschr
Locate first occurrence of character in wide string (function )
wmemchr
Locate character in block of wide characters (function )
wcspbrk
Locate characters in wide string (function )!X!
Cplusplus!size_t wcsrtombs (char* dest, const wchar_t** src, size_t max, mbstate_t* ps);
Convert wide-character string to multibyte string
Translates up to max characters of the C wide string indirectly pointed by src to their multibyte sequence equivalents and stores them in the buffer pointed by dest, stopping if a terminating null wide character is encountered (which is also translated and stored, but not counted in the length returned by the function).

The function uses (and updates) the shift state described by ps. If ps is a null pointer, the function uses its own internal shift state, which is altered as necessary only by calls to this function.

If the function translates an entire C wide string (until it finds a null wide character), and dest is not a null pointer, the function sets src to a null pointer value and the resulting state is guaranteed to be the initial conversion state.

The behavior of this function depends on the LC_CTYPE category of the selected C locale.

This is the restartable version of wcstombs (<cstdlib>).
!wcsrtombs!dest
Pointer to an array of char elements long enough to store a C string of max bytes.
If this is a null pointer, the function does not store the resulting sequence, but still counts how many bytes are needed to store the translation of src (parameter max is ignored in this case).
src
Pointer to a C wide string to be translated (an indirect pointer).
This value is modified by the function to point to past the last wide character converted if conversion stops prematurely, or to a null pointer if the function reached the terminating null character.
max
Maximum number of bytes characters to write to dest.
size_t is an unsigned integral type.
ps
Pointer to a mbstate_t object that defines a conversion state.
!The number of bytes written to dest (not including the eventual terminating null character).

If, during the translation, the function encountered a wide character that has no valid multibyte sequence equivalent, the function sets errno to EILSEQ and returns (size_t)-1 (src will point to the first character that could not be translated.

Notice that size_t is an unsigned integral type, and thus none of the values possibly returned is less than zero.!wcstombs
Convert wide-character string to multibyte string (function )
mbsrtowcs
Convert multibyte string to wide-character string (function )
mbrlen
Get length of multibyte character (function )
wcrtomb
Convert wide character to multibyte sequence (function )!X!
Cplusplus!size_t wcsspn (const wchar_t* wcs1, const wchar_t* wcs2);
Get span of character set in wide string
Returns the length of the initial portion of wcs1 which consists only of wide characters that are part of wcs2.

The search does not include the terminating null wide characters of either strings, but ends there.

This is the wide character equivalent of strspn (<cstring>).
!wcsspn!wcs1
C wide string to be scanned.
wcs2
C wide string containing the characters to match.!The length of the initial portion of wcs1 containing only wide characters that appear in wcs2.
Therefore, if all of the wide characters in wcs1 are in wcs2, the function returns the length of the entire wcs1 wide string, and if the first wide character in wcs1 is not in wcs2, the function returns zero.
size_t is an unsigned integral type.!strspn
Get span of character set in string (function )
wcscspn
Get span until character in wide string (function )
wcsstr
Locate substring of wide string (function )
wcsncmp
Compare characters of two wide strings (function )!X!
Cplusplus!const wchar_t* wcsstr (const wchar_t* wcs1, const wchar_t* wcs2);
      wchar_t* wcsstr (      wchar_t* wcs1, const wchar_t* wcs2);
Locate substring of wide string
Returns a pointer to the first occurrence of wcs2 in wcs1, or a null pointer if wcs2 is not part of wcs1.

The matching process does not include the terminating null wide characters, but it stops there.

This is the wide character equivalent of strstr (<cstring>).!wcsstr!wcs1
C wide string to be scanned.
wcs2
C wide string containing the sequence of characters to match.
!A pointer to the first occurrence in wcs1 of the entire sequence of characters specified in wcs2, or a null pointer if the sequence is not present in wcs1.!strstr
Locate substring (function )
wcsspn
Get span of character set in wide string (function )
wcspbrk
Locate characters in wide string (function )
wcschr
Locate first occurrence of character in wide string (function )!X!
Cplusplus!double wcstod (const wchar_t* str, wchar_t** endptr);
Convert wide string to double
Parses the C wide string str interpreting its content as a floating point number and returns its value as a double. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtod (<cstdlib>), interpreting str in the same way.!wcstod!str
C wide string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used by the function.
!On success, the function returns the converted floating point number as a value of type double.
If no valid conversion could be performed, the function returns zero (0.0).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VAL is returned, and errno is set to ERANGE.
If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).
!strtod
Convert string to double (function )
wcstol
Convert wide string to long integer (function )
wcstoul
Convert wide string to unsigned long integer (function )!X!
Cplusplus!float wcstof (const wchar_t* str, wchar_t** endptr);
Convert wide string to float
Parses the C wide string str interpreting its content as a floating point number and returns its value as a float. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtof (<cstdlib>), interpreting str in the same way.!wcstof!str
C wide string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used by the function.!On success, the function returns the converted floating point number as a value of type float.
If no valid conversion could be performed, the function returns zero (0.0F).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VALF is returned, and errno is set to ERANGE.
If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).
!strtof
Convert string to float (function )
wcstod
Convert wide string to double (function )
wcstol
Convert wide string to long integer (function )!X!
Cplusplus!wchar_t* wcstok (wchar_t* wcs, const wchar_t* delimiters);
Split wide string into tokens
A sequence of calls to this function split wcs into tokens, which are sequences of contiguous wide characters separated by any of the wide characters that are part of delimiters.

On a first call, the function expects a C wide string as argument for wcs, whose first character is used as the starting location to scan for tokens. In subsequent calls, the function expects a null pointer and uses the position right after the end of last token as the new starting location for scanning.

This is the wide character equivalent of strtok (<cstdlib>), and operates in the same way (see strtok for more details).!wcstok!wcs
C wide string to truncate.
Notice that the contents of this string are modified and broken into smaller strings (tokens).
Alternativelly, a null pointer may be specified, in which case the function continues scanning where a previous successful call to the function ended.
delimiters
C wide string containing the delimiter wide characters.
These may vary from one call to another.!A pointer to the last token found in the wide string.
A null pointer is returned if there are no tokens left to retrieve.!strtok
Split string into tokens (function )
wcscspn
Get span until character in wide string (function )
wcspbrk
Locate characters in wide string (function )!X!
Cplusplus!long int wcstol (const wchar_t* str, wchar_t** endptr, int base);
Convert wide string to long integer
Parses the C wide string str interpreting its content as an integral number of the specified base, which is returned as a long int value. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtol (<cstdlib>), interpreting str in the same way.!wcstol!str
C wide string beginning with the representation of an integral number.
endptr
Reference to an object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned (0L).
If the value read is out of the range of representable values by a long int, the function returns LONG_MAX or LONG_MIN (defined in <climits>), and errno is set to ERANGE.!strtol
Convert string to long integer (function )
wcstoul
Convert wide string to unsigned long integer (function )
wcstod
Convert wide string to double (function )!X!
Cplusplus!long double wcstold (const wchar_t* str, wchar_t** endptr);
Convert wide string to long double
Parses the C wide string str interpreting its content as a floating point number and returns its value as a long double. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtold (<cstdlib>), interpreting str in the same way.
!wcstold!str
C wide string beginning with the representation of a floating-point number.
endptr
Reference to an already allocated object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted floating point number as a value of type long double.
If no valid conversion could be performed, the function returns zero (0.0L).
If the correct value is out of the range of representable values for the type, a positive or negative HUGE_VALL is returned, and errno is set to ERANGE.
If the correct value would cause underflow, the function returns a value whose magnitude is no greater than the smallest normalized positive number (some library implementations may also set errno to ERANGE in this case).!strtold
Convert string to long double (function )
wcstod
Convert wide string to double (function )
wcstol
Convert wide string to long integer (function )!X!
Cplusplus!long long int strtoll (const wchar_t* str, wchar_t** endptr, int base);
Convert wide string to long long integer
Parses the C wide string str interpreting its content as an integral number of the specified base, which is returned as a long long int value. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtoll (<cstdlib>), interpreting str in the same way.!wcstoll!str
C wide string beginning with the representation of an integral number.
endptr
Reference to an object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
!On success, the function returns the converted integral number as a long int value.
If no valid conversion could be performed, a zero value is returned (0LL).
If the value read is out of the range of representable values by a long long int, the function returns LLONG_MAX or LLONG_MIN (defined in <climits>), and errno is set to ERANGE.!strtoll
Convert string to long long integer (function )
wcstol
Convert wide string to long integer (function )
wcstoull
Convert wide string to unsigned long long integer (function )
wcstod
Convert wide string to double (function )!X!
Cplusplus!unsigned long int wcstoul (const wchar_t* str, wchar_t** endptr, int base);
Convert wide string to unsigned long integer
Parses the C wide string str interpreting its content as an integral number of the specified base, which is returned as an unsigned long int value.

This is the wide character equivalent of strtoul (<cstdlib>), interpreting str in the same way.!wcstoul!str
C wide string containing the representation of an integral number.
endptr
Reference to an object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.
!On success, the function returns the converted integral number as an unsigned long int value.
If no valid conversion could be performed, a zero value is returned.
If the value read is out of the range of representable values by an unsigned long int, the function returns ULONG_MAX (defined in <climits>), and errno is set to ERANGE.!strtoul
Convert string to unsigned long integer (function )
wcstol
Convert wide string to long integer (function )
wcstod
Convert wide string to double (function )!X!
Cplusplus!unsigned long long int wcstoull (const wchar_t* str, wchar_t** endptr, int base);
Convert wide string to unsigned long long integer
Parses the C wide string str interpreting its content as an integral number of the specified base, which is returned as an unsigned long long int value. If endptr is not a null pointer, the function also sets the value of endptr to point to the first character after the number.

This is the wide character equivalent of strtoull (<cstdlib>), interpreting str in the same way.
!wcstoull!str
C wide string beginning with the representation of an integral number.
endptr
Reference to an object of type wchar_t*, whose value is set by the function to the next character in str after the numerical value.
This parameter can also be a null pointer, in which case it is not used.!On success, the function returns the converted integral number as an unsigned long long int value.
If no valid conversion could be performed, a zero value is returned (0ULL).
If the value read is out of the range of representable values by an unsigned long long int, the function returns ULLONG_MAX (defined in <climits>), and errno is set to ERANGE.
!strtoull
Convert string to unsigned long long integer (function )
wcstoul
Convert wide string to unsigned long integer (function )
wcstoll
Convert wide string to long long integer (function )
wcstod
Convert wide string to double (function )!X!
Cplusplus!size_t wcsxfrm (wchar_t* destination, const wchar_t* source, size_t num);
Transform wide string using locale
Transforms the C wide string pointed by source according to the current locale and copies the first num characters of the transformed string to destination, returning its length.

Alternativelly, the function can be used to only retrieve the length, by specifying a null pointer for destination and zero for num.

destination and source shall not overlap.

The behavior of this function depends on the LC_COLLATE category of the selected C locale.

This is the wide character equivalent of strncmp (<cstring>).!wcsxfrm!destination
Pointer to the destination array where the content is to be copied.
It can be a null pointer if the argument for num is zero.
source
C wide string to be transformed.
num
Maximum number of characters to be copied to destination.
size_t is an unsigned integral type.!The length of the transformed wide string, not including the terminating null wide character.
size_t is an unsigned integral type.
!strxfrm
Transform string using locale (function )
wcscoll
Compare two wide strings using locale (function )
wcsncpy
Copy characters from wide string (function )
wcsncmp
Compare characters of two wide strings (function )!X!
Cplusplus!int wctob (wint_t wc);
Convert wide character to single byte
Returns the single-byte representation of the wide character wc if (and only if) wc corresponds to a multibyte character with a length of a single byte in the initial state of a multibyte sequence.

Otherwise, it returns EOF.!wctob!wc
The wint_t promotion of a wide character.
The value is internally converted to a wchar_t to be interpreted.
!If wc translates to a single-byte character in the initial shift state of a multibyte sequence, the function returns its representation as an unsigned char (promoted to a value of type int).
Otherwise, it returns EOF.!btowc
Convert single byte character to wide character (function )
wcrtomb
Convert wide character to multibyte sequence (function )
wcsrtombs
Convert wide-character string to multibyte string (function )!X!
Cplusplus!const wchar_t* wmemchr (const wchar_t* ptr, wchar_t wc, size_t num);
      wchar_t* wmemchr (      wchar_t* ptr, wchar_t wc, size_t num);
Locate character in block of wide characters
Searches within the first num wide characters of the block pointed by ptr for the first occurrence of wc, and returns a pointer to it (or a null pointer if not found).

Notice that, unlike wcschr, the function does not stop comparing after finding a null wide character.

This is the wide character equivalent of memchr (<cstring>).!wmemchr!ptr
Pointer to the array of wchar_t elements to be searched.
wc
Wide character to be located.
num
Number of elements of type wchar_t to compare.
size_t is an unsigned integral type.!A pointer to the first occurrence of wc in the array pointed by ptr.
If the wc is not found, the function returns a null pointer.!memchr
Locate character in block of memory (function )
wmemcmp
Compare two blocks of wide characters (function )
wcschr
Locate first occurrence of character in wide string (function )
wcsrchr
Locate last occurrence of character in wide string (function )!X!
Cplusplus!int wmemcmp (const wchar_t* ptr1, const wchar_t* ptr2, size_t num);
Compare two blocks of wide characters
Compares the first num wide characters of the block of memory pointed by ptr1 to the first num wide characters pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not.

Notice that, unlike wcscmp, the function does not stop comparing after finding a null wide character.

This is the wide character equivalent of memcmp (<cstring>).!wmemcmp!ptr1
Pointer to block of elements of type wchar_t.
ptr2
Pointer to block of elements of type wchar_t.
num
Number of elemtns of type wchar_t to compare.!Returns an integral value indicating the relationship between the content of the blocks:
A zero value indicates that the contents of both memory blocks are equal.
A value greater than zero indicates that the first wide character that does not match in both memory blocks has a greater value in ptr1 than in ptr2; And a value less than zero indicates the opposite.
!memcmp
Compare two blocks of memory (function )
wcscmp
Compare two strings (function )
wcsncmp
Compare characters of two wide strings (function )
wmemchr
Locate character in block of wide characters (function )
wmemcpy
Copy block of wide characters (function )
wmemset
Fill array of wide characters (function )!X!
Cplusplus!wchar_t* wmemcpy (wchar_t* destination, const wchar_t* source, size_t num);
Copy block of wide characters
Copies the values of num elements of type wchar_t from the location pointed by source to the location pointed by destination.

The function does not check for any terminating null wide character in source - it always copies exactly num elements of type wchar_t.

To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall at least be num elements of type wchar_t, and should not overlap (for overlapping memory blocks, wmemmove is a safer approach).

This is the wide character equivalent of memcpy (<cstring>).!wmemcpy!destination
Pointer to the destination array where the content is to be copied.
source
Pointer to the source of data to be copied.
num
Number of bytes to copy.
size_t is an unsigned integral type.!destination is returned.!memcpy
Copy block of memory (function )
wmemmove
Move block of wide characters (function )
wstrncpy
wmemset
Fill array of wide characters (function )!X!
Cplusplus!wchar_t* wmemmove (wchar_t* destination, const wchar_t* source, size_t num);
Move block of wide characters
Copies the values of num elements of type wchar_t from the location pointed by source to the location pointed by destination. Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap.

The function does not check for any terminating null wide character in source - it always copies exactly num elements of type wchar_t.

To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num elements of type wchar_t.

This is the wide character equivalent of memmove (<cstring>).
!wmemmove!destination
Pointer to the destination array where the content is to be copied.
source
Pointer to the source of data to be copied.
num
Number of elements of type wchar_t to copy.
size_t is an unsigned integral type.!destination is returned.
!memmove
Move block of memory (function )
wmemcpy
Copy block of wide characters (function )
wmemcmp
Compare two blocks of wide characters (function )
wmemset
Fill array of wide characters (function )
wcsncpy
Copy characters from wide string (function )!X!
Cplusplus!wchar_t* wmemset (wchar_t* ptr, wchar_t wc, size_t num);
Fill array of wide characters
Sets the first num elements of the array of wide characters pointed by ptr to the value specified as wc.

This is the wide character equivalent of memset (<cstring>).
!wmemset!ptr
Pointer to the array to fill.
wc
Value to be set.
num
Number of bytes to be set to the value.
size_t is an unsigned integral type.!ptr is returned.
!memset
Fill block of memory (function )
wmemcpy
Copy block of wide characters (function )
wcsncpy
Copy characters from wide string (function )
wmemcmp
Compare two blocks of wide characters (function )!X!
Cplusplus!int wprintf (const wchar_t* format, ...);
Print formatted data to stdout
Writes the C wide string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does.

The external representation of wide characters in stdout are multibyte characters: These are obtained as if wcrtomb was called to convert each wide character (using the stream's internal mbstate_t object).

This is the wide character equivalent of printf (<cstdio>).!wprintf!format
C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).
Notice that all format specifiers have the same meaning as in printf; therefore, %lc shall be used to write a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.!On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.
!fputws
Write wide string to stream (function )
wscanf
Read formatted data from stdin (function )
fwprintf
Write formatted data to stream (function )!X!
Cplusplus!int wscanf (const wchar_t* format, ...);
Read formatted data from stdin
Reads data from stdin and stores them according to the C wide string format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.

The external representation of wide characters in stdin are multibyte characters: These are translated as if mbrtowc was called (using the stream's internal mbstate_t object).

This is the wide character equivalent of scanf (<cstdio>).!wscanf!format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!format
C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).
Notice though, that all format specifiers have the same meaning as in scanf; therefore, %lc shall be used to read a wide character (and not %c), as well as %ls shall be used for wide strings (and not %s).
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.!scanf
Read formatted data from stdin (function )
wprintf
Print formatted data to stdout (function )
fgetws
Get wide string from stream (function )!X!
Cplusplus!Multibyte conversion state
Type that holds the information necessary to maintain the state when converting between sequences of multibyte characters and wide characters (either way).

Multibyte sequence encodings may have different shift states that change how the next byte character is interpreted. Values of type mbstate_t are able to keep these states between function calls so that the translation of a sequence can be performed safely across more than one call.

All valid multibyte sequences shall begin (and end) in the same state (called its initial state). A zero-valued mbstate_t object always describes an initial conversion state, although other values may also represent such state (depending on the particular library implementation).

Typical ways to make an mbstate_t object an initial state object are (for an mbstate_t object called mbs):
 
memset (&mbs,0,sizeof(mbs));  // mbs is zero-valued object 

or:
 
mbrlen (NULL,0,&mbs);         // mbs set to an initial state 


Two mbstate_t values shall not be compared to each other to check for a particular state; The initial state status of a mbstate_t object can be checked with function mbsinit.!mbstate_t!X!X!Check if initial conversion state (function )!X!
Cplusplus!Unsigned integral type
Alias of one of the fundamental unsigned integer types.

It is a type able to represent the size of any object in bytes: size_t is the type returned by the sizeof operator and is widely used in the standard library to represent sizes and counts.!size_t!X!X!X!X!
Cplusplus!Time structure
Structure containing a calendar date and time broken down into its components.

The structure contains nine members of type int (in any order), which are:

Member Type Meaning Range
tm_sec int seconds after the minute 0-60*
tm_min int minutes after the hour 0-59
tm_hour int hours since midnight 0-23
tm_mday int day of the month 1-31
tm_mon int months since January 0-11
tm_year int years since 1900 
tm_wday int days since Sunday 0-6
tm_yday int days since January 1 0-365
tm_isdst int Daylight Saving Time flag 
The Daylight Saving Time flag (tm_isdst) is greater than zero if Daylight Saving Time is in effect, zero if Daylight Saving Time is not in effect, and less than zero if the information is not available.

* tm_sec is generally 0-59. The extra range is to accommodate for leap seconds in certain systems.!struct tm!X!X!wcsftime
Format time as wide string (function )
mktime
Convert tm structure to time_t (function )
localtime
Convert time_t to tm as local time (function )
gmtime
Convert time_t to tm as UTC time (function )!X!
Cplusplus!Wide character
Type whose range of values can represent distinct codes for all members of the largest extended character set specified among the supported locales.

In C++, wchar_t is a distinct fundamental type (and thus it is not defined in <cwchar> nor any other header).

In C, this is a typedef of an integral type.!wchar_t!X!X!X!X!
Cplusplus!Wide int type
Typedef of a type able to represent any value of type wchar_t that is a member of the extended character set, as well as an additional value (not part of that set): WEOF.

This type may either be an alias of wchar_t or an alias of an integer type, depending on the particular library implementation. But it shall remain unchanged by default argument promotions from values of type wchar_t.!wint_t!X!X!WEOF
Wide end-of-file (constant )!X!
Cplusplus!This macro expands to a null pointer constant.

A null-pointer constant is an integral constant expression that evaluates to zero (like 0 or 0L), or the cast of such value to type void* (like (void*)0).

A null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.!NULL!X!X!X!X!
Cplusplus!Maximum value of wchar_t
Macro definition of type wchar_t, which expands into the largest possible value of wchar_t.

This macro is also defined in <cstdint>.!WCHAR_MAX!X!X!WCHAR_MIN
Minimum value of wchar_t (constant )!X!
Cplusplus!Minimum value of wchar_t
Macro definition of type wchar_t, which expands into the smallest possible value of wchar_t.

This macro is also defined in <cstdint>.!WCHAR_MIN!X!X!WCHAR_MAX
Maximum value of wchar_t (constant )!X!
Cplusplus!Wide end-of-file
Macro definition of type wint_t that expands into a constant expression that does not match any member of the extended character set.

Unlike its narrow character counterpart (EOF), this value is not necessarily a negative value.

It is used to indicate end-of-file or some other failure conditions on wide oriented operations.

In C++, this macro corresponds to the value of char_traits<wchar_t>::eof().!WEOF!X!X!EOF
End-of-File (constant )!X!
Cplusplus!template < class T, size_t N > class array;
Array class
Arrays are fixed-size sequence containers: they hold a specific number of elements ordered in a strict linear sequence.

Internally, an array does not keep any data other than the elements it contains (not even its size, which is a template parameter, fixed on compile time). It is as efficient in terms of storage size as an ordinary array declared with the language's bracket syntax ([]). This class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.

Unlike the other standard containers, arrays have a fixed size and do not manage the allocation of its elements through an allocator: they are an aggregate type encapsulating a fixed-size array of elements. Therefore, they cannot be expanded or contracted dynamically (see vector for a similar container that can be expanded).

Zero-sized arrays are valid, but they should not be dereferenced (members front, back, and data).

Unlike with the other containers in the Standard Library, swapping two array containers is a linear operation that involves swapping all the elements in the ranges individually, which generally is a considerably less efficient operation. On the other side, this allows the iterators to elements in both containers to keep their original container association.

Another unique feature of array containers is that they can be treated as tuple objects: The <array> header overloads the get function to access the elements of the array as if it was a tuple, as well as specialized tuple_size and tuple_element types.!std::array!X!X!X!X!
Cplusplus!template < class T, class Alloc = allocator<T> > class deque;
Double ended queue
deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back).

Specific libraries may implement deques in different ways, generally as some form of dynamic array. But in any case, they allow for the individual elements to be accessed directly through random access iterators, with storage handled automatically by expanding and contracting the container as needed.

Therefore, they provide a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in a deque by offsetting a pointer to another element causes undefined behavior.

Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways: While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a deque can be scattered in different chunks of storage, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators). Therefore, deques are a little more complex internally than vectors, but this allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocations become more expensive.

For operations that involve frequent insertion or removals of elements at positions other than the beginning or the end, deques perform worse and have less consistent iterators and references than lists and forward lists.!std::deque!X!X!X!X!
Cplusplus!template < class T, class Alloc = allocator<T> > class forward_list;
Forward list
Forward lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence.

Forward lists are implemented as singly-linked lists; Singly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept by the association to each element of a link to the next element in the sequence.

The main design difference between a forward_list container and a list container is that the first keeps internally only a link to the next element, while the latter keeps two links per element: one pointing to the next element and one to the preceding one, allowing efficient iteration in both directions, but consuming additional storage per element and with a slight higher time overhead inserting and removing elements. forward_list objects are thus more efficient than list objects, although they can only be iterated forwards. 

Compared to other base standard sequence containers (array, vector and deque), forward_list perform generally better in inserting, extracting and moving elements in any position within the container, and therefore also in algorithms that make intensive use of these, like sorting algorithms.

The main drawback of forward_lists and lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a forward_list one has to iterate from the beginning to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).

The forward_list class template has been designed with efficiency in mind: By design, it is as efficient as a simple handwritten C-style singly-linked list, and in fact is the only standard container to deliberately lack a size member function for efficiency considerations: due to its nature as a linked list, having a size member that takes constant time would require it to keep an internal counter for its size (as list does). This would consume some extra storage and make insertion and removal operations slightly less efficient. To obtain the size of a forward_list object, you can use the distance algorithm with its begin and end, which is an operation that takes linear time.!std::forward_list!X!X!X!X!
Cplusplus!template < class T, class Alloc = allocator<T> > class list;
List
Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions.

List containers are implemented as doubly-linked lists; Doubly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept internally by the association to each element of a link to the element preceding it and a link to the element following it.

They are very similar to forward_list: The main difference being that forward_list objects are single-linked lists, and thus they can only be iterated forwards, in exchange for being somewhat smaller and more efficient.

Compared to other base standard sequence containers (array, vector and deque), lists perform generally better in inserting, extracting and moving elements in any position within the container for which an iterator has already been obtained, and therefore also in algorithms that make intensive use of these, like sorting algorithms.

The main drawback of lists and forward_lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a list, one has to iterate from a known position (like the beginning or the end) to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).
!std::list!X!X!X!X!
Cplusplus!template < class Key,                                     // map::key_type
           class T,                                       // map::mapped_type
           class Compare = less<Key>,                     // map::key_compare
           class Alloc = allocator<pair<const Key,T> >    // map::allocator_type
           > class map;
Map
Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.

In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:

 
typedef pair<const Key, T> value_type;


Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).

map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.

The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ((operator[]).

Maps are typically implemented as binary search trees.!std::map!X!X!X!X!
Cplusplus!template < class Key,                                     // multimap::key_type
           class T,                                       // multimap::mapped_type
           class Compare = less<Key>,                     // multimap::key_compare
           class Alloc = allocator<pair<const Key,T> >    // multimap::allocator_type
           > class multimap;
Multiple-key map
Multimaps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order, and where multiple elements can have equivalent keys.

In a multimap, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:

 
typedef pair<const Key, T> value_type;


Internally, the elements in a multimap are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).

multimap containers are generally slower than unordered_multimap containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.

Multimaps are typically implemented as binary search trees.!std::multimap!X!X!X!X!
Cplusplus!template <class T, class Container = vector<T>,
  class Compare = less<typename Container::value_type> > class priority_queue;
Priority queue
Priority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.

This context is similar to a heap, where elements can be inserted at any moment, and only the max heap element can be retrieved (the one at the top in the priority queue).

Priority queues are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are popped from the "back" of the specific container, which is known as the top of the priority queue.

The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall be accessible through random access iterators and support the following operations:
front()
push_back()
pop_back()

The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used.

Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions make_heap, push_heap and pop_heap when needed.!std::priority_queue!X!X!X!X!
Cplusplus!template <class T, class Container = deque<T> > class queue;
FIFO queue
queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.

queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".

The underlying container may be one of the standard container class template or some other specifically designed container class. This underlying container shall support at least the following operations:
front
back
push_back
pop_front

The standard container classes deque and list fulfill these requirements. By default, if no container class is specified for a particular queue class instantiation, the standard container deque is used.!std::queue!X!X!X!X!
Cplusplus!template < class T,                        // multiset::key_type/value_type
           class Compare = less<T>,        // multiset::key_compare/value_compare
           class Alloc = allocator<T> >    // multiset::allocator_type
           > class multiset;
Multiple-key set
Multisets are containers that store elements following a specific order, and where multiple elements can have equivalent values.

In a multiset, the value of an element also identifies it (the value is itself the key, of type T). The value of the elements in a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.

Internally, the elements in a multiset are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).

multiset containers are generally slower than unordered_multiset containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.

Multisets are typically implemented as binary search trees.!std::multiset!X!X!X!X!
Cplusplus!template < class T,                        // set::key_type/value_type
           class Compare = less<T>,        // set::key_compare/value_compare
           class Alloc = allocator<T>      // set::allocator_type
           > class set;
Set
Sets are containers that store unique elements following a specific order.

In a set, the value of an element also identifies it (the value is itself the key, of type T), and each value must be unique. The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.

Internally, the elements in a set are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).

set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.

Sets are typically implemented as binary search trees.!std::set!X!X!X!X!
Cplusplus!template <class T, class Container = deque<T> > class stack;
LIFO stack
Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.

stacks are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed/popped from the "back" of the specific container, which is known as the top of the stack.

The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall support the following operations:
back
push_back
pop_back

The standard container classes vector, deque and list fulfill these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container deque is used.
!std::stack!X!X!X!X!
Cplusplus!template < class Key,                                    // unordered_map::key_type
           class T,                                      // unordered_map::mapped_type
           class Hash = hash<Key>,                       // unordered_map::hasher
           class Pred = equal_to<Key>,                   // unordered_map::key_equal
           class Alloc = allocator< pair<const Key,T> >  // unordered_map::allocator_type
           > class unordered_map;
Unordered Map
Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.

In an unordered_map, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.

Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).

unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.

Unordered maps implement the direct access operator (operator[]) which allows for direct access of the mapped value using its key value as argument.

Iterators in the container are at least forward iterators.!std::unordered_map!X!X!X!X!
Cplusplus!template < class Key,                                    // unordered_multimap::key_type
           class T,                                      // unordered_multimap::mapped_type
           class Hash = hash<Key>,                       // unordered_multimap::hasher
           class Pred = equal_to<Key>,                   // unordered_multimap::key_equal
           class Alloc = allocator< pair<const Key,T> >  // unordered_multimap::allocator_type
           > class unordered_multimap;
Unordered Multimap
Unordered multimaps are associative containers that store elements formed by the combination of a key value and a mapped value, much like unordered_map containers, but allowing different elements to have equivalent keys.

In an unordered_multimap, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.

Internally, the elements in the unordered_multimap are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).

Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.

Iterators in the container are at least forward iterators.

Notice that this container is not defined in its own header, but shares header <unordered_map> with unordered_map.!std::unordered_multimap!X!X!X!X!
Cplusplus!template < class Key,                         // unordered_multiset::key_type/value_type
           class Hash = hash<Key>,            // unordered_multiset::hasher
           class Pred = equal_to<Key>,        // unordered_multiset::key_equal
           class Alloc = allocator<Key>       // unordered_multiset::allocator_type
           > class unordered_multiset;
Unordered Multiset
Unordered multisets are containers that store elements in no particular order, allowing fast retrieval of individual elements based on their value, much like unordered_set containers, but allowing different elements to have equivalent values.

In an unordered_multiset, the value of an element is at the same time its key, used to identify it. Keys are immutable, therefore, the elements in an unordered_multiset cannot be modified once in the container - they can be inserted and removed, though.

Internally, the elements in the unordered_multiset are not sorted in any particular, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).

Elements with equivalent values are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.

Iterators in the container are at least forward iterators.

Notice that this container is not defined in its own header, but shares header <unordered_set> with unordered_set.!std::unordered_multiset!X!X!X!X!
Cplusplus!template < class Key,                        // unordered_set::key_type/value_type
           class Hash = hash<Key>,           // unordered_set::hasher
           class Pred = equal_to<Key>,       // unordered_set::key_equal
           class Alloc = allocator<Key>      // unordered_set::allocator_type
           > class unordered_set;
Unordered Set
Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value.

In an unordered_set, the value of an element is at the same time its key, that identifies it uniquely. Keys are immutable, therefore, the elements in an unordered_set cannot be modified once in the container - they can be inserted and removed, though.

Internally, the elements in the unordered_set are not sorted in any particular order, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).

unordered_set containers are faster than set containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.

Iterators in the container are at least forward iterators.
!std::unordered_set!X!X!X!X!
Cplusplus!template < class T, class Alloc = allocator<T> > class vector; // generic template
Vector
Vectors are sequence containers representing arrays that can change in size.

Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.

Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the container.

Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity (see push_back).

Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.

Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent iterators and references than lists and forward_lists.!std::vector!X!X!X!X!
Cplusplus!template < class T, class Alloc = allocator<T> > class vector; // generic template
template <class Alloc> class vector<bool,Alloc>;               // bool specialization
Vector of bool
This is a specialized version of vector, which is used for elements of type bool and optimizes for space.

It behaves like the unspecialized version of vector, with the following changes:
The storage is not necessarily an array of bool values, but the library implementation may optimize storage so that each value is stored in a single bit.
Elements are not constructed using the allocator object, but their value is directly set on the proper bit in the internal storage.
Member function flip and a new signature for member swap.
A special member type, reference, a class that accesses individual bits in the container's internal storage with an interface that emulates a bool reference. Conversely, member type const_reference is a plain bool.
The pointer and iterator types used by the container are not necessarily neither pointers nor conforming iterators, although they shall simulate most of their expected behavior.

These changes provide a quirky interface to this specialization and favor memory optimization over processing (which may or may not suit your needs). In any case, it is not possible to instantiate the unspecialized template of vector for bool directly. Workarounds to avoid this range from using a different type (char, unsigned char) or container (like deque) to use wrapper types or further specialize for specific allocator types.

bitset is a class that provides a similar functionality for fixed-size arrays of bits.!std::vector<bool>!X!X!X!X!
Cplusplus!template <class T> struct atomic;
Atomic
Objects of atomic types contain a value of a particular type (T).

The main characteristic of atomic objects is that access to this contained value from different threads cannot cause data races (i.e., doing that is well-defined behavior, with accesses properly sequenced). Generally, for all other objects, the possibility of causing a data race for accessing the same object concurrently qualifies the operation as undefined behavior.

Additionally, atomic objects have the ability to synchronize access to other non-atomic objects in their threads by specifying different memory orders.
!std::atomic!X!X!X!X!
Cplusplus!struct atomic_flag;
Atomic flag
Atomic flags are boolean atomic objects that support two operations: test-and-set and clear.

Atomic flags are lock-free (this is the only type guaranteed to be lock-free on all library implementations).!std::atomic_flag!X!X!X!X!
Cplusplus!enum memory_order;
Memory order
Used as an argument to functions that conduct atomic operations to specify how other operations on different threads are synchronized.

It is defined as:
1
2
3
4
5
6
7
8
typedef enum memory_order {
    memory_order_relaxed,   // relaxed
    memory_order_consume,   // consume
    memory_order_acquire,   // acquire
    memory_order_release,   // release
    memory_order_acq_rel,   // acquire/release
    memory_order_seq_cst    // sequentially consistent
} memory order;


All atomic operations produce well-defined behavior with respect to an atomic object when multiple threads access it: each atomic operation is entirely performed on the object before any other atomic operation can access it. This guarantees no data races on these objects, and this is precisely the feature that defines atomicity.

But each thread may perform operations on memory locations other than the atomic object itself: and these other operations may produce visible side effects on other threads. Arguments of this type allow to specify a memory order for the operation that determines how these (possibly non-atomic) visible side effects are synchronized among threads, using the atomic operations as synchronization points:

memory_order_relaxed
The operation is ordered to happen atomically at some point.
This is the loosest memory order, providing no guarantees on how memory accesses in different threads are ordered with respect to the atomic operation.
memory_order_consume
[Applies to loading operations]
The operation is ordered to happen once all accesses to memory in the releasing thread that carry a dependency on the releasing operation (and that have visible side effects on the loading thread) have happened.
memory_order_acquire
[Applies to loading operations]
The operation is ordered to happen once all accesses to memory in the releasing thread (that have visible side effects on the loading thread) have happened.
memory_order_release
[Applies to storing operations]
The operation is ordered to happen before a consume or acquire operation, serving as a synchronization point for other accesses to memory that may have visible side effects on the loading thread.
memory_order_acq_rel
[Applies to loading/storing operations]
The operation loads acquiring and stores releasing (as defined above for memory_order_acquire and memory_order_release).
memory_order_seq_cst
The operation is ordered in a sequentially consistent manner: All operations using this memory order are ordered to happen once all accesses to memory that may have visible side effects on the other threads involved have already happened.
This is the strictest memory order, guaranteeing the least unexpected side effects between thread interactions though the non-atomic memory accesses.
For consume and acquire loads, sequentially consistent store operations are considered releasing operations.!std::memory_order!X!X!X!X!
Cplusplus!extern "C" void atomic_signal_fence (memory_order sync) noexcept;
Signal fence
Establishes a single-thread fence: The point of call to this function becomes either an acquire or a release ordering point (or both) within a single thread.

This function is equivalent to atomic_thread_fence except that no inter-thread synchronization happens because of the call. The function operates as a directive to the compiler inhibiting it from making optimizations that involve moving writing operations beyond a releasing fence or read operations before an acquire fence.!atomic_signal_fence!sync
Synchronization mode for the operation.
This shall be one of these possible values of the enum type memory_order:
value memory order description
memory_order_relaxed Relaxed The call has no effects.
memory_order_consume Consume Sets up an acquire signal fence:
Orders instructions with respect to the last release or sequentially consistent operation in the same thread.
memory_order_acquire Acquire
memory_order_release Release Sets up a release signal fence:
Orders instructions with respect to the next acquire operation in the same thread.
memory_order_acq_rel Acquire/Release Sets up a signal fence that is both an acquire fence and a release fence:
All instructions are ordered with respect to the last release or sequentially consistent operation and with the next acquire operation in the same thread.
memory_order_seq_cst Sequentially consistent Sets up a sequentially consistent acquire and release signal fence:
All instructions are ordered with respect to the other sequentially consistent operations in the same thread.
!none!atomic_thread_fence
Thread fence (function )!X!
Cplusplus!extern "C" void atomic_thread_fence (memory_order sync) noexcept;
Thread fence
Establishes a multi-thread fence: The point of call to this function becomes either an acquire or a release synchronization point (or both).

All visible side effects from the releasing thread that happen before the call to this function are synchronized to also happen before the call this function in the acquiring thread.

Calling this function has the same effects as a load or store atomic operation, but without involving an atomic value.!atomic_thread_fence!sync
Synchronization mode for the operation.
This shall be one of these possible values of the enum type memory_order:
value memory order description
memory_order_relaxed Relaxed The call has no effects.
memory_order_consume Consume Sets up an acquire fence:
Synchronizes all visible side effects from the last release or sequentially consistent operation.
memory_order_acquire Acquire
memory_order_release Release Sets up a release fence:
Synchronizes side effects with the next acquire operation.
memory_order_acq_rel Acquire/Release Sets up a fence that is both an acquire fence and a release fence:
Synchronizes all visible side effects from the last release or sequentially consistent operation and with the next acquire operation.
memory_order_seq_cst Sequentially consistent Sets up a sequentially consistent acquire and release fence:
Synchronizes all visible side effects with the other sequentially consistent operations, following a single total order.
!sync
Synchronization mode for the operation.
This shall be one of these possible values of the enum type memory_order:
value memory order description
memory_order_relaxed Relaxed The call has no effects.
memory_order_consume Consume Sets up an acquire fence:
Synchronizes all visible side effects from the last release or sequentially consistent operation.
memory_order_acquire Acquire
memory_order_release Release Sets up a release fence:
Synchronizes side effects with the next acquire operation.
memory_order_acq_rel Acquire/Release Sets up a fence that is both an acquire fence and a release fence:
Synchronizes all visible side effects from the last release or sequentially consistent operation and with the next acquire operation.
memory_order_seq_cst Sequentially consistent Sets up a sequentially consistent acquire and release fence:
Synchronizes all visible side effects with the other sequentially consistent operations, following a single total order.
!atomic_signal_fence
Signal fence (function )!X!
Cplusplus!template <class T>
  T kill_dependency (T y) noexcept;
Kill dependency
Returns the value of y without carrying a dependency.

Atomic operations that use memory_order_consume as memory order require the compiler to check for the dependencies carried by accessing memory locations used to produce the value released. Synchronizing such carried dependencies may cause certain hardware fences to be set up and force the compiler to forego certain potential optimizations involving these memory locations.

Calling this function indicates the compiler that any dependencies in y should not be carried over to the returned value, not requiring them to be synchronized.!std::kill_dependency!y
A value.!The value y without carrying dependencies.!memory_order
Memory order (enum )!X!
Cplusplus!ATOMIC_FLAG_INIT
Initialization of atomic flag
This macro is defined in such a way that it can be used to initialize an object of type atomic_flag to the clear state.

For a static-duration object, this initialization is static.!ATOMIC_FLAG_INIT!X!X!atomic_flag
Atomic flag (class )
atomic_flag::atomic_flag
Construct atomic flag (public member function )!X!
Cplusplus!ATOMIC_VAR_INIT(val)
Initialization of atomic variable
This macro expands to a token sequence suitable to initialize an atomic object (of static storage duration) with a value of val.

This macro exists for compatibility with C implementations, in which it is used as a constructor-like function for (default-constructed) atomic objects; In C++, this initialization may be performed directly by the initialization constructor.!ATOMIC_VAR_INIT!val
Value to use for initialization.
The object contained in the atomic object shall support constant initialization from this value.!A sequence of tokens suitable to initialize an atomic object with val.!atomic_init
Initialize atomic object (function )
atomic::atomic
Construct atomic (public member function )
ATOMIC_FLAG_INIT
Initialization of atomic flag (macro )!X!
Cplusplus!template <class T>
bool atomic_compare_exchange_strong (volatile atomic<T>* obj, T* expected, T val) noexcept;
template <class T>
bool atomic_compare_exchange_strong (atomic<T>* obj, T* expected, T val) noexcept;
overloads (2) 
bool atomic_compare_exchange_strong (volatile A* obj, T* expected, T val) noexcept;
bool atomic_compare_exchange_strong (A* obj, T* expected, T val) noexcept;
Compare and exchange contained value (strong)
Compares the contents of the value contained in obj with the value pointed by expected:
- if true, it replaces the contained value with val.
- if false, it replaces the value pointed by expected with the contained value .

The function always accesses the contained value to read it, and -if the comparison is true- it then also replaces it. But the entire operation is atomic: the value cannot be modified by other threads between the instant its value is read and the moment it is replaced.

Note that this function compares directly the physical contents of the contained value with the contents of expected; This may result in failed comparisons for values that compare equal using operator== (if the underlying type has padding bits, trap values, or alternate representations of the same value), although this comparison shall converge rapidly in a loop that preserves expected such as those generally used with atomic_compare_exchange_weak.

Unlike atomic_compare_exchange_weak, this strong version is required to always return true when expected indeed compares equal to the contained object, not allowing spurious failures. However, on certain machines, and for certain algorithms that check this in a loop, compare_exchange_weak may lead to significantly better performance.

See atomic::compare_exchange_strong for the equivalent member function of atomic.!std::atomic_compare_exchange_strong!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
expected
Pointer to an object whose value is compared to the contained value, and which -in case it doesn't match- may be overwritten with the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
val
Value to copy to the contained object in case expected matches the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
!true if *expected compares equal to the contained value.
false otherwise.!atomic_compare_exchange_weak
Compare and exchange contained value (weak) (function )
atomic_compare_exchange_strong_explicit
Compare and exchange contained value (strong, explicit) (function )
atomic_exchange
Read and modify contained value (function )
atomic::compare_exchange_strong
Compare and exchange contained value (strong) (public member function )!X!
Cplusplus!template <class T>
bool atomic_compare_exchange_strong_explicit (volatile atomic<T>* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
template <class T>
bool atomic_compare_exchange_strong_explicit (atomic<T>* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
overloads (2) 
bool atomic_compare_exchange_strong_explicit (volatile A* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit (A* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
Compare and exchange contained value (strong, explicit)
Operates like atomic_compare_exchange_strong, but it additionally allows to specify the memory order used both in case of success and failure.

See atomic::compare_exchange_strong for the equivalent member function of atomic.
!std::atomic_compare_exchange_strong_explicit!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
expected
Pointer to an object whose value is compared to the contained value, and which -in case it doesn't match- may be overwritten with the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
val
Value to copy to the contained object in case expected matches the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
success
Synchronization mode for the operation in case expected matches the contained value.
This shall be a value of the enum type memory_order.
failure
Synchronization mode for the operation in case expected does not match the contained value.
This shall be a value of the enum type memory_order that is neither memory_order_release nor memory_order_acq_rel, and which is not stronger than success.!true if *expected compares equal to the contained value.
false otherwise.!atomic_compare_exchange_strong
Compare and exchange contained value (strong) (function )
atomic_compare_exchange_weak_explicit
Compare and exchange contained value (weak, explicit) (function )
atomic_exchange
Read and modify contained value (function )
atomic::compare_exchange_strong
Compare and exchange contained value (strong) (public member function )!X!
Cplusplus!template (1) 
template <class T>
bool atomic_compare_exchange_weak (volatile atomic<T>* obj, T* expected, T val) noexcept;
template <class T>
bool atomic_compare_exchange_weak (atomic<T>* obj, T* expected, T val) noexcept;
overloads (2) 
bool atomic_compare_exchange_weak (volatile A* obj, T* expected, T val) noexcept;
bool atomic_compare_exchange_weak (A* obj, T* expected, T val) noexcept;
Compare and exchange contained value (weak)
Compares the contents of the value contained in obj with that of expected:
- if true, it replaces the contained value with val.
- if false, it replaces the value pointed by expected with the contained value .

The function always accesses the contained value to read it, and -if the comparison is true- it then also replaces it. But the entire operation is atomic: the value cannot be modified by other threads between the instant its value is read and the moment it is replaced.

Note that this function compares directly the physical contents of the contained value with the contents of expected; This may result in failed comparisons for values that compare equal using operator== (if the underlying type has padding bits, trap values, or alternate representations of the same value), although this comparison shall converge rapidly in a loop that preserves expected.

Unlike atomic_compare_exchange_strong, this weak version is allowed to fail spuriously by returning false even when *expected indeed compares equal to the value contained in obj. This may be acceptable behavior for certain looping algorithms, and may lead to significantly better performance on some platforms. On these spurious failures, the function returns false while not modifying expected.

For non-looping algorithms, atomic_compare_exchange_strong is generally preferred.

See atomic::compare_exchange_weak for the equivalent member function of atomic.
!std::atomic_compare_exchange_weak!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
expected
Pointer to an object whose value is compared to the contained value, and which -in case it doesn't match- may be overwritten with the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
val
Value to copy to the contained object in case expected matches the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
!true if *expected compares equal to the contained value (and does not fail spuriously).
false otherwise.
!atomic_compare_exchange_strong
Compare and exchange contained value (strong) (function )
atomic_compare_exchange_weak_explicit
Compare and exchange contained value (weak, explicit) (function )
atomic_exchange
Read and modify contained value (function )
atomic::compare_exchange_weak
Compare and exchange contained value (weak) (public member function )!X!
Cplusplus!template (1) 
template <class T>
bool atomic_compare_exchange_weak_explicit (volatile atomic<T>* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
template <class T>
bool atomic_compare_exchange_weak_explicit (atomic<T>* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
overloads (2) 
bool atomic_compare_exchange_weak_explicit (volatile A* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_weak_explicit (A* obj,
        T* expected, T val, memory_order success, memory_order failure) noexcept;
Compare and exchange contained value (weak, explicit)
Operates like atomic_compare_exchange_weak, but it additionally allows to specify the memory order used both in case of success and failure.

See atomic::compare_exchange_weak for the equivalent member function of atomic.!std::atomic_compare_exchange_weak_explicit!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
expected
Pointer to an object whose value is compared to the contained value, and which -in case it doesn't match- may be overwritten with the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
val
Value to copy to the contained object in case expected matches the contained value.
T is the type of the value contained in the atomic object (atomic's template parameter).
success
Synchronization mode for the operation in case expected matches the contained value.
This shall be a value of the enum type memory_order.
failure
Synchronization mode for the operation in case expected does not match the contained value.
This shall be a value of the enum type memory_order that is neither memory_order_release nor memory_order_acq_rel, and which is not stronger than success.!true if *expected compares equal to the contained value (and does not fail spuriously).
false otherwise.!atomic_compare_exchange_weak
Compare and exchange contained value (weak) (function )
atomic_compare_exchange_strong_explicit
Compare and exchange contained value (strong, explicit) (function )
atomic_exchange
Read and modify contained value (function )
atomic::compare_exchange_weak
Compare and exchange contained value (weak) (public member function )!X!
Cplusplus!template (1) 
template <class T> T atomic_exchange (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_exchange (atomic<T>* obj, T val) noexcept;
overloads (2) 
T atomic_exchange (volatile A* obj, T val) noexcept;
T atomic_exchange (A* obj, T val) noexcept;
Read and modify contained value
Replaces the value contained in obj with val and returns the value obj had immediately before.

The entire operation is atomic (an atomic read-modify-write operation): the value of obj is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

See atomic::exchange for the equivalent member function of atomic.!std::atomic_exchange!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to initialize the contained object with.
T is the type of the value contained in the atomic object (atomic's template parameter).
!The value contained in obj before the call.
T is the type of the contained value (atomic's template parameter).!atomic_exchange_explicit
Read and modify contained value (explicit memory order) (function )
atomic_load
Read contained value (function )
atomic_store
Modify contained value (function )
atomic::exchange
Access and modify contained value (public member function )!X!
Cplusplus!template (1) 
template <class T>
T atomic_store_explicit (volatile atomic<T>* obj, T val, memory_order sync) noexcept;
template <class T>
T atomic_store_explicit (atomic<T>* obj, T val, memory_order sync) noexcept;
overloads (2) 
T atomic_store_explicit (volatile A* obj, T val, memory_order sync) noexcept;
T atomic_store_explicit (A* obj, T val, memory_order sync) noexcept;
Read and modify contained value (explicit memory order)
Replaces the value contained in obj with val and returns the value obj had immediately before.

The entire operation is atomic (an atomic read-modify-write operation): the value of obj is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

See atomic::exchange for the equivalent member function of atomic.
!std::atomic_exchange_explicit!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to assign to the contained object.
T is the type of the value contained in the atomic object (atomic's template parameter).
sync
Synchronization mode for the operation.
This shall be a values of the enum type memory_order.!The value contained in obj before the call.
T is the type of the contained value (atomic's template parameter).!atomic_exchange
Read and modify contained value (function )
atomic_load_explicit
Read contained value (explicit memory order) (function )
atomic_store_explicit
Modify contained value (explicit memory order) (function )
atomic::exchange
Access and modify contained value (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T> T atomic_fetch_add (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_fetch_add (atomic<T>* obj, T val) noexcept;
template (pointer) (2) 
template <class U> U* atomic_fetch_add (volatile atomic<U*>* obj, ptrdiff_t val) noexcept;
template <class U> U* atomic_fetch_add (atomic<U*>* obj, ptrdiff_t val) noexcept;
overloads (3) 
T atomic_fetch_add (volatile A* obj, M val) noexcept;
T atomic_fetch_add (A* obj, M val) noexcept;
Add to contained value
Adds val to the value contained in obj.

The entire operation is atomic: the value cannot be modified between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using sequential consistency (memory_order_seq_cst). To modify the value with a different memory ordering, see atomic_fetch_add_explicit.

See atomic::fetch_add and atomic::operator+= for equivalent member functions of atomic.!std::atomic_fetch_add!obj
Pointer to an atomic object that contains either an integral or a pointer value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to add.
T is the type of the value contained by the atomic object (atomic's template parameter).
ptrdiff_t is a signed integral type.
M is T if T is an integral type, or ptrdiff_t if T is a pointer.!The contained value before the call.
T (or U*) is the type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_add_explicit
Add to contained value (explicit memory order) (function )
atomic_fetch_sub
Subtract from contained value (function )
atomic::fetch_add
Add to contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T>
T atomic_fetch_add_explicit (volatile atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template <class T>
T atomic_fetch_add_explicit (atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template (pointer) (2) 
template <class U>
U* atomic_fetch_add_explicit (volatile atomic<U*>* obj,
                              ptrdiff_t val, memory_order sync) noexcept;
template <class U>
U* atomic_fetch_add_explicit (atomic<U*>* obj,
                              ptrdiff_t val, memory_order sync) noexcept;
overloads (3) 
T atomic_fetch_add_explicit (volatile A* obj, M val, memory_order sync) noexcept;
T atomic_fetch_add_explicit (A* obj, M val, memory_order sync) noexcept;
Add to contained value (explicit memory order)
Adds val the value contained in obj, using the memory order specified by sync.

The entire operation is atomic: the value cannot be modified between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using the memory order specified by argument sync.

See atomic::fetch_add for the equivalent member function of atomic.
!std::atomic_fetch_add_explicit!obj
Pointer to an atomic object that contains either an integral or a pointer value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to add.
T is the type of the value contained by the atomic object (atomic's template parameter).
ptrdiff_t is a signed integral type.
M is T if T is an integral type, or ptrdiff_t if T is a pointer.
sync
Synchronization mode for the operation.
This shall be one of the values of the enum type memory_order.!The contained value before the call.
T (or U*) is the type of the value contained by the atomic object (atomic's template parameter).
!atomic_fetch_sub_explicit
Subtract from contained value (explicit memory order) (function )
atomic_fetch_add
Add to contained value (function )
atomic::fetch_add
Add to contained value (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T> T atomic_fetch_and (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_fetch_and (atomic<T>* obj, T val) noexcept;
overloads (2) 
T atomic_fetch_and (volatile A* obj, T val) noexcept;
T atomic_fetch_and (A* obj, T val) noexcept;
Apply bitwise AND to contained value
Reads the value contained in obj and replaces it by the result of performing a bitwise AND operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using sequential consistency (memory_order_seq_cst). To modify the value with a different memory ordering, see atomic_fetch_and_explicit.

See atomic::fetch_and and atomic::operator&= for equivalent member functions of atomic.!std::atomic_fetch_and!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_and_explicit
Apply bitwise AND to contained value (explicit memory order) (function )
atomic_fetch_or
Apply bitwise OR to contained value (function )
atomic::fetch_and
Apply bitwise AND to contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T>
T atomic_fetch_and_explicit (volatile atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template <class T>
T atomic_fetch_and_explicit (atomic<T>* obj,
                             T val, memory_order sync) noexcept;
overloads (2) 
T atomic_fetch_and_explicit (volatile A* obj, T val, memory_order sync) noexcept;
T atomic_fetch_and_explicit (A* obj, T val, memory_order sync) noexcept;
Apply bitwise AND to contained value (explicit memory order)
Reads the value contained in obj and replaces it by the result of performing a bitwise AND operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using the memory order specified by argument sync.

See atomic::fetch_and for the equivalent member function of atomic.!std::atomic_fetch_and_explicit!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
sync
Synchronization mode for the operation.
This shall be one of the values of the enum type memory_order.!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_or_explicit
Apply bitwise OR to contained value (explicit memory order) (function )
atomic_fetch_and
Apply bitwise AND to contained value (function )
atomic::fetch_and
Apply bitwise AND to contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T> T atomic_fetch_or (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_fetch_or (atomic<T>* obj, T val) noexcept;
overloads (2) 
T atomic_fetch_or (volatile A* obj, T val) noexcept;
T atomic_fetch_or (A* obj, T val) noexcept;
Apply bitwise OR to contained value
Reads the value contained in obj and replaces it by the result of performing a bitwise OR operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using sequential consistency (memory_order_seq_cst). To modify the value with a different memory ordering, see atomic_fetch_and_explicit.

See atomic::fetch_or and atomic::operator|= for equivalent member functions of atomic.
!std::atomic_fetch_or!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_or_explicit
Apply bitwise OR to contained value (explicit memory order) (function )
atomic_fetch_and
Apply bitwise AND to contained value (function )
atomic::fetch_or
Apply bitwise OR to contained value (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T>
T atomic_fetch_or_explicit (volatile atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template <class T>
T atomic_fetch_or_explicit (atomic<T>* obj,
                             T val, memory_order sync) noexcept;
overloads (2) 
T atomic_fetch_or_explicit (volatile A* obj, T val, memory_order sync) noexcept;
T atomic_fetch_or_explicit (A* obj, T val, memory_order sync) noexcept;
Apply bitwise OR to contained value (explicit memory order)
Reads the value contained in obj and replaces it by the result of performing a bitwise OR operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using the memory order specified by argument sync.

See atomic::fetch_or for the equivalent member function of atomic.!std::atomic_fetch_or_explicit!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
sync
Synchronization mode for the operation.
This shall be one of the values of the enum type memory_order.!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_or
Apply bitwise OR to contained value (function )
atomic_fetch_and_explicit
Apply bitwise AND to contained value (explicit memory order) (function )
atomic::fetch_or
Apply bitwise OR to contained value (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T> T atomic_fetch_sub (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_fetch_sub (atomic<T>* obj, T val) noexcept;
template (pointer) (2) 
template <class U> U* atomic_fetch_sub (volatile atomic<U*>* obj, ptrdiff_t val) noexcept;
template <class U> U* atomic_fetch_sub (atomic<U*>* obj, ptrdiff_t val) noexcept;
overloads (3) 
T atomic_fetch_sub (volatile A* obj, M val) noexcept;
T atomic_fetch_sub (A* obj, M val) noexcept;
Subtract from contained value
Subtracts val from the value contained in obj.

The entire operation is atomic: the value cannot be modified between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using sequential consistency (memory_order_seq_cst). To modify the value with a different memory ordering, see atomic_fetch_sub_explicit.

See atomic::fetch_sub and atomic::operator-= for equivalent member functions of atomic.!std::atomic_fetch_sub!obj
Pointer to an atomic object that contains either an integral or a pointer value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to subtract.
T is the type of the value contained by the atomic object (atomic's template parameter).
ptrdiff_t is a signed integral type.
M is T if T is an integral type, or ptrdiff_t if T is a pointer.!The contained value before the call.
T (or U*) is the type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_sub_explicit
Subtract from contained value (explicit memory order) (function )
atomic_fetch_add
Add to contained value (function )
atomic::fetch_sub
Subtract from contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T>
T atomic_fetch_sub_explicit (volatile atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template <class T>
T atomic_fetch_sub_explicit (atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template (pointer) (2) 
template <class U>
U* atomic_fetch_sub_explicit (volatile atomic<U*>* obj,
                              ptrdiff_t val, memory_order sync) noexcept;
template <class U>
U* atomic_fetch_sub_explicit (atomic<U*>* obj,
                              ptrdiff_t val, memory_order sync) noexcept;
overloads (3) 
T atomic_fetch_sub_explicit (volatile A* obj, M val, memory_order sync) noexcept;
T atomic_fetch_sub_explicit (A* obj, M val, memory_order sync) noexcept;
Subtract from contained value (explicit memory order)
Subtracts val the value contained in obj, using the memory order specified by sync.

The entire operation is atomic: the value cannot be modified between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using the memory order specified by argument sync.

See atomic::fetch_sub for the equivalent member function of atomic.!std::atomic_fetch_sub_explicit!obj
Pointer to an atomic object that contains either an integral or a pointer value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to subtract.
T is the type of the value contained by the atomic object (atomic's template parameter).
ptrdiff_t is a signed integral type.
M is T if T is an integral type, or ptrdiff_t if T is a pointer.
sync
Synchronization mode for the operation.
This shall be one of the values of the enum type memory_order.!The contained value before the call.
T (or U*) is the type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_add_explicit
Add to contained value (explicit memory order) (function )
atomic_fetch_sub
Subtract from contained value (function )
atomic::fetch_sub
Subtract from contained value (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T> T atomic_fetch_xor (volatile atomic<T>* obj, T val) noexcept;
template <class T> T atomic_fetch_xor (atomic<T>* obj, T val) noexcept;
overloads (2) 
T atomic_fetch_xor (volatile A* obj, T val) noexcept;
T atomic_fetch_xor (A* obj, T val) noexcept;
Apply bitwise XOR to contained value
Reads the value contained in obj and replaces it by the result of performing a bitwise XOR (exclusive or) operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using sequential consistency (memory_order_seq_cst). To modify the value with a different memory ordering, see atomic_fetch_and_explicit.

See atomic::fetch_xor and atomic::operator^= for equivalent member functions of atomic.!std::atomic_fetch_xor!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).!atomic_fetch_xor_explicit
Apply bitwise XOR to contained value (explicit memory order) (function )
atomic_fetch_and
Apply bitwise AND to contained value (function )
atomic::fetch_xor
Apply bitwise XOR to contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!template (integral) (1) 
template <class T>
T atomic_fetch_xor_explicit (volatile atomic<T>* obj,
                             T val, memory_order sync) noexcept;
template <class T>
T atomic_fetch_xor_explicit (atomic<T>* obj,
                             T val, memory_order sync) noexcept;
overloads (2) 
T atomic_fetch_xor_explicit (volatile A* obj, T val, memory_order sync) noexcept;
T atomic_fetch_xor_explicit (A* obj, T val, memory_order sync) noexcept;
Apply bitwise XOR to contained value (explicit memory order)
Reads the value contained in obj and replaces it by the result of performing a bitwise XOR (exclusive or) operation between the read value and val.

The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

The function synchronizes using the memory order specified by argument sync.

See atomic::fetch_xor for the equivalent member function of atomic.!std::atomic_fetch_xor_explicit!obj
Pointer to an atomic object that contains an integral value.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to apply.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
sync
Synchronization mode for the operation.
This shall be one of the values of the enum type memory_order.!The contained value before the call.
T is the integral type of the value contained by the atomic object (atomic's template parameter).
!atomic_fetch_xor
Apply bitwise XOR to contained value (function )
atomic_fetch_and_explicit
Apply bitwise AND to contained value (explicit memory order) (function )
atomic::fetch_xor
Apply bitwise XOR to contained value (public member function )
atomic::operator (comp. assign.)
Compound assignments (public member function )!X!
Cplusplus!void atomic_flag_clear (volatile atomic_flag* obj) noexcept;
void atomic_flag_clear (atomic_flag* obj) noexcept;
Clear atomic flag
Clears obj, setting its flag value to false.

This operation is atomic and uses sequential consistency (memory_order_seq_cst). To clear value with a different memory ordering, see atomic_flag_clear_explicit.

See atomic_flag::clear for the equivalent member function of atomic_flag.!std::atomic_flag_clear!obj
Pointer to the atomic_flag object to clear.!none!atomic_flag_clear_explicit
Clear atomic flag (explicit memory order) (function )
atomic_flag_test_and_set
Test and set atomic flag (function )
atomic_flag::clear
Clear flag (public member function )!X!
Cplusplus!void atomic_flag_clear (volatile atomic_flag* obj, memory_order sync) noexcept;
void atomic_flag_clear (atomic_flag* obj, memory_order sync) noexcept;
Clear atomic flag (explicit memory order)
Clears obj, setting its flag value to false.

See atomic_flag::clear for the equivalent member function of atomic_flag.!std::atomic_flag_clear_explicit!obj
Pointer to the atomic_flag object to clear.
sync
Synchronization mode for the operation.
This shall be a values of the enum type memory_order.!none!atomic_flag_clear
Clear atomic flag (function )
atomic_flag_test_and_set_explicit
Test and set atomic flag (explicit memory order) (function )
atomic_flag::clear
Clear flag (public member function )!X!
Cplusplus!bool atomic_flag_test_and_set (volatile atomic_flag* obj) noexcept;
bool atomic_flag_test_and_set (atomic_flag* obj) noexcept;
Test and set atomic flag
Sets the atomic flag pointed by obj and returns the value it had immediately before the call.

The entire operation is atomic (an atomic read-modify-write operation): the value of obj is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

See atomic_flag::test_and_set for the equivalent member function of atomic_flag.!std::atomic_flag_test_and_set!obj
Pointer to the atomic_flag object to set.!true if obj was already set before the call.
false otherwise.!atomic_flag_test_and_set_explicit
Test and set atomic flag (explicit memory order) (function )
atomic_flag_clear
Clear atomic flag (function )
atomic_flag::test_and_set
Test and set flag (public member function )!X!
Cplusplus!bool atomic_flag_test_and_set (volatile atomic_flag* obj, memory_order sync) noexcept;
bool atomic_flag_test_and_set (atomic_flag* obj, memory_order sync) noexcept;
Test and set atomic flag (explicit memory order)
Sets the atomic flag pointed by obj and returns the value it had immediately before the call.

The entire operation is atomic (an atomic read-modify-write operation): the value of obj is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.

See atomic_flag::test_and_set for the equivalent member function of atomic_flag.!std::atomic_flag_test_and_set_explicit!obj
Pointer to the atomic_flag object to set.
sync
Synchronization mode for the operation.
This shall be a values of the enum type memory_order.!true if obj was already set before the call.
false otherwise.!atomic_flag_test_and_set
Test and set atomic flag (function )
atomic_flag_clear_explicit
Clear atomic flag (explicit memory order) (function )
atomic_flag::test_and_set
Test and set flag (public member function )!X!
Cplusplus!template (1) 
template <class T> void atomic_init (volatile atomic<T>* obj, T val) noexcept;
template <class T> void atomic_init (atomic<T>* obj, T val) noexcept;
overloads (2) 
void atomic_init (volatile A* obj, T val) noexcept;
void atomic_init (A* obj, T val) noexcept;
Initialize atomic object
Initializes obj with a contained value of val.

Calling this function on an atomic object that has already been initialized (either on construction or by calling this function earlier) causes undefined behavior (see atomic_store to modify the value of already-initialized atomics).!std::atomic_init!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).
val
Value to initialize the contained object with.
T is the type of the value contained by the atomic object (atomic's template parameter).
!none!atomic::atomic
Construct atomic (public member function )!X!
Cplusplus!template (1) 
template <class T> bool atomic_is_lock_free (const volatile atomic<T>* obj) noexcept;
template <class T> bool atomic_is_lock_free (const atomic<T>* obj) noexcept;
overloads (2) 
bool atomic_is_lock_free (const volatile A* obj) noexcept;
bool atomic_is_lock_free (const A* obj) noexcept;
Is lock-free
Indicates whether obj is lock-free.

See atomic::is_lock_free for the equivalent member function of atomic.!atomic_is_lock_free!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (in case the library does not implement the C-style atomic types as instantiations of atomic).!true if the object is lock-free.
false otherwise.!atomic::is_lock_free
Is lock-free (public member function )!X!
Cplusplus!template (1) 
template <class T> T atomic_load (const volatile atomic<T>* obj) noexcept;
template <class T> T atomic_load (const atomic<T>* obj) noexcept;
overloads (2) 
T atomic_load (const volatile A* obj) noexcept;
T atomic_load (const A* obj) noexcept;
Read contained value
Returns the value contained in obj.

This operation is atomic and uses sequential consistency (memory_order_seq_cst). To access the value with a different memory ordering, see atomic_load_explicit.

See atomic::load and atomic::operator T for equivalent member functions of atomic.!std::atomic_load!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).!The contained value.
T is the type of the contained value (atomic's template parameter).
!atomic_load_explicit
Read contained value (explicit memory order) (function )
atomic_store
Modify contained value (function )
atomic::load
Read contained value (public member function )
atomic::operator T
Access contained value (public member function )!X!
Cplusplus!template (1) 
template <class T>
T atomic_load_explicit (const volatile atomic<T>* obj, memory_order sync) noexcept;
template <class T>
T atomic_load_explicit (const atomic<T>* obj, memory_order sync) noexcept;
overloads (2) 
T atomic_load_explicit (const volatile A* obj, memory_order sync) noexcept;
T atomic_load_explicit (const A* obj, memory_order sync) noexcept;
Read contained value (explicit memory order)
Returns the value contained in obj, using the memory order specified by sync.

See atomic::load for the equivalent member function of atomic.
!std::atomic_load_explicit!obj
Pointer to an atomic object.
Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).
sync
Synchronization mode for the operation.
This shall be one of the following values of the enum type memory_order:
memory_order_seq_cst
memory_order_consume
memory_order_acquire
memory_order_relaxed!The contained value.
T is the type of the contained value (atomic's template parameter).
!atomic_load
Read contained value (function )
atomic_store_explicit
Modify contained value (explicit memory order) (function )
atomic::load
Read contained value (public member function )!X!
Cplusplus!class condition_variable;
Condition variable
A condition variable is an object able to block the calling thread until notified to resume.

It uses a unique_lock (over a mutex) to lock the thread when one of its wait functions is called. The thread remains blocked until woken up by another thread that calls a notification function on the same condition_variable object.

Objects of type condition_variable always use unique_lock<mutex> to wait: for an alternative that works with any kind of lockable type, see condition_variable_any!std::condition_variable!X!X!X!X!
Cplusplus!class condition_variable_any;
Condition variable (any lock)
Same as condition_variable, except that its wait functions can take any lockable type as argument (condition_variable objects can only take unique_lock<mutex>). Other than that, they are identical.
!std::condition_variable_any!X!X!X!X!
Cplusplus!enum class cv_status;
Condition variable status
Type that indicates whether a function returned because of a timeout or not.

Values of this type are returned by the wait_for and wait_until members of condition_variable and condition_variable_any.

It is defined as:
 
enum class cv_status { no_timeout, timeout };
!std::cv_status!X!X!condition_variable::wait_for
Wait for timeout or until notified (public member function )
condition_variable::wait_until
Wait until notified or time point (public member function )!X!
Cplusplus!void notify_all_at_thread_exit (condition_variable& cond, unique_lock<mutex> lck);
Notify all at thread exit
When the calling thread exits, all threads waiting on cond are notified to resume execution.

The function also acquires ownership of the lock on the mutex object managed by lck, which is stored internally by the function and unlocked at thread exit (just before notifying all threads), behaving as if the following was called once all objects with thread storage duration have been destroyed:
1
2
lck.unlock();
cond.notify_all();
!std::notify_all_at_thread_exit!cond
A condition_variable object to notify all at thread exit.
lck
A unique_lock object whose mutex object is currently locked by this thread.
The object is acquired by the function (it shall be an rvalue).
All waiting threads on cond (if any) shall use the same underlying mutex object as lck.
!none!condition_variable::notify_all
Notify all (public member function )!X!
Cplusplus!int iswalnum (wint_t c);
Check if wide character is alphanumeric
Checks whether c is either an alphabetic letter (either uppercase or lowercase) or a decimal digit.

The result is true if either iswalpha or iswdigit would also return true for c.

This function is the wide-character equivalent of isalnum (<cctype>): If c translates with wctob to a character for which isalnum is true, it is always considered alphanumeric by this function too.

In C++, a locale-specific template version of this function (isalnum) exists in header <locale> for all character types.!iswalnum!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is either a digit or a letter. Zero (i.e., false) otherwise.
!isalnum
Check if character is alphanumeric (function )
iswalpha
Check if wide character is alphabetic (function )
iswdigit
Check if wide character is decimal digit (function )
isalnum (locale)
Check if character is alphanumeric using locale (function template )!X!
Cplusplus!int iswalpha (wint_t c);
Check if wide character is alphabetic
Checks whether c is an alphabetic letter wide character.

An alphabetic letter is a character for which iswupper or iswlower would return true, or another character explicitly considered alphabetic by the locale (in this case, the character cannot be iswcntrl, iswdigit, iswpunct or iswspace).

This function is the wide-character equivalent of isalpha (<cctype>): If c translates with wctob to a character for which isalpha is true, it is always considered alphabetic by this function too.

In C++, a locale-specific template version of this function (isalpha) exists in header <locale> for all character types.
!iswalpha!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is an alphabetic letter. Zero (i.e., false) otherwise.
!isalpha
Check if character is alphabetic (function )
iswalnum
Check if wide character is alphanumeric (function )
iswdigit
Check if wide character is decimal digit (function )
isalpha (locale)
Check if character is alphabetic using locale (function template )!X!
Cplusplus!int iswblank (wint_t c);
Check if wide character is blank
Checks whether c is a blank character.

A blank character is a space character used to separate words within a line of text.

The standard "C" locale considers blank characters the tab character (L'\t') and the space character (L' ').

Other locales may consider blank a different selection of characters, but they must all also be space characters by isspace.

This function is the wide-character equivalent of isblank (<cctype>): If c translates with wctob to a character for which isblank is true, it is always considered a blank character by this function too.

In C++, a locale-specific template version of this function (isblank) exists in header <locale> for all character types.!iswblank!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a blank character. Zero (i.e., false) otherwise.!isblank
Check if character is blank (function )
iswspace
Check if wide character is a white-space (function )
iswgraph
Check if wide character has graphical representation (function )
iswpunct
Check if wide character is punctuation character (function )
iswalnum
Check if wide character is alphanumeric (function )
isblank (locale)
Check if character is blank using locale (function template )!X!
Cplusplus!int iswcntrl (wint_t c);
Check if wide character is a control character
Checks whether c is a control character.

A control character is a character that does not occupy at least one printing position on a display (this is the opposite of a printable character, checked with iswprint).

This function is the wide-character equivalent of iscntrl (<cctype>): If c translates with wctob to a character for which iscntrl is true, it is always considered a control character by this function too.

In C++, a locale-specific template version of this function (iscntrl) exists in header <locale> for all character types.
!iswcntrl!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a control character. Zero (i.e., false) otherwise.!iscntrl
Check if character is a control character (function )
iswgraph
Check if wide character has graphical representation (function )
iswpunct
Check if wide character is punctuation character (function )
iscntrl (locale)
Check if character is a control character using locale (function template )!X!
Cplusplus!int iswctype(wint_t c, wctype_t desc);
Check if wide character has property
Checks whether c has the property specified by desc.

A specific locale can accept multiple categories in which to classify its characters. At least the following categories are recognized by all locales:

string passed to wctype description equivalent function
"alnum" alphanumerical character iswalnum
"alpha" letter character iswalpha
"blank" blank character iswblank
"cntrl" control character iswcntrl
"digit" decimal digit character iswdigit
"graph" character with graphical representation iswgraph
"lower" lowercase letter character iswlower
"print" printable character iswprint
"punct" punctuation character iswpunct
"space" white-space character iswspace
"upper" uppercase letter character iswupper
"xdigit" hexadecimal digit character iswxdigit

The setting of the LC_CTYPE locale category at the time of calling the function shall be the same as when wctype was called to obtain desc.!iswctype!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.
desc
A value returned by a call to wctype (with the same LC_CTYPE locale category selected as in this call).
wctype_t is the scalar type used as return type for wctype.!A value different from zero (i.e., true) if indeed c is has the property identified by desc. Zero (i.e., false) otherwise.!wctype
Return character property (function )
towctrans
Convert using transformation (function )!X!
Cplusplus!int iswdigit (wint_t c);
Check if wide character is decimal digit
Checks whether c is a decimal digit character.

A decimal digit is any of: 0 1 2 3 4 5 6 7 8 9 

This function is the wide-character equivalent of isdigit (<cctype>): If c translates with wctob to a character for which isdigit is true, it is always considered a decimal digit character by this function too.

In C++, a locale-specific template version of this function (isdigit) exists in header <locale> for all character types.
!iswdigit!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a decimal digit. Zero (i.e., false) otherwise.!isdigit
Check if character is decimal digit (function )
iswxdigit
Check if wide character is hexadecimal digit (function )
iswalnum
Check if wide character is alphanumeric (function )
iswalpha
Check if wide character is alphabetic (function )
isdigit (locale)
Check if character is a decimal digit using locale (function template )!X!
Cplusplus!int iswgraph (wint_t c);
Check if wide character has graphical representation
Checks whether c is a wide character with graphical representation.

The characters with graphical representation are all those characters than can be printed (as determined by iswprint) except the espace character (L' ').

This function is the wide-character equivalent of isgraph (<cctype>): If c translates with wctob to a character for which isgraph is true, it is considered a character with graphical representation by this function (except possibly for certain locale-specific printable white-space characters other than L' ').

In C++, a locale-specific template version of this function (isgraph) exists in header <locale> for all character types.
!iswgraph!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.
!A value different from zero (i.e., true) if indeed c is a character with graphical representation. Zero (i.e., false) otherwise.
!isgraph
Check if character has graphical representation (function )
iswprint
Check if wide character is printable (function )
iswspace
Check if wide character is a white-space (function )
isgraph (locale)
Check if character has graphical representation using locale (function template )!X!
Cplusplus!int iswlower (wint_t c);
Check if wide character is lowercase letter
Checks whether c is a lowercase letter.

Notice that what is considered a letter may depend on the locale being used.

This function is the wide-character equivalent of islower (<cctype>): If c translates with wctob to a character for which islower is true, it is always considered a lowercase letter character by this function too.

In C++, a locale-specific template version of this function (islower) exists in header <locale> for all character types.!iswlower!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.
!A value different from zero (i.e., true) if indeed c is a lowercase letter. Zero (i.e., false) otherwise.
!islower
Check if character is lowercase letter (function )
iswupper
Check if wide character is uppercase letter (function )
iswalpha
Check if wide character is alphabetic (function )
towupper
Convert lowercase wide character to uppercase (function )
towlower
Convert uppercase wide character to lowercase (function )
islower (locale)
Check if character is a lowercase letter using locale (function template )!X!
Cplusplus!int iswprint (wint_t c);
Check if wide character is printable
Checks whether c is a printable character.

A printable character is a character that occupies at least one printing position on a display (this is the opposite of a control character, checked with iswcntrl).

This function is the wide-character equivalent of isprint (<cctype>): If c translates with wctob to a character for which isprint is true, it is always considered a printable character by this function too.

In C++, a locale-specific template version of this function (isprint) exists in header <locale> for all character types.!iswprint!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a printable character. Zero (i.e., false) otherwise.
!isprint
Check if character is printable (function )
iswcntrl
Check if wide character is a control character (function )
iswspace
Check if wide character is a white-space (function )
isprint (locale)
Check if character is printable using locale (function template )!X!
Cplusplus!int iswpunct (wint_t c);
Check if wide character is punctuation character
Checks whether c is a punctuation character.

A puctuation character is a character considered by a specific locale as a punctuation mark. These are characters with a graphical representation (as in iswgraph) that are necessarily non-alphanumerical (as in iswalnum).

This function is the wide-character equivalent of ispunct (<cctype>): If c translates with wctob to a character for which ispunct is true, it is always considered a punctuation character by this function (except possibly for certain locale-specific printable white-space characters other than L' ').

In C++, a locale-specific template version of this function (ispunct) exists in header <locale> for all character types.!iswpunct!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a punctuation character. Zero (i.e., false) otherwise.
!ispunct
Check if character is a punctuation character (function )
iswgraph
Check if wide character has graphical representation (function )
iswcntrl
Check if wide character is a control character (function )
ispunct (locale)
Check if character is a punctuation character using locale (function template )!X!
Cplusplus!int iswspace (wint_t c);
Check if wide character is a white-space
Checks whether c is a white-space character.

A white-space is a character considered by a specific locale as a space separating words, lines and/or paragraphs.

This function is the wide-character equivalent of isspace (<cctype>): If c translates with wctob to a character for which isspace is true, it is always considered a white-space character by this function too.

In C++, a locale-specific template version of this function (isspace) exists in header <locale> for all character types.!iswspace!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.
!A value different from zero (i.e., true) if indeed c is a white-space character. Zero (i.e., false) otherwise.
!isspace
Check if character is a white-space (function )
iswgraph
Check if wide character has graphical representation (function )
iswpunct
Check if wide character is punctuation character (function )
isspace (locale)
Check if character is a white-space using locale (function template )!X!
Cplusplus!int iswupper (wint_t c);
Check if wide character is uppercase letter
Checks whether c is an uppercase letter.

Notice that what is considered a letter may depend on the locale being used.

This function is the wide-character equivalent of isupper (<cctype>): If c translates with wctob to a character for which isupper is true, it is always considered an uppercase letter character by this function too.

In C++, a locale-specific template version of this function (isupper) exists in header <locale> for all character types.!iswupper!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is an uppercase letter. Zero (i.e., false) otherwise.!isupper
Check if character is uppercase letter (function )
iswlower
Check if wide character is lowercase letter (function )
iswalpha
Check if wide character is alphabetic (function )
towupper
Convert lowercase wide character to uppercase (function )
towlower
Convert uppercase wide character to lowercase (function )
isupper (locale)
Check if character is an uppercase letter using locale (function template )!X!
Cplusplus!int iswxdigit (wint_t c);
Check if wide character is hexadecimal digit
Checks whether c is a hexadecimal digit character.

A hexadecimal digit is any of: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 

This function is the wide-character equivalent of isxdigit (<cctype>): If c translates with wctob to a character for which isxdigit is true, it is always considered a hexadecimal digit character by this function too.

In C++, a locale-specific template version of this function (isxdigit) exists in header <locale> for all character types.
!iswxdigit!c
Wide character to be checked, casted to a wint_t, or WEOF.
wint_t is an integral type.!A value different from zero (i.e., true) if indeed c is a hexadecimal digit. Zero (i.e., false) otherwise.!isxdigit
Check if character is hexadecimal digit (function )
iswdigit
Check if wide character is decimal digit (function )
iswalnum
Check if wide character is alphanumeric (function )
isxdigit (locale)
Check if character is hexadecimal digit using locale (function template )!X!
Cplusplus!wint_t towctrans(wint_t c, wctrans_t desc);
Convert using transformation
Applies a the transformation specified by desc to the wide character c.

A specific locale can accept multiple transformations for characters. At least the following transformations are recognized by all locales:

string passed to wctrans description equivalent function
"tolower" to lowercase towlower
"toupper" to uppercase towupper

The setting of the LC_CTYPE locale category at the time of calling the function shall be the same as when wcttrans was called to obtain desc.
!towctrans!c
Wide character to be transformed, casted to a wint_t value, or WEOF.
wint_t is an integral type.
desc
A value returned by a call to wctrans (with the same LC_CTYPE locale category selected as in this call).
wctrans_t is the scalar type used as return type for wctrans.
!The character transformation of c, if such value exists, or c (unchanged) otherwise.
The value is returned as a wint_t value that can be implicitly casted to wchar_t.!wctrans
Return character transformation (function )
towupper
Convert lowercase wide character to uppercase (function )
towlower
Convert uppercase wide character to lowercase (function )
iswctype
Check if wide character has property (function )!X!
Cplusplus!wint_t towlower ( wint_t c );
Convert uppercase wide character to lowercase
Converts c to its lowercase equivalent if c is an uppercase letter and has a lowercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used.

If an uppercase character has more than one correspondent lowercase character, this function always returns the same character for the same value of c.

This function is the wide-character equivalent of tolower (<cctype>).

In C++, a locale-specific template version of this function (tolower) exists in header <locale> for all character types.!towlower!c
Wide character to be converted, casted to a wint_t value, or WEOF.
wint_t is an integral type.!The lowercase equivalent to c, if such value exists, or c (unchanged) otherwise.
The value is returned as a wint_t value that can be implicitly casted to wchar_t.!tolower
Convert uppercase letter to lowercase (function )
towupper
Convert lowercase wide character to uppercase (function )
iswupper
Check if wide character is uppercase letter (function )
iswlower
Check if wide character is lowercase letter (function )
iswalpha
Check if wide character is alphabetic (function )
tolower (locale)
Convert uppercase letter to lowercase using locale (function template )!X!
Cplusplus!wint_t towupper (wint_t c);
Convert lowercase wide character to uppercase
Converts c to its uppercase equivalent if c is a lowercase letter and has an uppercase equivalent. If no such conversion is possible, the value returned is c unchanged.

Notice that what is considered a letter may depend on the locale being used.

If a lowercase character has more than one correspondent uppercase character, this function always returns the same character for the same value of c.

This function is the wide-character equivalent of toupper (<cctype>).

In C++, a locale-specific template version of this function (toupper) exists in header <locale> for all character types.
!towupper!c
Wide character to be converted, casted to a wint_t value, or WEOF.
wint_t is an integral type.!The uppercase equivalent to c, if such value exists, or c (unchanged) otherwise.
The value is returned as a wint_t value that can be implicitly casted to wchar_t.
!toupper
Convert lowercase letter to uppercase (function )
towlower
Convert uppercase wide character to lowercase (function )
iswupper
Check if wide character is uppercase letter (function )
iswlower
Check if wide character is lowercase letter (function )
iswalpha
Check if wide character is alphabetic (function )
toupper (locale)
Convert lowercase letter to uppercase using locale (function template )!X!
Cplusplus!wctrans_t wctrans (const char* property);
Return character transformation
Returns a value of type wctrans_t that corresponds to the character transformation by property.

A specific locale can accept multiple transformations for characters. At least the following transformations are recognized by all locales:

string passed as property description equivalent function
"tolower" to lowercase towlower
"toupper" to uppercase towupper

The value returned by this function depends on the LC_CTYPE locale category selected.!wctrans!property
A string identifying a character transformation (see above).
!A value of type wctrans_t identifying a specific character category.
This value is locale-dependent.
!towctrans
Convert using transformation (function )
wctype
Return character property (function )
iswupper
Check if wide character is uppercase letter (function )
iswlower
Check if wide character is lowercase letter (function )!X!
Cplusplus!wctype_t wctype (const char* property);
Return character property
Returns a value of type wctype_t that corresponds to the character category specified by property.

A specific locale can accept multiple categories in which to classify its characters. At least the following categories are recognized by all locales:
string passed as property description equivalent function
"alnum" alphanumerical character iswalnum
"alpha" letter character iswalpha
"blank" blank character iswblank
"cntrl" control character iswcntrl
"digit" decimal digit character iswdigit
"graph" character with graphical representation iswgraph
"lower" lowercase letter character iswlower
"print" printable character iswprint
"punct" punctuation character iswpunct
"space" white-space character iswspace
"upper" uppercase letter character iswupper
"xdigit" hexadecimal digit character iswxdigit

The value returned by this function depends on the LC_CTYPE locale category selected.!wctype!property
A string identifying a character category (see above).!A value of type wctype_t identifying a specific character category.
This value is locale-dependent.!iswctype
Check if wide character has property (function )
wctrans
Return character transformation (function )!X!
Cplusplus!Wide character transformation
Scalar type that can hold values which represent locale-specific character transformations.

This is the type returned by function wctrans, and depends on the LC_CTYPE locale category selected at the time of the call.!wctrans_t!X!X!X!X!
Cplusplus!Wide character type
Scalar type that can hold values which represent locale-specific character classification categories.

This is the type returned by function wctype, and depends on the LC_CTYPE locale category selected at the time of the call.!wctype_t!X!X!X!X!
Cplusplus!Wide character integral type
Integer type that can hold any character value of the extended character set, as well as at least one additional value (that corresponds to WOEF).

Some functions use this type as the type to represent either a character of the extended character set or WEOF.

This may be the same type as wchar_t or a different one (depending on the system characteristics and library implementation).!wint_t!X!X!X!X!
Cplusplus!Wide End-of-File
Macro constant definition that expands to a constant expression of type wint_t whose value does not correspond to any character of the extended character set.

It is used as the value returned by several wide character functions to indicate either that the End-of-File has been reached, or to indicate a character value not corresponding to any member of the extended character set.

This macro is also defined in header <cwchar>.!WEOF!X!X!EOF
End-of-File (constant )!X!
Cplusplus!template < class charT, class traits = char_traits<charT> >
  class basic_filebuf;
File stream buffer
basic_streambuf
basic_filebuf

Stream buffer to read from and write to files.

Constructed without association, these objects are associated to a file by calling member open. Once open, all input/output operations performed on the object are reflected in the associated file.

Objects of this class may internally maintain an intermediate input buffer and/or an intermediate output buffer, where individual characters are read or written by i/o operations. These buffers are synchronized with the contents of the file once filled up, when explicitly requested to do so (sync), or when the object is closed.

Objects of this class may be explicitly made unbuffered by calling member pubsetbuf with both arguments set to zero (see member setbuf): Unbuffered file stream buffers perform the i/o operations directly on the file, without an intermediate buffer.

Access to the associated sequence of characters (i.e., the file) is given to streams by means of the interface offered by the virtual members inherited from basic_streambuf that are overriden in this class:!basic_filebuf!X!X!X!X!
Cplusplus!template < class charT, class traits = char_traits<charT> >
  class basic_fstream;
File stream
ios_base
basic_ios
basic_istream
basic_ostream
basic_iostream
basic_fstream

Input/output stream class to operate on files.

Objects of this class maintain a basic_filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

Apart from the internal file stream buffer, objects of these classes keep a set of internal fields inherited from ios_base, basic_ios and basic_istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.!basic_fstream!X!X!X!X!
Cplusplus!template < class charT, class traits = char_traits<charT> >
  class basic_ifstream;
Input file stream
ios_base
basic_ios
basic_istream
basic_ifstream

Input stream class to operate on files.

Objects of this class maintain a basic_filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

Apart from the internal file stream buffer, objects of these classes keep a set of internal fields inherited from ios_base, basic_ios and basic_istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).

Template parameters
charT
Character type.
This shall be a non-array POD type.
Aliased as member type basic_ifstream::char_type.
traits
Character traits class that defines essential properties of the characters used by stream object (see char_traits).
traits::char_type shall be the same as charT.
Aliased as member type basic_ifstream::traits_type.
!basic_ifstream!X!X!X!X!
Cplusplus!template < class charT, class traits = char_traits<charT> >
  class basic_ofstream;
Output file stream
ios_base
basic_ios
basic_ostream
basic_ofstream

Output stream class to operate on files.

Objects of this class maintain a basic_filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

Apart from the internal file stream buffer, objects of these classes keep a set of internal fields inherited from ios_base and basic_ios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
!basic_ofstream!X!X!X!X!
Cplusplus!typedef basic_filebuf<char> filebuf;
File stream buffer
streambuf
filebuf

Stream buffer to read from and write to files.

Constructed without association, these objects are associated to a file by calling member open. Once open, all input/output operations performed on the object are reflected in the associated file.

Objects of this class may internally maintain an intermediate input buffer and/or an intermediate output buffer, where individual characters are read or written by i/o operations. These buffers are synchronized with the contents of the file once filled up, when explicitly requested to do so (sync), or when the object is closed.

Objects of this class may be explicitly made unbuffered by calling member pubsetbuf with both arguments set to zero (see member setbuf): Unbuffered file stream buffers perform the i/o operations directly on the file, without an intermediate buffer.

Access to the associated sequence of characters (i.e., the file) is given to streams by means of the interface offered by the virtual members inherited from streambuf that are overriden in this class.

This is an instantiation of basic_filebuf with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type
!filebuf!X!X!X!X!
Cplusplus!typedef basic_fstream<char> fstream;
Input/output file stream class
ios_base
ios
istream
ostream
iostream
fstream

Input/output stream class to operate on files.

Objects of this class maintain a filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

This is an instantiation of basic_fstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Apart from the internal file stream buffer, objects of this class keep a set of internal fields inherited from ios_base, ios and istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.
!fstream!X!X!X!X!
Cplusplus!typedef basic_ifstream<char> ifstream;
Input file stream class
ios_base
ios
istream
ifstream

Input stream class to operate on files.

Objects of this class maintain a filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

This is an instantiation of basic_ifstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Apart from the internal file stream buffer, objects of this class keep a set of internal fields inherited from ios_base, ios and istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.
!ifstream!X!X!X!X!
Cplusplus!typedef basic_ofstream<char> ofstream;
Output file stream
ios_base
ios
ostream
ofstream

Output stream class to operate on files.

Objects of this class maintain a filebuf object as their internal stream buffer, which performs input/output operations on the file they are associated with (if any).

File streams are associated with files either on construction, or by calling member open.

This is an instantiation of basic_ofstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Apart from the internal file stream buffer, objects of this class keep a set of internal fields inherited from ios_base, ios and istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.
!ofstream!X!X!X!X!
Cplusplus!typedef basic_filebuf<wchar_t> wfilebuf;
File stream buffer (wide)
wstreambuf
wfilebuf

Stream buffer to read from and write to files using wide characters.

This is an instantiation of basic_filebuf with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Member types
member type definition
char_type wchar_t
traits_type char_traits<wchar_t>
int_type wint_t
pos_type wstreampos
off_type streamoff
!wfilebuf!X!X!X!X!
Cplusplus!typedef basic_fstream<wchar_t> wfstream;
File stream (wide)
ios_base
wios
wistream
wostream
wiostream
wfstream

Input/output stream class to operate on files using wide characters.

This is an instantiation of basic_fstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Apart from the internal file buffer of type wfilebuf, objects of this class keep a set of internal fields inherited from ios_base, wios and wistream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!wfstream!X!X!X!X!
Cplusplus!typedef basic_ifstream<wchar_t> wifstream;
Input file stream (wide)
ios_base
wios
wistream
wifstream

Input stream class to operate on files using wide characters.

This is an instantiation of basic_ifstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Apart from the internal file buffer of type wfilebuf, objects of this class keep a set of internal fields inherited from ios_base, wios and wistream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!wifstream!X!X!X!X!
Cplusplus!typedef basic_ofstream<wchar_t> wofstream;
Output file stream (wide)
ios_base
wios
wostream
wofstream

Output stream class to operate on files using wide characters.

This is an instantiation of basic_ofstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Apart from the internal file buffer of type wfilebuf, objects of this class keep a set of internal fields inherited from ios_base and wios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
!wofstream!X!X!X!X!
Cplusplus!template <class moneyT>
/*unspecified*/ get_money (moneyT& mon, bool intl = false);
Get monetary value
Extracts characters from the input stream it is applied to, and interprets them as a monetary expression, which is stored as the value of mon.

Internally, the function accesses the input sequence by first constructing an object of type basic_istream::sentry (with noskipws set to false). Then (if evaluating the sentry object is true), it calls money_get::get (using the stream's selected locale) to perform both the extraction and the parsing operations, and adjusts the stream's internal state flags accordingly. Finally, it destroys the sentry object before returning.

This manipulator is declared in header <iomanip>.!get_money!mon
Object where the monetary value is stored.
moneyT shall be either long double or a basic_string instantiation.
intl
true for international representations, false otherwise.
This is used internally to instantiate the proper moneypunct class.!Unspecified. This function should only be used as a stream manipulator (see example).

Errors are signaled by modifying the stream's internal state flags:
flag error
eofbit The input sequence has no more characters available (end-of-file reached).
failbit Either no characters were extracted, or the characters extracted could not be interpreted as a valid monetary value.
badbit Error on stream (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set by a single operation.

If the operation sets an internal state flag on the stream that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!istream::operator>>
Extract formatted input (public member function )
put_money
Put monetary value (function )
get_time
Get date and time (function )!X!
Cplusplus!template <class charT>
/*unspecified*/ get_time (struct tm* tmb, const charT* fmt);
Get date and time
Extracts characters from the input stream it is applied to, and interprets them as time and date information as specified in argument fmt. The obtained data is stored at the struct tm object pointed by tmb.

Internally, the function accesses the input sequence by first constructing an object of type basic_istream::sentry. Then (if evaluating the sentry object is true), it calls time_get::get (using the stream's selected locale) to perform both the extraction and the parsing operations, and adjusts the stream's internal state flags accordingly. Finally, it destroys the sentry object before returning.

This manipulator is declared in header <iomanip>.!get_time!tmb
Pointer to an object of type struct tm where the time and date information extracted is stored.
struct tm is a class defined in header <ctime>.
fmt
C-string used by time_get::get as format string (see time_get::get).
charT is the character type in the c-string.
!Unspecified. This function should only be used as a stream manipulator (see example).

Errors are signaled by modifying the stream's internal state flags:
flag error
eofbit The input sequence has no more characters available (end-of-file reached).
failbit Either no characters were extracted, or the characters extracted could not be interpreted as a valid monetary value.
badbit Error on stream (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set by a single operation.

If the operation sets an internal state flag on the stream that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!istream::operator>>
Extract formatted input (public member function )
put_time
Put date and time (function )
get_money
Get monetary value (function )!X!
Cplusplus!template <class moneyT>
/*unspecified*/ put_money (const moneyT& mon, bool intl = false);
Put monetary value
Inserts the representation of mon as a monetary value into the output stream it is applied to.

Internally, the function accesses the output sequence by first constructing an object of type basic_ostream::sentry. Then (if evaluating the sentry object is true), it calls money_put::put (using the stream's selected locale) to perform both the formatting and the insertion operations, adjusting the stream's internal state flags accordingly. Finally, it destroys the sentry object before returning.

This manipulator is declared in header <iomanip>.!put_money!mon
Monetary value.
moneyT shall be either long double or a basic_string instantiation.
intl
true for international representations, false otherwise.
This is used internally to instantiate the proper moneypunct class.
!Unspecified. This function should only be used as a stream manipulator (see example).

Errors are signaled by modifying the stream's internal state flags:
flag error
eofbit -
failbit The function failed to format mon (it may also be set if the construction of sentry failed).
badbit Either the insertion on the stream failed, or some other error happened (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set by a single operation.

If the operation sets an internal state flag on the stream that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!ostream::operator<<
Insert formatted output (public member function )
get_money
Get monetary value (function )
put_time
Put date and time (function )!X!
Cplusplus!template <class charT>
/*unspecified*/ put_time (const struct tm* tmb, const charT* fmt);
Put date and time
Inserts the representation of the time and date information pointed by tmb, formatting it as specified by argument fmt.

Internally, the function accesses the output sequence by first constructing an object of type basic_ostream::sentry. Then (if evaluating the sentry object is true), it calls time_put::put (using the stream's selected locale) to perform both the formatting and the insertion operations, adjusting the stream's internal state flags accordingly. Finally, it destroys the sentry object before returning.

This manipulator is declared in header <iomanip>.!put_time!tmb
Pointer to the object of type struct tm with the date and time information to format.
struct tm is a class defined in header <ctime>.
fmt
C-string used by time_put::put as format string. It contains any combination of regular characters and special format specifiers. These format specifiers are replaced by the function to the corresponding values to represent the time specified in tmb. They all begin with a percentage (%) sign, and are:
specifier Replaced by Example
%a Abbreviated weekday name * Thu
%A Full weekday name * Thursday
%b Abbreviated month name * Aug
%B Full month name * August
%c Date and time representation * Thu Aug 23 14:55:02 2001
%C Year divided by 100 and truncated to integer (00-99) 20
%d Day of the month, zero-padded (01-31) 23
%D Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01
%e Day of the month, space-padded ( 1-31) 23
%F Short YYYY-MM-DD date, equivalent to %Y-%m-%d 2001-08-23
%g Week-based year, last two digits (00-99) 01
%G Week-based year 2001
%h Abbreviated month name * (same as %b) Aug
%H Hour in 24h format (00-23) 14
%I Hour in 12h format (01-12) 02
%j Day of the year (001-366) 235
%m Month as a decimal number (01-12) 08
%M Minute (00-59) 55
%n New-line character ('\n') 
%p AM or PM designation PM
%r 12-hour clock time * 02:55:02 pm
%R 24-hour HH:MM time, equivalent to %H:%M 14:55
%S Second (00-61) 02
%t Horizontal-tab character ('\t') 
%T ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S 14:55:02
%u ISO 8601 weekday as number with Monday as 1 (1-7) 4
%U Week number with the first Sunday as the first day of week one (00-53) 33
%V ISO 8601 week number (00-53) 34
%w Weekday as a decimal number with Sunday as 0 (0-6) 4
%W Week number with the first Monday as the first day of week one (00-53) 34
%x Date representation * 08/23/01
%X Time representation * 14:55:02
%y Year, last two digits (00-99) 01
%Y Year 2001
%z ISO 8601 offset from UTC in timezone (1 minute=1, 1 hour=100)
If timezone cannot be termined, no characters +100
%Z Timezone name or abbreviation *
If timezone cannot be termined, no characters CDT
%% A % sign %
* The specifiers marked with an asterisk (*) are locale-dependent.
Two locale-specific modifiers can also be inserted between the percentage sign (%) and the specifier proper to request an alternative format, where applicable:
Modifier Meaning Applies to
E Uses the locale's alternative representation %Ec %EC %Ex %EX %Ey %EY
O Uses the locale's alternative numeric symbols %Od %Oe %OH %OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy
charT is the character type in the c-string.!Unspecified. This function should only be used as a stream manipulator (see example).

Errors are signaled by modifying the stream's internal state flags:
flag error
eofbit -
failbit The function failed to format tmb as specified by fmt (it may also be set if the construction of sentry failed).
badbit Either the insertion on the stream failed, or some other error happened (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set by a single operation.

If the operation sets an internal state flag on the stream that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!ostream::operator<<
Insert formatted output (public member function )
get_time
Get date and time (function )
put_money
Put monetary value (function )!X!
Cplusplus!/*unspecified*/ resetiosflags (ios_base::fmtflags mask);
Reset format flags
Unsets the format flags specified by parameter mask.

Behaves as if member unsetf were called with mask as argument on the stream on which it is inserted/extracted as a manipulator (it can be inserted/extracted on input streams or output streams).

See ios_base::fmtflags for more information on the particular flags that can be modified with this manipulator function.

This manipulator is declared in header <iomanip>.!resetiosflags!mask
Mask representing the flags to be reset.
fmtflags is a bitmask type.!Unspecified. This function should only be used as a stream manipulator (see example).!setiosflags
Set format flags (function )
ios_base::unsetf
Clear specific format flags (public member function )
ios_base::flags
Get/set format flags (public member function )!X!
Cplusplus!/*unspecified*/ setbase (int base);
Set basefield flag
Sets the basefield to one of its possible values: dec, hex or oct, according to argument base.

Behaves as if setf(which,ios_base::basefield) were called on the stream on which it is inserted/extracted as a manipulator, with which being:
dec, if base is 10
hex, if base is 16
oct, if base is 8
zero, if base is any other value.

It can be inserted/extracted on input streams or output streams.

This manipulator is declared in header <iomanip>.!setbase!base
Numerical radix to be used:
base argument same as inserting...
8 oct
10 dec
16 hex
any other resetiosflags(ios_base::basefield)
!Unspecified. This function should only be used as a stream manipulator (see example).!oct
Use octal base (function )
dec
Use decimal base (function )
hex
Use hexadecimal base (function )
ios_base::fmtflags
Type for stream format flags (public member type )!X!
Cplusplus!/*unspecified*/ setfill (char_type c);
Set fill character
Sets c as the stream's fill character.

Behaves as if member fill were called with c as argument on the stream on which it is inserted as a manipulator (it can be inserted on output streams).

This manipulator is declared in header <iomanip>.!setfill!c
The new fill character for the stream.
char_type is the type of characters used by the stream (i.e., its first class template parameter, charT).
!Unspecified. This function should only be used as a stream manipulator (see example).!setw
Set field width (function )
basic_ios::fill
Get/set fill character (public member function )!X!
Cplusplus!/*unspecified*/ setiosflags (ios_base::fmtflags mask);
Set format flags
Sets the format flags specified by parameter mask.

Behaves as if member setf were called with mask as argument on the stream on which it is inserted/extracted as a manipulator (it can be inserted/extracted on input streams or output streams).

See ios_base::fmtflags for more information on the particular flags that can be modified with this manipulator function.

This manipulator is declared in header <iomanip>.
!setiosflags!mask
Mask representing the flags to be set.
fmtflags is a bitmask type.!Unspecified. This function should only be used as a stream manipulator (see example).!resetiosflags
Reset format flags (function )
ios_base::setf
Set specific format flags (public member function )
ios_base::flags
Get/set format flags (public member function )!X!
Cplusplus!/*unspecified*/ setprecision (int n);
Set decimal precision
Sets the decimal precision to be used to format floating-point values on output operations.

Behaves as if member precision were called with n as argument on the stream on which it is inserted/extracted as a manipulator (it can be inserted/extracted on input streams or output streams).

This manipulator is declared in header <iomanip>.!setprecision!n
New value for the decimal precision.
!Unspecified. This function should only be used as a stream manipulator (see example).!ios_base::precision
Get/Set floating-point decimal precision (public member function )
fixed
Use fixed floating-point notation (function )
scientific
Use scientific floating-point notation (function )!X!
Cplusplus!/*undefined*/ setw (int n);
Set field width
Sets the field width to be used on output operations.

Behaves as if member width were called with n as argument on the stream on which it is inserted/extracted as a manipulator (it can be inserted/extracted on input streams or output streams).

This manipulator is declared in header <iomanip>.!setw!n
Number of characters to be used as field width.
!Unspecified. This function should only be used as a stream manipulator (see example).!setfill
Set fill character (function )
ios_base::width
Get/set field width (public member function )!X!
Cplusplus!template <class charT, class traits = char_traits<charT> >
  class basic_ios;
Base class for streams (type-dependent components)
ios_base
basic_ios
basic_istream
basic_ostream

Template class to instantiate the base classes for all stream classes.

Both this class template and its parent class, ios_base, define the components of streams that do not depend on whether the stream is an input or an output stream. ios_base describes the members that are independent of the template parameters, while this one describes the members that are dependent on the template parameters.

The class template adds to the information kept by its inherited ios_base component, the following:

field member functions description
Formatting fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
!basic_ios!X!X!streampos
Stream position type (type )
wstreampos
Wide stream position type (type )!X!
Cplusplus!template <class stateT> class fpos;
Stream position class template
Class template used as a template for types to indicate positions in streams. The template depends on the state type stateT.

The details of this class are implementation-defined, but has at least two members:

1
2
stateT state() const;
void state(stateT);


Each either getting or setting the value of the state type (stateT) kept internally by the object.

Objects of any fpos instanced type support construction and conversion from int, and allow consistent conversions to/from values of type streamoff (as well as being added or subtracted values of this type).

Two objects of this type can be compared with operators == and !=. They can also be subtracted, which yields a value of type streamoff.

The synonym types streampos and wstreampos are instantiations of this template with mbstate_t as stateT.!fpos!X!X!X!X!
Cplusplus!typedef basic_ios<char> ios;
Base class for streams (type-dependent components)
ios_base
ios
istream
ostream

Base class for all stream classes using narrow characters (of type char)

This is an instantiation of basic_ios with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Both this class and its parent class, ios_base, define the components of streams that do not depend on whether the stream is an input or an output stream. ios_base describes the members that are independent of the template parameters, while this one describes the members that are dependent on the template parameters.

The class adds to the information kept by its inherited ios_base component, the following:

field member functions description
Formatting fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
!ios!X!X!X!X!
Cplusplus!class ios_base;
Base class for streams
ios_base
basic_ios

Base class for the entire hierarchy of stream classes in the standard input/output library, describing the most basic part of a stream which is common to all stream objects, independently of their character type.

It has no public constructors, and thus no objects of this class can be declared.

Both ios_base and its derived class basic_ios define the components of streams that do not depend on whether the stream is an input or an output stream: ios_base describes the members that are independent of the template parameters (i.e. the character type and traits), while basic_ios describes the members that do depend on them.

More specifically, the ios_base class maintains the following information of a stream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.!ios_base!X!X!X!X!
Cplusplus!enum class io_errc;
Input/output error conditions
This enum class type defines the error conditions of the iostream category.

The enum includes at least the following label:
io_errc label value description
stream 1 Error in stream

All library implementations define at least this value (stream, with a value of 1), but may provide additional values, especially if they require to produce additional error codes for the iostream category.

Values of the enum type io_errc may be used to create error_condition objects to be compared against the value returned by the code member of ios_base::failure.

Although notice that exceptions of type ios_base::failure may also carry error codes from other categories (such as from the system_category).!io_errc!X!X!errc
Generic error conditions (enum class )
iostream_category
Return iostream category (function )
make_error_code (io_errc)
Make error code (function )
make_error_condition (io_errc)
Make error condition (function )!X!
Cplusplus!Stream offset type
Type to represent position offsets in a stream.

It is the type returned by subtracting two stream position of an fpos type, and can be converted to and from this type.

The underlying type depends on the particular library implementation.!streamoff!X!X!streamsize
Stream size type (type )
fpos
Stream position class template (class template )
streampos
Stream position type (type )!X!
Cplusplus!typedef fpos<mbstate_t> streampos;
Stream position type
Instantiation of fpos used to represent positions in narrow-oriented streams.

Objects of this class support construction and conversion from int, and allow consistent conversions to/from streamoff values (as well as being added or subtracted a value of this type).

Two objects of this type can be compared with operators == and !=. They can also be subtracted, which yields a value of type streamoff.

streampos and wstreampos are synonyms: both are typedefs of fpos<mbstate_t>.!streampos!X!X!fpos
Stream position class template (class template )
streamoff
Stream offset type (type )
streamsize
Stream size type (type )!X!
Cplusplus!Stream size type
Type to represent sizes and character counts in streams.

It is a typedef of one the fundamental signed integral types.

It is convertible to/from streamoff.!streamsize!X!X!streamoff
Stream offset type (type )!X!
Cplusplus!typedef basic_ios<wchar_t> ios;
Base class for wide character streams
ios_base
wios
wistream
wostream

This class is an instantiation of basic_ios designed to serve as base class for all wide stream classes, with wchar_t as character type (see basic_ios for more info on the template).

It instantiates basic_ios with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type
!wios!X!X!fpos
Stream position class template (class template )
streamoff
Stream offset type (type )
streamsize
Stream size type (type )!X!
Cplusplus!typedef fpos<mbstate_t> wstreampos;
Wide stream position type
Instantiation of fpos used to represent positions in wide-oriented streams.

Objects of this class support construction and conversion from int, and allow consistent conversions to/from streamoff values (as well as being added or subtracted a value of this type).

Two objects of this type can be compared with operators == and !=. They can also be subtracted, which yields a value of type streamoff.

streampos and wstreampos are synonyms: both are typedefs of fpos<mbstate_t>.!wstreampos!X!X!X!X!
Cplusplus!ios_base& boolalpha (ios_base& str);
Alphanumerical bool values
Sets the boolalpha format flag for the str stream.

When the boolalpha format flag is set, bool values are inserted/extracted by their textual representation: either true or false, instead of integral values.

This flag can be unset with the noboolalpha manipulator.

For standard streams, the boolalpha flag is not set on initialization.!boolalpha!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!noboolalpha
No alphanumerical bool values (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )
setiosflags
Set format flags (function )!X!
Cplusplus!ios_base& dec (ios_base& str);
Use decimal base
Sets the basefield format flag for the str stream to dec.

When basefield is set to dec, integral numerical values inserted into the stream are expressed in decimal base (i.e., radix 10). For input streams, extracted values are also expected to be expressed in decimal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
dec read/write integral values using decimal base format.
hex read/write integral values using hexadecimal base format.
oct read/write integral values using octal base format.

For standard streams, the basefield flag is set to dec on initialization.!dec!str
Stream object whose basefield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!hex
Use hexadecimal base (function )
oct
Use octal base (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )!X!
Cplusplus!ios_base& defaultfloat (ios_base& str);
Use default floating-point notation
Sets the floatfield format flag for the str stream to defaultfloat.

When floatfield is set to defaultfloat, floating-point values are written using the default notation: the representation uses as many meaningful digits as needed up to the stream's decimal precision (precision), counting both the digits before and after the decimal point (if any).

The floatfield format flag is both a selective and a toggle flag: it can take any of the following values, or none:

flag value effect when set
fixed write floating-point values in fixed-point notation.
scientific write floating-point values in scientific notation.
hexfloat write floating-point values in hexadecimal format.
The value of this is the same as (fixed|scientific)
defaultfloat write floating-point values in default floating-point notation. This is the value by default (same as none, before any other floatfield bit is set).

For standard streams, the floatfield format flag is set to this value (defaultfloat) on initialization.
!defaultfloat!str
Stream object whose floatfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.
!fixed
Use fixed floating-point notation (function )
scientific
Use scientific floating-point notation (function )
hexfloat
Use hexadecimal floating-point format (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& fixed (ios_base& str);
Use fixed floating-point notation
Sets the floatfield format flag for the str stream to fixed.

When floatfield is set to fixed, floating-point values are written using fixed-point notation: the value is represented with exactly as many digits in the decimal part as specified by the precision field (precision) and with no exponent part.

C++98C++11
The floatfield format flag is both a selective and a toggle flag: it can take one, both or none of the following values:

flag value effect when set
fixed write floating-point values in fixed-point notation
scientific write floating-point values in scientific notation.
(none) write floating-point values in default floating-point notation.
The default notation (none) is a different floatfield value than either fixed or scientific. The default notation can be selected by calling str.unsetf(ios_base::floatfield).

For standard streams, no floatfield is set on initialization (default notation).

The precision field can be modified using member precision.

Notice that the treatment of the precision field differs between the default floating-point notation and the fixed and scientific notations (see precision). On the default floating-point notation, the precision field specifies the maximum number of meaningful digits to display both before and after the decimal point, while in both the fixed and scientific notations, the precision field specifies exactly how many digits to display after the decimal point, even if they are trailing decimal zeros.!fixed!str
Stream object whose floatfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!scientific
Use scientific floating-point notation (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& hex (ios_base& str);
Use hexadecimal base
Sets the basefield format flag for the str stream to hex.

When basefield is set to hex, integral numerical values inserted into the stream are expressed in hexadecimal base (i.e., radix 16). For input streams, extracted values are also expected to be expressed in hexadecimal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
dec read/write integral values using decimal base format.
hex read/write integral values using hexadecimal base format.
oct read/write integral values using octal base format.

Notice that the basefield flag only affects the insertion/extraction of integer values (floating-point values are always interpreted in decimal base).

Notice also that no base prefix is implicitly prepended to the number unless the showbase format flag is set.

For standard streams, the basefield flag is set to dec on initialization.!hex!str
Stream object whose basefield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.
!dec
Use decimal base (function )
oct
Use octal base (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )!X!
Cplusplus!ios_base& hexfloat (ios_base& str);
Use hexadecimal floating-point format
Sets the floatfield format flag for the str stream to hexfloat.

When floatfield is set to hexfloat, floating-point values are written using hexadecimal format.

The floatfield format flag is both a selective and a toggle flag: it can take any of the following values, or none:

flag value effect when set
fixed write floating-point values in fixed-point notation.
scientific write floating-point values in scientific notation.
hexfloat write floating-point values in hexadecimal format.
The value of this is the same as (fixed|scientific)
defaultfloat write floating-point values in default floating-point notation. This is the value by default (same as none, before any other floatfield bit is set).

For standard streams, the floatfield format flag is set to defaultfloat on initialization.
!hexfloat!str
Stream object whose floatfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!fixed
Use fixed floating-point notation (function )
scientific
Use scientific floating-point notation (function )
defaultfloat
Use default floating-point notation (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& internal (ios_base& str);
Adjust field by inserting characters at an internal position
Sets the adjustfield format flag for the str stream to internal.

When adjustfield is set to internal, the output is padded to the field width (width) by inserting fill characters (fill) at a specified internal point, which for numerical values is between the sign and/or numerical base and the number magnitude. For non-numerical values it is equivalent to right.

The adjustfield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
internal the output is padded to the field width by inserting fill characters at a specified internal point.
left the output is padded to the field width appending fill characters at the end.
right the output is padded to the field width by inserting fill characters at the beginning.

For standard streams, the adjustfield flag is set to right on initialization.!internal!str
Stream object whose adjustfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.
!left
Adjust output to the left (function )
right
Adjust output to the right (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& left (ios_base& str);
Adjust output to the left
Sets the adjustfield format flag for the str stream to left.

When adjustfield is set to left, the output is padded to the field width (width) by inserting fill characters (fill) at the end, effectively adjusting the field to the left.

The adjustfield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
internal the output is padded to the field width by inserting fill characters at a specified internal point.
left the output is padded to the field width appending fill characters at the end.
right the output is padded to the field width by inserting fill characters at the beginning.

For standard streams, the adjustfield flag is set to right on initialization.!left!str
Stream object whose adjustfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!internal
Adjust field by inserting characters at an internal position (function )
right
Adjust output to the right (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& noboolalpha (ios_base& str);
No alphanumerical bool values
Clears the boolalpha format flag for the str stream.

When the boolalpha format flag is not set, bool values are insterted/extracted as integral values (0 and 1) instead of their textual representations: true and false.

This flag can be set with the boolalpha manipulator.

For standard streams, the boolalpha flag is not set on initialization.
!noboolalpha!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.
!boolalpha
Alphanumerical bool values (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& noshowbase (ios_base& str);
Do not show numerical base prefixes
Clears the showbase format flag for the str stream.

When the showbase format flag is not set, numerical values are inserted into the stream without prefixing them with any numerical base prefix (i.e., 0x for hexadecimal values, 0 for octal values and no prefix for decimal-base values).

This flag can be set with the showbase manipulator, which forces the prefixing of numerical integer values with their respective numerical base prefix.

For standard streams, the showbase flag is not set on initialization.
!noshowbase!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!showbase
Show numerical base prefixes (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& noshowpoint (ios_base& str);
Do not show decimal point
Clears the showpoint format flag for the str stream.

When the showpoint format flag is not set, the decimal point is only written when necessary for floating-point values inserted into the stream: when their decimal part is not zero.

This flag can be set with the showpoint manipulator. When the flag is set, the decimal point is always written for floating point values inserted into the stream, even for those whose decimal part is zero.

For standard streams, the showpoint flag is not set on initialization.!noshowpoint!str
Stream object where to apply.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!showpoint
Show decimal point (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& noshowpos (ios_base& str);
Do not show positive signs
Clears the showpos format flag for the str stream.

When the showpos format flag is not set, no plus signs precede positive values inserted in str.

This flag can be set with the showpos manipulator, which forces the writing of a plus sign (+) before every non-negative numerical value inserted into the stream (including zeros).

For standard streams, the showpos flag is not set on initialization.
!noshowpos!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!showpos
Show positive signs (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& noskipws (ios_base& str);
Do not skip whitespaces
Clears the skipws format flag for the str stream.

When the skipws format flag is not set, all operations on the stream consider initial whitespace characters as valid content to be extracted.

Tab spaces, carriage returns and blank spaces are all considered whitespaces (see isspace).

This flag can be set with the skipws manipulator. When set, as many initial whitespace characters as necessary are read and discarded from the stream until a non-whitespace character is found. This would apply to every formatted input operation performed with operator>> on the stream.

Notice that many extraction operations consider the whitespaces themselves as the terminating character, therefore, with the skipws flag disabled, some extraction operations may extract no characters at all from the stream.

For standard streams, the skipws flag is set on initialization.
!noskipws!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!skipws
Skip whitespaces (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& nounitbuf (ios_base& str);
Do not force flushes after insertions
Clears the unitbuf "format" flag for the str stream.

When the unitbuf flag is not set, the associated buffer is not forced to be flushed after every insertion operation.

This flag can be set with the unitbuf manipulator, forcing flushes after every insertion.

For standard streams, the unitbuf flag is not set on initialization.
!nounitbuf!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!unitbuf
Flush buffer after insertions (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& nouppercase (ios_base& str);
Do not generate upper case letters
Clears the uppercase format flag for the str stream.

When the uppercase format flag is not set, the letters automatically generated by the stream for certain representations (like some hexadecimal representations and numerical base prefixes) are not forced to be displayed using uppercase letters (generally using lowercase letters instead).

This flag can be set with the uppercase manipulator, forcing the use of uppercase for generated letters.

For standard streams, the uppercase flag is not set on initialization.!nouppercase!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!uppercase
Generate upper-case letters (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& oct (ios_base& str);
Use octal base
Sets the basefield format flag for the str stream to oct.

When basefield is set to oct, integral numerical values inserted into the stream are expressed in octal base (i.e., radix 8). For input streams, extracted values are also expected to be expressed in octal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
dec read/write integral values using decimal base format.
hex read/write integral values using hexadecimal base format.
oct read/write integral values using octal base format.

Notice that the basefield flag only affects the insertion/extraction of integer values (floating-point values are always interpreted in decimal base).

Notice also that no base prefix is implicitly prepended to the number unless the showbase format flag is set.

For standard streams, the basefield flag is set to dec on initialization.
!oct!str
Stream object whose basefield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!dec
Use decimal base (function )
hex
Use hexadecimal base (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )!X!
Cplusplus!ios_base& right (ios_base& str);
Adjust output to the right
Sets the adjustfield format flag for the str stream to right.

When adjustfield is set to right, the output is padded to the field width (width) by inserting fill characters (fill) at the beginning, effectively adjusting the field to the right.

The adjustfield format flag can take any of the following values (each with its own manipulator):

flag value effect when set
internal the output is padded to the field width by inserting fill characters at a specified internal point.
left the output is padded to the field width appending fill characters at the end.
right the output is padded to the field width by inserting fill characters at the beginning.

For standard streams, the adjustfield flag is set to this value (right) on initialization.!right!str
Stream object whose adjustfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!internal
Adjust field by inserting characters at an internal position (function )
left
Adjust output to the left (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& scientific (ios_base& str);
Use scientific floating-point notation
Sets the floatfield format flag for the str stream to scientific.

When floatfield is set to scientific, floating-point values are written using scientific notation: the value is represented always with only one digit before the decimal point, followed by the decimal point and as many decimal digits as the precision field (precision). Finally, this notation always includes an exponential part consisting on the letter e followed by an optional sign and three exponential digits.

The floatfield format flag is both a selective and a toggle flag: it can take combine one or more of the following values:

flag value effect when set
fixed write floating-point values in fixed-point notation
scientific write floating-point values in scientific notation.
(none) write floating-point values in default floating-point notation.
The default notation (none) is a different floatfield value than either fixed or scientific. The default notation can be selected by calling str.unsetf(ios_base::floatfield).

For standard streams, no floatfield is set on initialization (default notation).

The precision field can be modified using member precision.

Notice that the treatment of the precision field differs between the default floating-point notation and the fixed and scientific notations (see precision). On the default floating-point notation, the precision field specifies the maximum number of meaningful digits to display both before and after the decimal point, while in both the fixed and scientific notations, the precision field specifies exactly how many digits to display after the decimal point, even if they are trailing decimal zeros.!scientific!str
Stream object whose floatfield format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!scientific
Use scientific floating-point notation (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& showbase (ios_base& str);
Show numerical base prefixes
Sets the showbase format flag for the str stream.

When the showbase format flag is set, numerical integer values inserted into output streams are prefixed with the same prefixes used by C++ literal constants: 0x for hexadecimal values (see hex), 0 for octal values (see oct) and no prefix for decimal-base values (see dec).

This option can be unset with the noshowbase manipulator. When not set, all numerical values are inserted without base prefixes.

For standard streams, the showbase flag is not set on initialization.!showbase!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!noshowbase
Do not show numerical base prefixes (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& showpoint (ios_base& str);
Show decimal point
Sets the showpoint format flag for the str stream.

When the showpoint format flag is set, the decimal point is always written for floating point values inserted into the stream (even for those whose decimal part is zero). Following the decimal point, as many digits as necessary are written to match the precision set for the stream (if any).

This flag can be unset with the noshowpoint manipulator. When not set, the decimal point is only written for numbers whose decimal part is not zero.

The precision setting can be modified using the precision member function.

For standard streams, the showpoint flag is not set on initialization.!showpoint!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!noshowpoint
Do not show decimal point (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& showpos (ios_base& str);
Show positive signs
Sets the showpos format flag for the str stream.

When the showpos format flag is set, a plus sign (+) precedes every non-negative numerical value inserted into the stream (including zeros).

This flag can be unset with the noshowpos manipulator.

For standard streams, the showpos flag is not set on initialization.!showpos!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!noshowpos
Do not show positive signs (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& skipws (ios_base& str);
Skip whitespaces
Sets the skipws format flag for the str stream.

When the skipws format flag is set, as many whitespace characters as necessary are read and discarded from the stream until a non-whitespace character is found before. This applies to every formatted input operation performed with operator>> on the stream.

Tab spaces, carriage returns and blank spaces are all considered whitespaces (see isspace).

This flag can be unset with the noskipws manipulator, forcing extraction operations to consider leading whitepaces as part of the content to be extracted.

For standard streams, the skipws flag is set on initialization.!skipws!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!noskipws
Do not skip whitespaces (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& unitbuf (ios_base& str);
Flush buffer after insertions
Sets the unitbuf "format" flag for the str stream.

When the unitbuf flag is set, the associated buffer is flushed after each insertion operation.

This flag can be unset with the nounitbuf manipulator, not forcing flushes after every insertion.

For standard streams, the unitbuf flag is not set on initialization.
!unitbuf!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).
!Argument str.!nounitbuf
Do not force flushes after insertions (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!ios_base& uppercase (ios_base& str);
Generate upper-case letters
Sets the uppercase format flag for the str stream.

When the uppercase format flag is set, uppercase (capital) letters are used instead of lowercase for representations on output operations involving stream-generated letters, like some hexadecimal representations and numerical base prefixes.

This flag can be unset with the nouppercase manipulator, not forcing the use of uppercase for generated letters.

For standard streams, the uppercase flag is not set on initialization.!uppercase!str
Stream object whose format flag is affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) and extraction (>>) operations on streams (see example below).!Argument str.!nouppercase
Do not generate upper case letters (function )
ios_base::flags
Get/set format flags (public member function )
ios_base::setf
Set specific format flags (public member function )
ios_base::unsetf
Clear specific format flags (public member function )!X!
Cplusplus!const error_category& iostream_category();
Return iostream category
Returns a reference to the static object of the error_category type that has the following characteristics:
Its name member function returns a pointer to the character sequence "iostream"
Its equivalent and default_error_condition member functions behave as specified for the base error_category class.

error_condition objects describing errors that correspond to the enum type io_errc are associated to this category. What constitutes one of these correspondences depends on the operating system and the particular library implementation.!iostream_category!none!A reference to the iostream error_category object.!io_errc
Input/output error conditions (enum class )!X!
Cplusplus!extern ostream cerr;
Standard output stream for errors
Object of class ostream that represents the standard error stream oriented to narrow characters (of type char). It corresponds to the C stream stderr.

The standard error stream is a destination of characters determined by the environment. This destination may be shared by more than one standard object (such as cout or clog).

As an object of class ostream, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, cerr is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

cerr is not tied to any other output stream (see ios::tie).

By default, cerr is synchronized with stderr (see ios_base::sync_with_stdio).

A program should not mix output operations on cerr with output operations on wcerr or wclog (or with other wide-oriented output operations on stderr): Once an output operation has been performed on either, the standard error stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stderr. 

For more information on the operations supported by cerr, see the reference for its type: ostream.!cerr!X!X!ostream
Output Stream (class )
cout
Standard output stream (object )
clog
Standard output stream for logging (object )
cin
Standard input stream (object )
wcerr
Standard output stream for errors (wide-oriented) (object )!X!
Cplusplus!extern istream cin;
Standard input stream
Object of class istream that represents the standard input stream oriented to narrow characters (of type char). It corresponds to the C stream stdin.

The standard input stream is a source of characters determined by the environment. It is generally assumed to be input from an external source, such as the keyboard or a file.

As an object of class istream, characters can be retrieved either as formatted data using the extraction operator (operator>>) or as unformatted data, using member functions such as read.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, cin is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

cin is tied to the standard output stream cout (see ios::tie), which indicates that cout's buffer is flushed (see ostream::flush) before each i/o operation performed on cin.

By default, cin is synchronized with stdin (see ios_base::sync_with_stdio).

A program should not mix input operations on cin with input operations on wcin (or with other wide-oriented input operations on stdin): Once an input operation has been performed on either, the standard input stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdin.

For more information on the operations supported by cin, see the reference for its type: istream.
!cin!X!X!istream
Input stream (class )
cout
Standard output stream (object )
wcin
Standard input stream (wide) (object )!X!
Cplusplus!extern ostream clog;
Standard output stream for logging
Object of class ostream that represents the standard logging stream oriented to narrow characters (of type char). It corresponds, along with cerr, to the C stream stderr.

The standard logging stream is a destination of characters determined by the environment. This destination may be shared by more than one standard object (such as cout or cerr).

As an object of class ostream, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, clog is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

clog is not tied to any other stream (see ios::tie).

By default, clog is synchronized with stderr (see ios_base::sync_with_stdio).

A program should not mix output operations on clog with output operations on wclog or wcerr (or with other wide-oriented output operations on stderr): Once an output operation has been performed on either, the standard logging stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stderr. 

For more information on the operations supported by clog, see the reference for its type: ostream.!clog!X!X!ostream
Output Stream (class )
cout
Standard output stream (object )
cerr
Standard output stream for errors (object )
cin
Standard input stream (object )
wclog
Standard output stream for logging (wide) (object )!X!
Cplusplus!std::cout
extern ostream cout;
Standard output stream
Object of class ostream that represents the standard output stream oriented to narrow characters (of type char). It corresponds to the C stream stdout.

The standard output stream is the default destination of characters determined by the environment. This destination may be shared with more standard objects (such as cerr or clog).

As an object of class ostream, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, cout is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

cout is not tied to any other output stream (see ios::tie).

By default, cout is synchronized with stdout (see ios_base::sync_with_stdio).

A program should not mix output operations on cout with output operations on wcout (or with other wide-oriented output operations on stdout): Once an output operation has been performed on either, the standard output stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdout. 

For more information on the operations supported by cout, see the reference for its type: ostream.!cout!X!X!ostream
Output Stream (class )
cin
Standard input stream (object )
cerr
Standard output stream for errors (object )
clog
Standard output stream for logging (object )
wcout
Standard output stream (wide) (object )!X!
Cplusplus!extern basic_ostream<wchar_t> wcerr;
Standard output stream for errors (wide-oriented)
Object of class wostream that represents the standard error stream oriented to wide characters (of type wchar_t). It corresponds to the C stream stderr.

The standard error stream is a destination of characters determined by the environment. This destination may be shared by more than one standard object (such as wcout or wclog).

As an object of a basic_ostream class, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, wcerr is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

wcerr is not tied to any other output stream (see basic_ios::tie).

By default, wcerr is synchronized with stderr (see ios_base::sync_with_stdio).

A program should not mix output operations on wcerr with output operations on cerr or clog (or with other narrow-oriented output operations on stderr): Once an output operation has been performed on either, the standard error stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stderr. 

For more information on the operations supported by wcerr, see the reference for its type: basic_ostream.!wcerr!X!X!basic_ostream
Output stream (class )
cerr
Standard output stream for errors (object )
wcout
Standard output stream (wide) (object )
wclog
Standard output stream for logging (wide) (object )
wcin
Standard input stream (wide) (object )!X!
Cplusplus!extern basic_istream<wchar_t> wcin;
Standard input stream (wide)
Object of class wistream that represents the standard input stream oriented to wide characters (of type wchar_t). It corresponds to the C stream stdin.

The standard input stream is a source of characters determined by the environment. It is generally assumed to be input from an external source, such as the keyboard or a file.

As an object of a basic_istream class, characters can be retrieved either as formatted data using the extraction operator (operator>>) or as unformatted data, using member functions such as read.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, wcin is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

wcin is tied to the standard output stream wcout (see basic_ios::tie), which indicates that wcout's buffer is flushed (see basic_ostream::flush) before each i/o operation performed on wcin.

By default, wcin is synchronized with stdin (see ios_base::sync_with_stdio).

A program should not mix input operations on wcin with input operations on cin (or with other narrow-oriented input operations on stdin): Once an input operation has been performed on either, the standard input stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdin.

For more information on the operations supported by wcin, see the reference for its type: basic_istream.!wcin!X!X!istream
Input stream (class )
cin
Standard input stream (object )
wcout
Standard output stream (wide) (object )!X!
Cplusplus!extern basic_ostream<wchar_t> wclog;
Standard output stream for logging (wide)
Object of class wostream that represents the standard logging stream oriented to wide characters (of type wchar_t). It corresponds, along with wcerr, to the C stream stderr.

The standard logging stream is a destination of characters determined by the environment. This destination may be shared by more than one standard object (such as wcout or wcerr).

As an object of a basic_ostream class, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, wclog is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

wclog is not tied to any other stream (see basic_ios::tie).

By default, clog is synchronized with stderr (see ios_base::sync_with_stdio).

A program should not mix output operations on wclog with output operations on clog or cerr (or with other narrow-oriented output operations on stderr): Once an output operation has been performed on either, the standard logging stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stderr. 

For more information on the operations supported by wclog, see the reference for its type: basic_ostream.
!wclog!X!X!ostream
Output Stream (class )
clog
Standard output stream for logging (object )
wcout
Standard output stream (wide) (object )
wcerr
Standard output stream for errors (wide-oriented) (object )
wcin
Standard input stream (wide) (object )!X!
Cplusplus!extern basic_ostream<wchar_t> wcout;
Standard output stream (wide)
Object of class wostream that represents the standard output stream oriented to wide characters (of type wchar_t). It corresponds to the C stream stdout.

The standard output stream is the default destination of characters determined by the environment. This destination may be shared with more standard objects (such as wcerr or wclog).

As an object of a basic_ostream class, characters can be written to it either as formatted data using the insertion operator (operator<<) or as unformatted data, using member functions such as write.

The object is declared in header <iostream> with external linkage and static duration: it lasts the entire duration of the program.

In terms of static initialization order, wcout is guaranteed to be properly constructed and initialized no later than the first time an object of type ios_base::Init is constructed.

wcout is not tied to any other output stream (see basic_ios::tie).

By default, wcout is synchronized with stdout (see ios_base::sync_with_stdio).

A program should not mix output operations on wcout with output operations on cout (or with other narrow-oriented output operations on stdout): Once an output operation has been performed on either, the standard output stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdout. 

For more information on the operations supported by wcout, see the reference for its type: basic_ostream.!wcout!X!X!ostream
Output Stream (class )
cout
Standard output stream (object )
wcin
Standard input stream (wide) (object )
wcerr
Standard output stream for errors (wide-oriented) (object )
wclog
Standard output stream for logging (wide) (object )!X!
Cplusplus!template <class charT, class traits = char_traits<charT> >
  class basic_iostream;
Input/output stream
ios_base
basic_ios
basic_istream
basic_ostream
basic_iostream
basic_fstream
basic_stringstream

This class inherits all members from its two basic_istream and basic_ostream (using virtual inheritance), thus being able to perform both input and output operations.

The class relies on a single basic_streambuf object for both the input and output operations.

Objects of these classes keep a set of internal fields inherited from ios_base, basic_ios and basic_istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!basic_iostream!X!X!X!X!
Cplusplus!template <class charT, class traits = char_traits<charT> >
  class basic_istream;
Input stream
ios_base
basic_ios
basic_istream
basic_iostream
basic_ifstream
basic_istringstream

Input stream objects can read and interpret input from sequences of characters. Specific members are provided to perform these input operations (see functions below).

The standard objects cin and wcin use particular instantiations of this class template.

Objects of these classes keep a set of internal fields inherited from ios_base and basic_ios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.

To these, basic_istream adds the character count (accessible using member gcount).!basic_istream!X!X!X!X!
Cplusplus!typedef basic_iostream<char> iostream;
Input/output stream
ios_base
ios
istream
ostream
iostream
fstream
stringstream

[NOTE: This page describes the iostream class, for a description of the iostream library, see Input/Output library.]

This is an instantiation of basic_iostream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

This class inherits all members from its two parent classes istream and ostream, thus being able to perform both input and output operations.

The class relies on a single streambuf object for both the input and output operations.

Objects of these classes keep a set of internal fields inherited from ios_base, ios and istream:
field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!iostream!X!X!X!X!
Cplusplus!typedef basic_istream<char> istream;
Input stream
ios_base
ios
istream
iostream
ifstream
istringstream

Input stream objects can read and interpret input from sequences of characters. Specific members are provided to perform these input operations (see functions below).

The standard object cin is an object of this type.

This is an instantiation of basic_istream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Objects of these classes keep a set of internal fields inherited from ios_base and ios:
field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.

To these, istream adds the character count (accessible using member gcount).!istream!X!X!X!X!
Cplusplus!typedef basic_iostream<wchar_t> wiostream;
Input/output stream (wide)
ios_base
wios
wistream
wostream
wiostream
wfstream
wstringstream

This is an instantiation of basic_iostream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

This class inherits all members from its two parent classes wistream and wostream, thus being able to perform both input and output operations.

The class relies on a single wstreambuf object for both the input and output operations.

Objects of these classes keep a set of internal fields inherited from ios_base and wios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated wstreambuf object, which is charge of all input/output operations.
!wiostream!X!X!X!X!
Cplusplus!typedef basic_istream<wchar_t> wistream;
Input stream (wide)
ios_base
wios
wistream
wiostream
wifstream
wistringstream

Input stream objects can read and interpret input from sequences of characters. Specific members are provided to perform these input operations (see functions below).

The standard object wcin is an object of this type.

This is an instantiation of basic_istream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Objects of these classes keep a set of internal fields inherited from ios_base and wios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated wstreambuf object, which is charge of all input/output operations.
!wistream!X!X!X!X!
Cplusplus!for istream 
istream& ws (istream& is);
basic template 
template <class charT, class traits>
basic_istream<charT,traits>& ws (basic_istream<charT,traits>& is);
Extract whitespaces
Extracts as many whitespace characters as possible from the current position in the input sequence. The extraction stops as soon as a non-whitespace character is found. These extracted whitespace characters are discarded.

Notice that basic_istream objects have the skipws flag set by default: This applies a similar effect before the formatted extraction operations (see operator>>).

No specifications on the internal operations performed by this function.

Calling this function does not alter the value returned by gcount.
!ws!is
Input stream object from where whitespaces are extracted.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the extraction (>>) operations on input streams (see example below).!Argument is.

Errors are signaled by modifying the internal state flags of is:
flag error
eofbit The function stopped extracting characters because the input sequence has no more characters available (end-of-file reached).
failbit The stream state of is was not good before the call (applies to C++11 and other implementations constructing a sentry object)
badbit Error on stream (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set on is by a single operation.

If the operation sets an internal state flag of is that was registered using its member exceptions, the function throws an exception of member type failure.!skipws
Skip whitespaces (function )
noskipws
Do not skip whitespaces (function )!X!
Cplusplus!template <class charT, class traits = char_traits<charT> >
  class basic_ostream;
Output stream
ios_base
basic_ios
basic_ostream
basic_iostream
basic_ofstream
basic_ostringstream

Output stream objects can write sequences of characters and represent other kinds of data. Specific members are provided to perform these output operations (see functions below).

The standard objects cout, cerr, clog, wcout, wcerr and wclog use particular instantiations of this class template.

Objects of these classes keep a set of internal fields inherited from ios_base and basic_ios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
!basic_ostream!X!X!X!X!
Cplusplus!typedef basic_ostream<char> ostream;
Output Stream
ios_base
ios
ostream
iostream
ofstream
ostringstream

Output stream objects can write sequences of characters and represent other kinds of data. Specific members are provided to perform these output operations (see functions below).

The standard objects cout, cerr and clog are objects of this type.

This is an instantiation of basic_ostream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

Objects of this class keep a set of internal fields inherited from ios_base and ios:
field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
!ostream!X!X!X!X!
Cplusplus!typedef basic_ostream<wchar_t> wostream;
Output stream (wide)
ios_base
wios
wostream
wiostream
wofstream
wostringstream

Output stream objects can write sequences of characters and represent other kinds of data. Specific members are provided to perform these output operations (see functions below).

The standard objects wcout, wcerr and wclog are objects of this type.

This is an instantiation of basic_ostream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type

Objects of this class keep a set of internal fields inherited from ios_base and wios:
field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.!wostream!X!X!X!X!
Cplusplus!for ostream 
ostream& endl (ostream& os);
basic template 
template <class charT, class traits>
basic_ostream<charT,traits>& endl (basic_ostream<charT,traits>& os);
Insert newline and flush
Inserts a new-line character and flushes the stream.

Its behavior is equivalent to calling os.put('\n') (or os.put(os.widen('\n')) for character types other than char), and then os.flush().
!endl!os
Output stream object affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) operations on output streams (see example below).!Argument os.

Errors are signaled by modifying the internal state flags of os:
flag error
eofbit -
failbit May be set if the construction of a sentry object failed.
badbit Either the insertion on the stream (or the synchronization) failed, or some other error happened (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set on os by a single operation.

If the operation sets an internal state flag of os that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!flush
Flush stream buffer (function )
ostream::operator<<
Insert formatted output (public member function )!X!
Cplusplus!for ostream 
ostream& ends (ostream& os);
basic template 
template <class charT, class traits>
basic_ostream<charT,traits>& ends (basic_ostream<charT,traits>& os);
Insert null character
Inserts a null character on os.

Its behavior is equivalent to calling os.put('\0') (or os.put(charT()) for other character types).!ends!os
Output stream object where character is inserted.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) operations on output streams.!Argument os.

Errors are signaled by modifying the internal state flags of os:
flag error
eofbit -
failbit May be set if the construction of a sentry object failed.
badbit Either the insertion on the stream failed, or some other error happened (such as when this function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set on os by a single operation.

If the operation sets an internal state flag of os that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!endl
Insert newline and flush (function )
ostream::operator<<
Insert formatted output (public member function )!X!
Cplusplus!for ostream 
ostream& flush (ostream& os);
basic template 
template <class charT, class traits>
basic_ostream<charT,traits>& flush (basic_ostream<charT,traits>& os);
Flush stream buffer
Synchronizes the associated stream buffer with its controlled output sequence.

For stream buffer objects that implement intermediate buffers, this function requests all characters to be written to the controlled sequence.

Its behavior is equivalent to calling os's member function flush.

A member function with the same name and behavior exists (see ostream::flush).

Parameters
os
Output stream object affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) operations on output streams (see example below).!flush!os
Output stream object affected.
Because this function is a manipulator, it is designed to be used alone with no arguments in conjunction with the insertion (<<) operations on output streams (see example below).!Argument os.

Errors are signaled by modifying the internal state flags of os:
flag error
eofbit -
failbit May be set if the construction of a sentry object failed.
badbit The synchronization operation failed (including if the function catches an exception thrown by an internal operation).
When set, the integrity of the stream may have been affected.
Multiple flags may be set on os by a single operation.

If the operation sets an internal state flag of os that was registered using its member exceptions, the function throws an exception of type ios_base::failure.!endl
Insert newline and flush (function )
ostream::flush
Flush output stream buffer (public member function )!X!
Cplusplus!template < class charT,                           // basic_istringstream::char_type
           class traits = char_traits<charT>,     // basic_istringstream::traits_type
           class Alloc = allocator<charT>         // basic_istringstream::allocator_type
           > class basic_istringstream;
Input string stream
ios_base
basic_ios
basic_istream
basic_istringstream

Input stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a basic_string object, using member str.

The characters in the sequence can be extracted from the stream using any operation allowed on input streams.

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base, basic_ios and basic_istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).!basic_istringstream!X!X!X!X!
Cplusplus!template < class charT,                           // basic_ostringstream::char_type
           class traits = char_traits<charT>,     // basic_ostringstream::traits_type
           class Alloc = allocator<charT>         // basic_ostringstream::allocator_type
           > class basic_ostringstream;
Output string stream
ios_base
basic_ios
basic_ostream
basic_ostringstream

Output stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a basic_string object, using member str.

Characters can be inserted into the stream with any operation allowed on output streams.

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base and basic_ios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
!basic_ostringstream!X!X!X!X!
Cplusplus!template < class charT,                           // basic_stringbuf::char_type
           class traits = char_traits<charT>,     // basic_stringbuf::traits_type
           class Alloc = allocator<charT>         // basic_stringbuf::allocator_type
           > class basic_stringbuf;
String stream buffer
basic_streambuf
basic_stringbuf

Stream buffer to read from and write to basic_string objects.

Objects of this class maintain internally a sequence of characters that they use as their associated input sequence and/or associated output sequence. The internal sequence can be initialized from a basic_string object, or copied to one, using member str.

Access to the internal sequence of characters is given to streams by means of the interface offered by the virtual members inherited from basic_streambuf that are overriden in this class:!basic_stringbuf!X!X!X!X!
Cplusplus!template < class charT,                           // basic_stringstream::char_type
           class traits = char_traits<charT>,     // basic_stringstream::traits_type
           class Alloc = allocator<charT>         // basic_stringstream::allocator_type
           > class basic_stringstream;
String stream
ios_base
basic_ios
basic_istream
basic_ostream
basic_iostream
basic_stringstream

Stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a basic_string object, using member str.

Characters can be inserted and/or extracted from the stream using any operation allowed on both input and output streams.

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base, basic_ios and basic_istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.!basic_stringstream!X!X!X!X!
Cplusplus!typedef basic_istringstream<char> istringstream;
Input string stream
ios_base
ios
istream
istringstream

Input stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a string object, using member str.

The characters in the sequence can be extracted from the stream using any operation allowed on input streams.

This is an instantiation of basic_istringstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type
Alloc allocator<char> Aliased as member allocator_type

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base, ios and istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!istringstream!X!X!X!X!
Cplusplus!typedef basic_ostringstream<char> ostringstream;
Output string stream
ios_base
ios
ostream
ostringstream

Output stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a string object, using member str.

Characters can be inserted into the stream with any operation allowed on output streams.

This is an instantiation of basic_ostringstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type
Alloc allocator<char> Aliased as member allocator_type

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base and ios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
!ostringstream!X!X!X!X!
Cplusplus!typedef basic_stringbuf<char> stringbuf;
String stream buffer
streambuf
stringbuf

Stream buffer to read from and write to string objects.

Objects of this class maintain internally a sequence of characters that they use as their associated input sequence and/or associated output sequence. The internal sequence can be initialized from a string object, or copied to one, using member str.

Access to the internal sequence of characters is given to streams by means of the interface offered by the virtual members inherited from streambuf that are overriden in this class:!stringbuf!X!X!X!X!
Cplusplus!typedef basic_stringstream<char> stringstream;
Input/output string stream
ios_base
ios
istream
ostream
iostream
stringstream

Stream class to operate on strings.

Objects of this class use a string buffer that contains a sequence of characters. This sequence of characters can be accessed directly as a string object, using member str.

Characters can be inserted and/or extracted from the stream using any operation allowed on both input and output streams.

This is an instantiation of basic_stringstream with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type
Alloc allocator<char> Aliased as member allocator_type

Apart from the internal string buffer, objects of these classes keep a set of internal fields inherited from ios_base, ios and istream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation.
!stringstream!X!X!X!X!
Cplusplus!typedef basic_istringstream<wchar_t> wistringstream;
Input string stream (wide)
ios_base
wios
wistream
wistringstream

Input stream class to operate on strings of wide characters.

This is an instantiation of basic_istringstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type
Alloc allocator<wchar_t> Aliased as member allocator_type

Apart from the internal string buffer of type wstringbuf, objects of this class keep a set of internal fields inherited from ios_base, wios and wistream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!wistringstream!X!X!X!X!
Cplusplus!typedef basic_ostringstream<wchar_t> wostringstream;
Output string stream (wide)
ios_base
wios
wostream
wostringstream

Output stream class to operate on strings of wide characters.

This is an instantiation of basic_ostringstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type
Alloc allocator<wchar_t> Aliased as member allocator_type

Apart from the internal string buffer of type wstringbuf, objects of this class keep a set of internal fields inherited from ios_base and wios:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.!wostringstream!X!X!X!X!
Cplusplus!typedef basic_stringbuf<wchar_t> wstringbuf;
String stream buffer (wide)
wstreambuf
wstringbuf

Stream buffer to read from and write to wstring objects.

Objects of this class maintain internally a sequence of wide characters that they use as their associated input sequence and/or associated output sequence. The internal sequence can be initialized from a wstring object, or copied to one, using member str.

Access to the internal sequence of characters is given to streams by means of the interface offered by the virtual members inherited from wstreambuf that are overriden in this class:!wstringbuf!X!X!X!X!
Cplusplus!typedef basic_stringstream<wchar_t> wstringstream;
Input/output string stream (wide)
ios_base
wios
wistream
wostream
wiostream
wstringstream

Stream class to operate on strings of wide characters.

This is an instantiation of basic_stringstream with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type
Alloc allocator<wchar_t> Aliased as member allocator_type

Apart from the internal string buffer of type wstringbuf, objects of this class keep a set of internal fields inherited from ios_base, wios and wistream:

field member functions description
Formatting format flags flags
setf
unsetf A set of internal flags that affect how certain input/output operations are interpreted or generated.
See member type fmtflags.
field width width Width of the next formatted element to insert.
display precision precision Decimal precision for the next floating-point value inserted.
locale getloc
imbue The locale object used by the function for formatted input/output operations affected by localization properties.
fill character fill Character to pad a formatted field up to the field width (width).
State error state rdstate
setstate
clear The current error state of the stream.
Individual values may be obtained by calling good, eof, fail and bad.
See member type iostate.
exception mask exceptions The state flags for which a failure exception is thrown.
See member type iostate.
Other callback stack register_callback Stack of pointers to functions that are called when certain events occur.
extensible arrays iword
pword
xalloc Internal arrays to store objects of type long and void*.
tied stream tie Pointer to output stream that is flushed before each i/o operation on this stream.
stream buffer rdbuf Pointer to the associated basic_streambuf object, which is charge of all input/output operations.
character count gcount Count of characters read by last unformatted input operation (input streams only).
!wstringstream!X!X!X!X!
Cplusplus!template <class charT, class traits = char_traits<charT> >
  class basic_streambuf;
Base buffer class for streams
basic_streambuf
basic_filebuf
basic_stringbuf

This template is designed as base virtual class for all stream buffer classes.

A stream buffer is an object in charge of performing the reading and writing operations of the stream object it is associated with: the stream delegates all such operations to its associated stream buffer object, which is an intermediary between the stream and its controlled input and output sequences.

All stream objects, no matter whether buffered or unbuffered, have an associated stream buffer: Some stream buffer types may then be set to either use an intermediate buffer or not.

Stream buffer objects keep internally, at least:
A locale object, used for locale-dependent operations.
A set of internal pointers to keep an input buffer: eback, gptr, egptr.
A set of internal pointers to keep an output buffer: pbase, pptr, epptr.

Internally, the basic_streambuf class is an elaborated base class designed to provide a uniform public interface for all derived classes: These public functions call virtual protected members that derived classes may override to implement specific behavior. These overridden virtual functions have access to the internals of the basic_streambuf class by means of a set of protected functions (see below).!basic_streambuf!X!X!X!X!
Cplusplus!typedef basic_streambuf<char> streambuf;
Base buffer class for streams
streambuf
filebuf
stringbuf

This template is designed as base virtual class for all stream buffer classes that handle narrow characters (of type char).

It is an instantiation of basic_streambuf with the following template parameters:
template parameter definition comments
charT char Aliased as member char_type
traits char_traits<char> Aliased as member traits_type

A stream buffer is an object in charge of performing the reading and writing operations of the stream object it is associated with: the stream delegates all such operations to its associated stream buffer object, which is an intermediary between the stream and its controlled input and output sequences.

All stream objects, no matter whether buffered or unbuffered, have an associated stream buffer: Some stream buffer types may then be set to either use an intermediate buffer or not.

Stream buffer objects keep internally, at least:
A locale object, used for locale-dependent operations.
A set of internal pointers to keep an input buffer: eback, gptr, egptr.
A set of internal pointers to keep an output buffer: pbase, pptr, epptr.

Internally, the streambuf class is an elaborated base class designed to provide a uniform public interface for all derived classes: These public functions call virtual protected members that derived classes may override to implement specific behavior. These overridden virtual functions have access to the internals of the streambuf class by means of a set of protected functions (see below).
!streambuf!X!X!X!X!
Cplusplus!typedef basic_streambuf<wchar_t> wstreambuf;
Base buffer class for streams (wide)
wstreambuf
wfilebuf
wstringbuf

This template is designed as base virtual class for all stream buffer classes that handle wide characters (of type wchar_t). See basic_streambuf for more info on the template.

It instantiates basic_streambuf with the following template parameters:
template parameter definition comments
charT wchar_t Aliased as member char_type
traits char_traits<wchar_t> Aliased as member traits_type
!wstreambuf!X!X!X!X!
Cplusplus!struct adopt_lock_t {};
Type of adopt_lock
This is an empty class used as the type of adopt_lock.

Passing adopt_lock to the constructor of unique_lock of lock_guard, makes the object to not lock the mutex object, and assume instead that it is already locked by the current thread.!adopt_lock_t!X!X!adopt_lock
Adopt lock (object )
defer_lock_t
Type of defer_lock (class )
try_to_lock_t
Type of try_to_lock (class )!X!
Cplusplus!struct defer_lock_t {};
Type of defer_lock
This is an empty class used as the type of defer_lock.

Passing defer_lock to unique_lock's constructor, makes it not to lock the mutex object automatically on construction, initializing the object as not owning a lock.
!defer_lock_t!X!X!defer_lock
Defer lock (object )
try_to_lock_t
Type of try_to_lock (class )
adopt_lock_t
Type of adopt_lock (class )!X!
Cplusplus!template <class Mutex> class lock_guard;
Lock guard
A lock guard is an object that manages a mutex object by keeping it always locked.

On construction, the mutex object is locked by the calling thread, and on destruction, the mutex is unlocked. It is the simplest lock, and is specially useful as an object with automatic duration that lasts until the end of its context. In this way, it guarantees the mutex object is properly unlocked in case an exception is thrown.

Note though that the lock_guard object does not manage the lifetime of the mutex object in any way: the duration of the mutex object shall extend at least until the destruction of the lock_guard that locks it.!lock_guard!X!X!unique_lock
Unique lock (class template )!X!
Cplusplus!class mutex;
Mutex class
A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations.

mutex objects provide exclusive ownership and do not support recursivity (i.e., a thread shall not lock a mutex it already owns) -- see recursive_mutex for an alternative class that does.

It is guaranteed to be a standard-layout class.
!mutex!X!X!X!X!
Cplusplus!struct once_flag;
Flag argument type for call_once
Object of this type are used as arguments for call_once.

Using the same object on different calls to call_once in different threads causes a single execution if called concurrently.

It is a non-copyable, non-movable, default-constructible class, declared in <mutex> with the following prototype:
1
2
3
4
5
struct once_flag {
  constexpr once_flag() noexcept;
  once_flag (const once_flag&) = delete;
  once_flag& operator= (const once_flag&) = delete;
};
!once_flag!X!X!X!X!
Cplusplus!class recursive_mutex;
Recursive mutex class
A recursive mutex is a lockable object, just like mutex, but allows the same thread to acquire multiple levels of ownership over the mutex object.

This allows to lock (or try-lock) the mutex object from a thread that is already locking it, acquiring a new level of ownership over the mutex object: the thread will remain locked until member unlock is called as many times as this level of ownership.

It is guaranteed to be a standard-layout class.!recursive_mutex!X!X!X!X!
Cplusplus!class recursive_timed_mutex;
Recursive timed mutex
A recursive timed mutex combines both the features of recursive_mutex and the features of timed_mutex into a single class: it supports both acquiring multiple lock levels by a single thread and also timed try-lock requests.

It is guaranteed to be a standard-layout class.!recursive_timed_mutex!X!X!X!X!
Cplusplus!class timed_mutex;
Timed mutex class
A timed mutex is a time lockable object that is designed to signal when critical sections of code need exclusive access, just like a regular mutex, but additionally supporting timed try-lock requests.

As such, a timed_mutex has two additional members: try_lock_for and try_lock_until.

It is guaranteed to be a standard-layout class.!timed_mutex!X!X!X!X!
Cplusplus!struct try_to_lock_t {};
Type of try_to_lock
This is an empty class used as the type of try_to_lock.

Passing try_to_lock to unique_lock's constructor, makes it to attempt to lock the mutex object by calling its try_lock member, instead of lock.
!try_to_lock_t!X!X!try_to_lock
Try to lock (object )
defer_lock_t
Type of defer_lock (class )
adopt_lock_t
Type of adopt_lock (class )!X!
Cplusplus!template <class Mutex> class unique_lock;
Unique lock
A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.

On construction (or by move-assigning to it), the object acquires a mutex object, for whose locking and unlocking operations becomes responsible.

The object supports both states: locked and unlocked.

This class guarantees an unlocked status on destruction (even if not called explicitly). Therefore it is especially useful as an object with automatic duration, as it guarantees the mutex object is properly unlocked in case an exception is thrown.

Note though, that the unique_lock object does not manage the lifetime of the mutex object in any way: the duration of the mutex object shall extend at least until the destruction of the unique_lock that manages it.
!unique_lock!X!X!X!X!
Cplusplus!template <class Fn, class... Args>
  void call_once (once_flag& flag, Fn&& fn, Args&&... args);
Call function once
Calls fn passing args as arguments, unless another thread has already executed (or is currently executing) a call to call_once with the same flag.

If another thread is already actively executing a call to call_once with the same flag, it causes a passive execution: Passive executions do not call fn but do not return until the active execution itself has returned, and all visible side effects are synchronized at that point among all concurrent calls to this function with the same flag.

If an active call to call_once ends by throwing an exception (which is propagated to its calling thread) and passive executions exist, one is selected among these passive executions, and called to be the new active call instead.

Note that once an active execution has returned, all current passive executions and future calls to call_once (with the same flag) also return without becoming active executions.

The active execution uses decay copies of the lvalue or rvalue references of fn and args, ignoring the value returned by fn.
!call_once!flag
Object used by the function to track the state of invocations.
Using the same object for calls in different threads, results in a single call if called concurrently.
If flag has an state that is not valid, the function throws a system_error exception with an invalid_argument error condition.
call_once is a specific type defined in header <mutex> to be used as argument to this function.
fn
A pointer to function, pointer to member, or any kind of move-constructible function object (i.e., an object whose class defines operator(), including closures and function objects).
The return value (if any) is ignored.
args...
Arguments passed to the call to fn. Their types shall be move-constructible.
If fn is a member pointer, the first argument shall be an object for which that member is defined (or a reference, or a pointer to it).!none
!once_flag
Flag argument type for call_once (class )
thread
Thread (class )!X!
Cplusplus!template <class Mutex1, class Mutex2, class... Mutexes>
  void lock (Mutex1& a, Mutex2& b, Mutexes&... cde);
Lock multiple mutexes
Locks all the objects passed as arguments, blocking the calling thread if necessary.

The function locks the objects using an unspecified sequence of calls to their members lock, try_lock and unlock that ensures that all arguments are locked on return (without producing any deadlocks).

If the function cannot lock all objects (such as because one of its internal calls threw an exception), the function first unlocks all objects it successfully locked (if any) before failing.!lock!a, b, cde
Objects to locked.
Mutex1, Mutex2 and Mutexes shall be lockable types.!none!try_lock
Try to lock multiple mutexes (function template )!X!
Cplusplus!template <class Mutex1, class Mutex2, class... Mutexes>
  int try_lock (Mutex1& a, Mutex2& b, Mutexes&... cde);
Try to lock multiple mutexes
Attempts to lock all the objects passed as arguments using their try_lock member functions (non-blocking).

The function calls the try_lock member function for each argument (first a, then b, and eventually the others in cde, in the same order), until either all calls are successful, or as soon as one of the calls fails (either by returning false or throwing an exception).

If the function ends because a call fails, unlock is called on all objects for which the call to try_lock was successful, and the function returns the argument order number of the object whose lock failed. No further calls are performed for the remaining objects in the argument list.!try_lock!a, b, cde
Objects to try-lock.
Mutex1, Mutex2 and Mutexes shall be lockable types.
!In case the function is successful locking all objects, it returns -1.
Otherwise, the function returns the index of the object which failed to be locked (0 for a, 1 for b,...).
!lock
Lock multiple mutexes (function template )!X!
Cplusplus!constexpr adopt_lock_t adopt_lock {};
Adopt lock
Value used as possible argument to the constructor of unique_lock or lock_guard.

unique_lock objects constructed with adopt_lock do not lock the mutex object on construction, assuming instead that it is already locked by the current thread.

The value is a compile-time constant that carries no state, and is merely used to disambiguate between constructor signatures.

adopt_lock_t is an empty class.!adopt_lock!X!X!defer_lock
Defer lock (object )
try_to_lock
Try to lock (object )!X!
Cplusplus!constexpr defer_lock_t defer_lock {};
Defer lock
Value used as possible argument to unique_lock's constructor.

unique_lock objects constructed with defer_lock do not lock the mutex object automatically on construction, initializing them as not owning a lock.

The value is a compile-time constant that carries no state, and is merely used to disambiguate between constructor signatures.

defer_lock_t is an empty class.!defer_lock!X!X!try_to_lock
Try to lock (object )
adopt_lock
Adopt lock (object )!X!
Cplusplus!constexpr try_to_lock_t try_to_lock {};
Try to lock
Value used as possible argument to unique_lock's constructor.

unique_lock objects constructed with try_to_lock attempt to lock the mutex object by calling its try_lock member instead of its lock member.

The value is a compile-time constant that carries no state, and is merely used to disambiguate between constructor signatures.

try_to_lock_t is an empty class.!try_to_lock!X!X!X!X!
Cplusplus!class thread;
Thread
Class to represent individual threads of execution.

A thread of execution is a sequence of instructions that can be executed concurrently with other such sequences in multithreading environments, while sharing a same address space.

An initialized thread object represents an active thread of execution; Such a thread object is joinable, and has a unique thread id.

A default-constructed (non-initialized) thread object is not joinable, and its thread id is common for all non-joinable threads.

A joinable thread becomes not joinable if moved from, or if either join or detach are called on them.
!thread!X!X!X!X!
Cplusplus!This thread
This namespace groups a set of functions that access the current thread.
!this_thread!X!X!X!X!
Cplusplus!template <class T>  future;
template <class R&> future<R&>;     // specialization : T is a reference type (R&)
template <>         future<void>;   // specialization : T is void
Future
A future is an object that can retrieve a value from some provider object or function, properly synchronizing this access if in different threads.

"Valid" futures are future objects associated to a shared state, and are constructed by calling one of the following functions:
async
promise::get_future
packaged_task::get_future

future objects are only useful when they are valid. Default-constructed future objects are not valid (unless move-assigned a valid future).

Calling future::get on a valid future blocks the thread until the provider makes the shared state ready (either by setting a value or an exception to it). This way, two threads can be synchronized by one waiting for the other to set a value.

The lifetime of the shared state lasts at least until the last object with which it is associated releases it or is destroyed. Therefore, if associated to a future, the shared state can survive the object from which it was obtained in the first place (if any).!future!X!X!X!X!
Cplusplus!class future_error : public logic_error;
Future error exception
exception
logic_error
future_error

This class defines the type of objects thrown as exceptions to report invalid operations on future objects or other elements of the library that may access a future's shared state.

The class inherits from logic_error, to which it adds an error_code as member code (and defines a specialized what member).!future_error!X!X!X!X!
Cplusplus!template <class T> packaged_task;     // undefined
template <class Ret, class... Args> class packaged_task<Ret(Args...)>;
Packaged task
A packaged_task wraps a callable element and allows its result to be retrieved asynchronously.

It is similar to std::function, but transferring its result automatically to a future object.

The object contains internally two elements:
A stored task, which is some callable object (such as a function pointer, pointer to member or function object) whose call signature shall take arguments of the types in Args... and return a value of type Ret.
A shared state, which is able to store the results of calling the stored task (of type Ret) and be accessed asynchronously through a future.

The shared state is associated to a future object by calling member get_future. After the call, both objects share the same shared state:
- The packaged_task object is the asynchronous provider and is expected to set the shared state as ready at some point by calling the stored task.
- The future object is an asynchronous return object that can retrieve the value of the shared state, waiting for it to be ready, if necessary.

The lifetime of the shared state lasts at least until the last object with which it is associated releases it or is destroyed. Therefore it can survive the packaged_task object that obtained it in the first place if associated also to a future.!packaged_task!X!X!X!X!
Cplusplus!template <class T>  promise;
template <class R&> promise<R&>;     // specialization : T is a reference type (R&)
template <>         promise<void>;   // specialization : T is void
Promise
A promise is an object that can store a value of type T to be retrieved by a future object (possibly in another thread), offering a synchronization point.

On construction, promise objects are associated to a new shared state on which they can store either a value of type T or an exception derived from std::exception.

This shared state can be associated to a future object by calling member get_future. After the call, both objects share the same shared state:
- The promise object is the asynchronous provider and is expected to set a value for the shared state at some point.
- The future object is an asynchronous return object that can retrieve the value of the shared state, waiting for it to be ready, if necessary.

The lifetime of the shared state lasts at least until the last object with which it is associated releases it or is destroyed. Therefore it can survive the promise object that obtained it in the first place if associated also to a future.
!promise!X!X!X!X!
Cplusplus!template <class T>  shared_future;
template <class R&> shared_future<R&>;   // specialization : T is a reference type (R&)
template <>         shared_future<void>; // specialization : T is void
Shared future
A shared_future object behaves like a future object, except that it can be copied, and that more than one shared_future can share ownership over their end of a shared state. They also allow the value in the shared state to be retrieved multiple times once ready.

shared_future objects can be implicitly converted from future objects (see its constructor), or explicitly obtained by calling future::share. In both cases, the future object from which it is obtained transfers its association with the shared state to the shared_future and becomes itself non-valid.

The lifetime of the shared state lasts at least until the last object with which it is associated is destroyed. Retrieving the value from a shared_future (with member get) does not release its ownership over the shared state (unlike with futures). Therefore, if associated to shared_future objects, the shared state can survive the object from which it was obtained in the first place (if any).!shared_future!X!X!X!X!
Cplusplus!enum class future_errc;
Error conditions for future objects
This enum class type defines the error conditions of the future category.

future_errc label int value description
broken_promise 0 The promise object with which the future shares its shared state was destroyed before being set a value or an exception.
future_already_retrieved 1 A future object was already retrieved from this provider.
promise_already_satisfied 2 The promise object was already set a value or exception.
no_state 3 An operation attempted to access the shared state of an object with no shared state.

All library implementations define at least the values above, but may provide additional values.

Values of the enum type future_errc may be used to create error_condition objects to be compared against the value returned by the code member of future_error.
!future_errc!X!X!errc
Generic error conditions (enum class )
future_category
Return future category (function )!X!
Cplusplus!enum class future_status;
Return value for timed future operations
This enum class type defines the possible return values of the wait_for and wait_until member functions of future and shared_future.

future_status label int value description
future_status::ready 0 The function returned because the shared state was ready.
future_status::timeout 1 The function returned because the specified time was exhausted.
future_status::deferred 2 The function returned because the shared state contains a deferred function (see std::async).
!future_status!X!X!future::wait_for
Wait for ready during time span (public member function )
future::wait_until
Wait for ready until time point (public member function )
shared_future::wait_for
Wait for ready during time span (public member function )
shared_future::wait_until
Wait for ready until time point (public member function )!X!
Cplusplus!enum class launch;
Launching policy for async
This enum class type is a bitmask type that defines the launching policy in calls to async.

It can be any combination of the following values:

launch label int value description
launch::async unspecified Asynchronous: The function is called asynchronously by a new thread and synchronizes its return with the point of access to the shared state.
launch::deferred unspecified Deferred: The function is called at the point of access to the shared state.
The unspecified equivalent int values shall denote individual bits, allowing several labels to be combined in a single bitmask. When multiple values of this type are combined, the function automatically selects one (depending on their particular library implementation).

Library implementations may define additional labels of this type for different launching policies that may describe restrictions on task interaction by different calls.!launch!X!X!async
Call function asynchronously (function template )!X!
Cplusplus!unspecified policy (1) 
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (Fn&& fn, Args&&... args);
specific policy (2) 
template <class Fn, class... Args>
  future<typename result_of<Fn(Args...)>::type>
    async (launch policy, Fn&& fn, Args&&... args);
Call function asynchronously
Calls fn (with args as arguments) at some point, returning without waiting for the execution of fn to complete.

The value returned by fn can be accessed through the future object returned (by calling its member future::get).

The second version (2) lets the caller select a specific launching policy, while the first version (1) uses automatic selection, as if calling (2) with launch::async|launch::deferred as policy.

The function temporarily stores in the shared state either the threading handler used or decay copies of fn and args (as a deferred function) without making it ready. Once the execution of fn is completed, the shared state contains the value returned by fn and is made ready.!async!policy
A bitmask value of type launch indicating the launching policy:
policy description
launch::async Asynchronous: Launches a new thread to call fn (as if a thread object is constructed with fn and args as arguments, and accessing the shared state of the returned future joins it).
launch::deferred Deferred: The call to fn is deferred until the shared state of the returned future is accessed (with wait or get). At that point, fn is called and the function is no longer considered deferred. When this call returns, the shared state of the returned future is made ready.
launch::async|launch::deferred Automatic: The function chooses the policy automatically (at some point). This depends on the system and library implementation, which generally optimizes for the current availability of concurrency in the system.
Particular library implementations may support additional launching policies, with the proper label defined in type launch. Combining multiple values is possible, in which case, the function automatically chooses one among them.
fn
A pointer to function, pointer to member, or any kind of move-constructible function object (i.e., an object whose class defines operator(), including closures and function objects).
The function uses a decay copy of this argument.
The return value of fn is stored as the shared state to be retrieved by the future object returned by async.
If fn throws, the exception is set in the shared state to be retrieved by the future object.
args...
Arguments passed to the call to fn (if any). Their types shall be move-constructible.
If fn is a member pointer, the first argument shall be an object for which that member is defined (or a reference, or a pointer to it).
The function uses decay copies of these arguments.
Fn and Args... are template parameters: if implicitly deduced, these are the proper lvalue or rvalue reference types of the arguments. Note though, that the function uses decay copies of fn and args... (see std::ref for a wrapper class that makes references copyable).!A future object whose shared state is made ready when the execution of fn ends. The value retrieved by its member future::get is the value returned by fn (if any).

When launch::async is selected, the future returned is linked to the end of the thread created, even if its shared state is never accessed: in this case, its destructor synchronizes with the return of fn. Therefore, the return value shall not be disregarded for asynchronous behavior, even when fn returns void.

result_of::type is the type returned by Fn when called with arguments of the types in Args.!thread
Thread (class )
packaged_task
Packaged task (class template )!X!
Cplusplus!const error_category& future_category() noexcept;
Return future category
Returns a reference to the static object of the error_category type that has the following characteristics:
Its name member function returns a pointer to the character sequence "future"
Its equivalent and default_error_condition member functions behave as specified for the base error_category class.

error_condition objects describing errors that correspond to the enum type future_errc are associated to this category. What constitutes one of these correspondences depends on the operating system and the particular library implementation.!future_category!none!A reference to the future error_category object.!future_errc
Error conditions for future objects (enum class )!X!
